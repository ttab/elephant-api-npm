/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "spell/service.proto" (package "elephant.spell", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message elephant.spell.SupportedLanguagesRequest
 */
export interface SupportedLanguagesRequest {
}
/**
 * @generated from protobuf message elephant.spell.SupportedLanguagesResponse
 */
export interface SupportedLanguagesResponse {
    /**
     * Languages that can be used for spellchecking.
     *
     * @generated from protobuf field: repeated elephant.spell.Language languages = 1
     */
    languages: Language[];
}
/**
 * @generated from protobuf message elephant.spell.Language
 */
export interface Language {
    /**
     * Code for the language.
     *
     * @generated from protobuf field: string code = 1
     */
    code: string;
}
/**
 * @generated from protobuf message elephant.spell.TextRequest
 */
export interface TextRequest {
    /**
     * Text to spellcheck.
     *
     * @generated from protobuf field: repeated string text = 1
     */
    text: string[];
    /**
     * Language to check the text for.
     *
     * @generated from protobuf field: string language = 2
     */
    language: string;
}
/**
 * @generated from protobuf message elephant.spell.TextResponse
 */
export interface TextResponse {
    /**
     * @generated from protobuf field: repeated elephant.spell.Misspelled misspelled = 1
     */
    misspelled: Misspelled[];
}
/**
 * @generated from protobuf message elephant.spell.Misspelled
 */
export interface Misspelled {
    /**
     * @generated from protobuf field: repeated elephant.spell.MisspelledEntry entries = 1
     */
    entries: MisspelledEntry[];
}
/**
 * @generated from protobuf message elephant.spell.MisspelledEntry
 */
export interface MisspelledEntry {
    /**
     * Text that was used in the source text.
     *
     * @generated from protobuf field: string text = 1
     */
    text: string;
    /**
     * Suggestions for replacements.
     *
     * @generated from protobuf field: repeated elephant.spell.Suggestion suggestions = 2
     */
    suggestions: Suggestion[];
}
/**
 * @generated from protobuf message elephant.spell.Suggestion
 */
export interface Suggestion {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
}
/**
 * @generated from protobuf message elephant.spell.ListEntriesRequest
 */
export interface ListEntriesRequest {
    /**
     * Language to list entries for.
     *
     * @generated from protobuf field: string language = 1
     */
    language: string;
    /**
     * Page to return.
     *
     * @generated from protobuf field: int64 page = 2
     */
    page: bigint;
    /**
     * Prefix to filter entries by.
     *
     * @generated from protobuf field: string prefix = 3
     */
    prefix: string;
    /**
     * Status to filter entries by
     *
     * @generated from protobuf field: string status = 4
     */
    status: string;
}
/**
 * @generated from protobuf message elephant.spell.ListEntriesResponse
 */
export interface ListEntriesResponse {
    /**
     * @generated from protobuf field: repeated elephant.spell.CustomEntry entries = 1
     */
    entries: CustomEntry[];
}
/**
 * @generated from protobuf message elephant.spell.CustomEntry
 */
export interface CustomEntry {
    /**
     * Language the entry is for.
     *
     * @generated from protobuf field: string language = 1
     */
    language: string;
    /**
     * Text is the word (or phrase) itself.
     *
     * @generated from protobuf field: string text = 2
     */
    text: string;
    /**
     * Status of the entry, this is used for moderation.
     *
     * @generated from protobuf field: string status = 3
     */
    status: string;
    /**
     * Description of the entry.
     *
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * CommonMistakes when writing the word or phrase. This is used to pre-filter
     * text that is spell-checked.
     *
     * @generated from protobuf field: repeated string common_mistakes = 5
     */
    commonMistakes: string[];
}
/**
 * @generated from protobuf message elephant.spell.ListDictionariesRequest
 */
export interface ListDictionariesRequest {
}
/**
 * @generated from protobuf message elephant.spell.ListDictionariesResponse
 */
export interface ListDictionariesResponse {
    /**
     * @generated from protobuf field: repeated elephant.spell.CustomDictionary dictionaries = 1
     */
    dictionaries: CustomDictionary[];
}
/**
 * @generated from protobuf message elephant.spell.CustomDictionary
 */
export interface CustomDictionary {
    /**
     * Language the dictionary is for.
     *
     * @generated from protobuf field: string language = 1
     */
    language: string;
    /**
     * EntryCount for the dictionary.
     *
     * @generated from protobuf field: int64 entry_count = 2
     */
    entryCount: bigint;
}
/**
 * @generated from protobuf message elephant.spell.GetEntryRequest
 */
export interface GetEntryRequest {
    /**
     * Language the entry is for.
     *
     * @generated from protobuf field: string language = 1
     */
    language: string;
    /**
     * Text is the word or phrase to get the entry for.
     *
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message elephant.spell.GetEntryResponse
 */
export interface GetEntryResponse {
    /**
     * Entry information.
     *
     * @generated from protobuf field: elephant.spell.CustomEntry entry = 1
     */
    entry?: CustomEntry;
}
/**
 * @generated from protobuf message elephant.spell.SetEntryRequest
 */
export interface SetEntryRequest {
    /**
     * Entry to set.
     *
     * @generated from protobuf field: elephant.spell.CustomEntry entry = 1
     */
    entry?: CustomEntry;
}
/**
 * @generated from protobuf message elephant.spell.SetEntryResponse
 */
export interface SetEntryResponse {
}
/**
 * @generated from protobuf message elephant.spell.DeleteEntryRequest
 */
export interface DeleteEntryRequest {
    /**
     * Language the entry is for.
     *
     * @generated from protobuf field: string language = 1
     */
    language: string;
    /**
     * Text is the word or phrase to delete.
     *
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message elephant.spell.DeleteEntryResponse
 */
export interface DeleteEntryResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class SupportedLanguagesRequest$Type extends MessageType<SupportedLanguagesRequest> {
    constructor() {
        super("elephant.spell.SupportedLanguagesRequest", []);
    }
    create(value?: PartialMessage<SupportedLanguagesRequest>): SupportedLanguagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SupportedLanguagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupportedLanguagesRequest): SupportedLanguagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupportedLanguagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.SupportedLanguagesRequest
 */
export const SupportedLanguagesRequest = new SupportedLanguagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportedLanguagesResponse$Type extends MessageType<SupportedLanguagesResponse> {
    constructor() {
        super("elephant.spell.SupportedLanguagesResponse", [
            { no: 1, name: "languages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Language }
        ]);
    }
    create(value?: PartialMessage<SupportedLanguagesResponse>): SupportedLanguagesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.languages = [];
        if (value !== undefined)
            reflectionMergePartial<SupportedLanguagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupportedLanguagesResponse): SupportedLanguagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.spell.Language languages */ 1:
                    message.languages.push(Language.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupportedLanguagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.spell.Language languages = 1; */
        for (let i = 0; i < message.languages.length; i++)
            Language.internalBinaryWrite(message.languages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.SupportedLanguagesResponse
 */
export const SupportedLanguagesResponse = new SupportedLanguagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Language$Type extends MessageType<Language> {
    constructor() {
        super("elephant.spell.Language", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Language>): Language {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<Language>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Language): Language {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Language, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.Language
 */
export const Language = new Language$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextRequest$Type extends MessageType<TextRequest> {
    constructor() {
        super("elephant.spell.TextRequest", [
            { no: 1, name: "text", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TextRequest>): TextRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = [];
        message.language = "";
        if (value !== undefined)
            reflectionMergePartial<TextRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextRequest): TextRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string text */ 1:
                    message.text.push(reader.string());
                    break;
                case /* string language */ 2:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string text = 1; */
        for (let i = 0; i < message.text.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.text[i]);
        /* string language = 2; */
        if (message.language !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.TextRequest
 */
export const TextRequest = new TextRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextResponse$Type extends MessageType<TextResponse> {
    constructor() {
        super("elephant.spell.TextResponse", [
            { no: 1, name: "misspelled", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Misspelled }
        ]);
    }
    create(value?: PartialMessage<TextResponse>): TextResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.misspelled = [];
        if (value !== undefined)
            reflectionMergePartial<TextResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextResponse): TextResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.spell.Misspelled misspelled */ 1:
                    message.misspelled.push(Misspelled.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.spell.Misspelled misspelled = 1; */
        for (let i = 0; i < message.misspelled.length; i++)
            Misspelled.internalBinaryWrite(message.misspelled[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.TextResponse
 */
export const TextResponse = new TextResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Misspelled$Type extends MessageType<Misspelled> {
    constructor() {
        super("elephant.spell.Misspelled", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MisspelledEntry }
        ]);
    }
    create(value?: PartialMessage<Misspelled>): Misspelled {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<Misspelled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Misspelled): Misspelled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.spell.MisspelledEntry entries */ 1:
                    message.entries.push(MisspelledEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Misspelled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.spell.MisspelledEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            MisspelledEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.Misspelled
 */
export const Misspelled = new Misspelled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MisspelledEntry$Type extends MessageType<MisspelledEntry> {
    constructor() {
        super("elephant.spell.MisspelledEntry", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "suggestions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Suggestion }
        ]);
    }
    create(value?: PartialMessage<MisspelledEntry>): MisspelledEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.suggestions = [];
        if (value !== undefined)
            reflectionMergePartial<MisspelledEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MisspelledEntry): MisspelledEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* repeated elephant.spell.Suggestion suggestions */ 2:
                    message.suggestions.push(Suggestion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MisspelledEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* repeated elephant.spell.Suggestion suggestions = 2; */
        for (let i = 0; i < message.suggestions.length; i++)
            Suggestion.internalBinaryWrite(message.suggestions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.MisspelledEntry
 */
export const MisspelledEntry = new MisspelledEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Suggestion$Type extends MessageType<Suggestion> {
    constructor() {
        super("elephant.spell.Suggestion", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Suggestion>): Suggestion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<Suggestion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Suggestion): Suggestion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Suggestion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.Suggestion
 */
export const Suggestion = new Suggestion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntriesRequest$Type extends MessageType<ListEntriesRequest> {
    constructor() {
        super("elephant.spell.ListEntriesRequest", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListEntriesRequest>): ListEntriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.page = 0n;
        message.prefix = "";
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<ListEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntriesRequest): ListEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* int64 page */ 2:
                    message.page = reader.int64().toBigInt();
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                case /* string status */ 4:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* int64 page = 2; */
        if (message.page !== 0n)
            writer.tag(2, WireType.Varint).int64(message.page);
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        /* string status = 4; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.ListEntriesRequest
 */
export const ListEntriesRequest = new ListEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntriesResponse$Type extends MessageType<ListEntriesResponse> {
    constructor() {
        super("elephant.spell.ListEntriesResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CustomEntry }
        ]);
    }
    create(value?: PartialMessage<ListEntriesResponse>): ListEntriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<ListEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntriesResponse): ListEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.spell.CustomEntry entries */ 1:
                    message.entries.push(CustomEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.spell.CustomEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CustomEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.ListEntriesResponse
 */
export const ListEntriesResponse = new ListEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomEntry$Type extends MessageType<CustomEntry> {
    constructor() {
        super("elephant.spell.CustomEntry", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "common_mistakes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomEntry>): CustomEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.text = "";
        message.status = "";
        message.description = "";
        message.commonMistakes = [];
        if (value !== undefined)
            reflectionMergePartial<CustomEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomEntry): CustomEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated string common_mistakes */ 5:
                    message.commonMistakes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated string common_mistakes = 5; */
        for (let i = 0; i < message.commonMistakes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.commonMistakes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.CustomEntry
 */
export const CustomEntry = new CustomEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDictionariesRequest$Type extends MessageType<ListDictionariesRequest> {
    constructor() {
        super("elephant.spell.ListDictionariesRequest", []);
    }
    create(value?: PartialMessage<ListDictionariesRequest>): ListDictionariesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListDictionariesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDictionariesRequest): ListDictionariesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDictionariesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.ListDictionariesRequest
 */
export const ListDictionariesRequest = new ListDictionariesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDictionariesResponse$Type extends MessageType<ListDictionariesResponse> {
    constructor() {
        super("elephant.spell.ListDictionariesResponse", [
            { no: 1, name: "dictionaries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CustomDictionary }
        ]);
    }
    create(value?: PartialMessage<ListDictionariesResponse>): ListDictionariesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dictionaries = [];
        if (value !== undefined)
            reflectionMergePartial<ListDictionariesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDictionariesResponse): ListDictionariesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.spell.CustomDictionary dictionaries */ 1:
                    message.dictionaries.push(CustomDictionary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDictionariesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.spell.CustomDictionary dictionaries = 1; */
        for (let i = 0; i < message.dictionaries.length; i++)
            CustomDictionary.internalBinaryWrite(message.dictionaries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.ListDictionariesResponse
 */
export const ListDictionariesResponse = new ListDictionariesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomDictionary$Type extends MessageType<CustomDictionary> {
    constructor() {
        super("elephant.spell.CustomDictionary", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entry_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CustomDictionary>): CustomDictionary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.entryCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<CustomDictionary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomDictionary): CustomDictionary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* int64 entry_count */ 2:
                    message.entryCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomDictionary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* int64 entry_count = 2; */
        if (message.entryCount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.entryCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.CustomDictionary
 */
export const CustomDictionary = new CustomDictionary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEntryRequest$Type extends MessageType<GetEntryRequest> {
    constructor() {
        super("elephant.spell.GetEntryRequest", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetEntryRequest>): GetEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<GetEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEntryRequest): GetEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.GetEntryRequest
 */
export const GetEntryRequest = new GetEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEntryResponse$Type extends MessageType<GetEntryResponse> {
    constructor() {
        super("elephant.spell.GetEntryResponse", [
            { no: 1, name: "entry", kind: "message", T: () => CustomEntry }
        ]);
    }
    create(value?: PartialMessage<GetEntryResponse>): GetEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEntryResponse): GetEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.spell.CustomEntry entry */ 1:
                    message.entry = CustomEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.spell.CustomEntry entry = 1; */
        if (message.entry)
            CustomEntry.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.GetEntryResponse
 */
export const GetEntryResponse = new GetEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEntryRequest$Type extends MessageType<SetEntryRequest> {
    constructor() {
        super("elephant.spell.SetEntryRequest", [
            { no: 1, name: "entry", kind: "message", T: () => CustomEntry }
        ]);
    }
    create(value?: PartialMessage<SetEntryRequest>): SetEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEntryRequest): SetEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.spell.CustomEntry entry */ 1:
                    message.entry = CustomEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.spell.CustomEntry entry = 1; */
        if (message.entry)
            CustomEntry.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.SetEntryRequest
 */
export const SetEntryRequest = new SetEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEntryResponse$Type extends MessageType<SetEntryResponse> {
    constructor() {
        super("elephant.spell.SetEntryResponse", []);
    }
    create(value?: PartialMessage<SetEntryResponse>): SetEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEntryResponse): SetEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.SetEntryResponse
 */
export const SetEntryResponse = new SetEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteEntryRequest$Type extends MessageType<DeleteEntryRequest> {
    constructor() {
        super("elephant.spell.DeleteEntryRequest", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteEntryRequest>): DeleteEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteEntryRequest): DeleteEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.DeleteEntryRequest
 */
export const DeleteEntryRequest = new DeleteEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteEntryResponse$Type extends MessageType<DeleteEntryResponse> {
    constructor() {
        super("elephant.spell.DeleteEntryResponse", []);
    }
    create(value?: PartialMessage<DeleteEntryResponse>): DeleteEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteEntryResponse): DeleteEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.spell.DeleteEntryResponse
 */
export const DeleteEntryResponse = new DeleteEntryResponse$Type();
/**
 * @generated ServiceType for protobuf service elephant.spell.Check
 */
export const Check = new ServiceType("elephant.spell.Check", [
    { name: "Text", options: {}, I: TextRequest, O: TextResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.spell.Dictionaries
 */
export const Dictionaries = new ServiceType("elephant.spell.Dictionaries", [
    { name: "SupportedLanguages", options: {}, I: SupportedLanguagesRequest, O: SupportedLanguagesResponse },
    { name: "ListDictionaries", options: {}, I: ListDictionariesRequest, O: ListDictionariesResponse },
    { name: "ListEntries", options: {}, I: ListEntriesRequest, O: ListEntriesResponse },
    { name: "GetEntry", options: {}, I: GetEntryRequest, O: GetEntryResponse },
    { name: "SetEntry", options: {}, I: SetEntryRequest, O: SetEntryResponse },
    { name: "DeleteEntry", options: {}, I: DeleteEntryRequest, O: DeleteEntryResponse }
]);

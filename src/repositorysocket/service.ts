/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "repositorysocket/service.proto" (package "elephant.repositorysocket", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EventlogItem } from "../repository/service";
import { Document } from "../newsdoc/newsdoc";
import { DocumentMeta } from "../repository/service";
import { DocumentFilter } from "../repository/service";
import { Timespan } from "../repository/service";
/**
 * @generated from protobuf message elephant.repositorysocket.Call
 */
export interface Call {
    /**
     * CallID uniquely identifies this call and will be referenced in the
     * response.
     *
     * @generated from protobuf field: string call_id = 1
     */
    callId: string;
    /**
     * @generated from protobuf field: elephant.repositorysocket.Authenticate authenticate = 2
     */
    authenticate?: Authenticate;
    /**
     * @generated from protobuf field: elephant.repositorysocket.GetDocuments get_documents = 3
     */
    getDocuments?: GetDocuments;
    /**
     * @generated from protobuf field: elephant.repositorysocket.CloseDocumentSet close_document_set = 4
     */
    closeDocumentSet?: CloseDocumentSet;
}
/**
 * @generated from protobuf message elephant.repositorysocket.Response
 */
export interface Response {
    /**
     * CallID is the ID of the call that this is a response to.
     *
     * @generated from protobuf field: string call_id = 1
     */
    callId: string;
    /**
     * Error is set if the call failed.
     *
     * @generated from protobuf field: elephant.repositorysocket.Error error = 2
     */
    error?: Error;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentBatch document_batch = 3
     */
    documentBatch?: DocumentBatch;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentUpdate document_update = 4
     */
    documentUpdate?: DocumentUpdate;
    /**
     * @generated from protobuf field: elephant.repositorysocket.InclusionBatch inclusion_batch = 5
     */
    inclusionBatch?: InclusionBatch;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentRemoved removed = 6
     */
    removed?: DocumentRemoved;
    /**
     * Handled is true when the call has been completely handled without errors.
     *
     * @generated from protobuf field: bool handled = 7
     */
    handled: boolean;
}
/**
 * Error is used to communicate errors.
 *
 * @generated from protobuf message elephant.repositorysocket.Error
 */
export interface Error {
    /**
     * ErrorCode classifying the error.
     *
     * @generated from protobuf field: string error_code = 1
     */
    errorCode: string;
    /**
     * ErrorMessage describing the error.
     *
     * @generated from protobuf field: string error_message = 2
     */
    errorMessage: string;
}
/**
 * Authenticate is used to authenticate a connection. The socket will be closed
 * if the client fails to reauthenticate before the token expires. The socket
 * will also be closed if the user sub changes between authenticate calls.
 *
 * Responds with RespSuccess if the connection is successfully authenticated.
 *
 * @generated from protobuf message elephant.repositorysocket.Authenticate
 */
export interface Authenticate {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * GetDocuments is used to fetch and optionally subscribe to a set of documents.
 *
 * Responds with a series of RespGetDocumentsBatch followed by
 * RespDocumentUpdate as changes occur.
 *
 * @generated from protobuf message elephant.repositorysocket.GetDocuments
 */
export interface GetDocuments {
    /**
     * SetName is the name of the document set. Required when subscribing.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Type of the documents to get.
     *
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * Timespan is the inclusive time range to get documents for. Optional, this
     * is only available for document types with time expressions and/or
     * deliverables.
     *
     * @generated from protobuf field: elephant.repository.Timespan timespan = 3
     */
    timespan?: Timespan;
    /**
     * Labels are the labels that the documents must match.
     *
     * @generated from protobuf field: repeated string labels = 4
     */
    labels: string[];
    /**
     * Filter to apply to the documents.
     *
     * @generated from protobuf field: elephant.repository.DocumentFilter filter = 5
     */
    filter?: DocumentFilter;
    /**
     * Include will include documents with an UUID that matches the uuid of the
     * newdoc extraction expression. Timespans, labels and filters will not be
     * applied to included documents.
     *
     * @generated from protobuf field: repeated string include = 6
     */
    include: string[];
    /**
     * IncludeACLs should be set to true to include ACL update events in the
     * stream of updates.
     *
     * @generated from protobuf field: bool include_acls = 7
     */
    includeAcls: boolean;
}
/**
 * CloseDocumentSet is used to stop recieving updates for a document set.
 *
 * Responds with RespSuccess if the set was closed, or error code 'not_found' if
 * the document set is unknown.
 *
 * @generated from protobuf message elephant.repositorysocket.CloseDocumentSet
 */
export interface CloseDocumentSet {
    /**
     * SetName is the name of the document set to close.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
}
/**
 * DocumentBatch is emitted in response to a CallGetDocuments message. Multiple
 * batch messages can be emitted for a single get documents call.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentBatch
 */
export interface DocumentBatch {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Documents is a batch of documents that are included in the set.
     *
     * @generated from protobuf field: repeated elephant.repositorysocket.DocumentState documents = 2
     */
    documents: DocumentState[];
    /**
     * FinalBatch is set to true for the last batch in the response.
     *
     * @generated from protobuf field: bool final_batch = 3
     */
    finalBatch: boolean;
}
/**
 * @generated from protobuf message elephant.repositorysocket.DocumentState
 */
export interface DocumentState {
    /**
     * Meta information about the document.
     *
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 1
     */
    meta?: DocumentMeta;
    /**
     * Document is the document itself.
     *
     * @generated from protobuf field: newsdoc.Document document = 2
     */
    document?: Document;
}
/**
 * DocumentUpdate is emitted when a write operation has affected a document in a
 * set.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Event is the change event for the document.
     *
     * @generated from protobuf field: elephant.repository.EventlogItem event = 2
     */
    event?: EventlogItem;
    /**
     * Meta information about the document, only included if the document is newly
     * added to the document set.
     *
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 3
     */
    meta?: DocumentMeta;
    /**
     * Document is included for document update events or if the document is newly
     * added to the document set.
     *
     * @generated from protobuf field: newsdoc.Document document = 4
     */
    document?: Document;
    /**
     * Included is true if the update is for a document that was added through
     * inclusion.
     *
     * @generated from protobuf field: bool included = 5
     */
    included: boolean;
}
/**
 * DocumentRemoved is emitted when a document is removed from the set.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentRemoved
 */
export interface DocumentRemoved {
    /**
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * @generated from protobuf field: string document_uuid = 2
     */
    documentUuid: string;
}
/**
 * InclusionBatch is emitted when documents are first included by documents in
 * the set.
 *
 * @generated from protobuf message elephant.repositorysocket.InclusionBatch
 */
export interface InclusionBatch {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Documents is a batch of documents that are included in the set.
     *
     * @generated from protobuf field: repeated elephant.repositorysocket.InclusionDocument documents = 2
     */
    documents: InclusionDocument[];
}
/**
 * InclusionDocument is a document that was referenced by a document in the set.
 *
 * @generated from protobuf message elephant.repositorysocket.InclusionDocument
 */
export interface InclusionDocument {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentState state = 2
     */
    state?: DocumentState;
}
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("elephant.repositorysocket.Call", [
            { no: 1, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authenticate", kind: "message", T: () => Authenticate },
            { no: 3, name: "get_documents", kind: "message", T: () => GetDocuments },
            { no: 4, name: "close_document_set", kind: "message", T: () => CloseDocumentSet }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.callId = "";
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_id */ 1:
                    message.callId = reader.string();
                    break;
                case /* elephant.repositorysocket.Authenticate authenticate */ 2:
                    message.authenticate = Authenticate.internalBinaryRead(reader, reader.uint32(), options, message.authenticate);
                    break;
                case /* elephant.repositorysocket.GetDocuments get_documents */ 3:
                    message.getDocuments = GetDocuments.internalBinaryRead(reader, reader.uint32(), options, message.getDocuments);
                    break;
                case /* elephant.repositorysocket.CloseDocumentSet close_document_set */ 4:
                    message.closeDocumentSet = CloseDocumentSet.internalBinaryRead(reader, reader.uint32(), options, message.closeDocumentSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_id = 1; */
        if (message.callId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callId);
        /* elephant.repositorysocket.Authenticate authenticate = 2; */
        if (message.authenticate)
            Authenticate.internalBinaryWrite(message.authenticate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.GetDocuments get_documents = 3; */
        if (message.getDocuments)
            GetDocuments.internalBinaryWrite(message.getDocuments, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.CloseDocumentSet close_document_set = 4; */
        if (message.closeDocumentSet)
            CloseDocumentSet.internalBinaryWrite(message.closeDocumentSet, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Call
 */
export const Call = new Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("elephant.repositorysocket.Response", [
            { no: 1, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "message", T: () => Error },
            { no: 3, name: "document_batch", kind: "message", T: () => DocumentBatch },
            { no: 4, name: "document_update", kind: "message", T: () => DocumentUpdate },
            { no: 5, name: "inclusion_batch", kind: "message", T: () => InclusionBatch },
            { no: 6, name: "removed", kind: "message", T: () => DocumentRemoved },
            { no: 7, name: "handled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.callId = "";
        message.handled = false;
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_id */ 1:
                    message.callId = reader.string();
                    break;
                case /* elephant.repositorysocket.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* elephant.repositorysocket.DocumentBatch document_batch */ 3:
                    message.documentBatch = DocumentBatch.internalBinaryRead(reader, reader.uint32(), options, message.documentBatch);
                    break;
                case /* elephant.repositorysocket.DocumentUpdate document_update */ 4:
                    message.documentUpdate = DocumentUpdate.internalBinaryRead(reader, reader.uint32(), options, message.documentUpdate);
                    break;
                case /* elephant.repositorysocket.InclusionBatch inclusion_batch */ 5:
                    message.inclusionBatch = InclusionBatch.internalBinaryRead(reader, reader.uint32(), options, message.inclusionBatch);
                    break;
                case /* elephant.repositorysocket.DocumentRemoved removed */ 6:
                    message.removed = DocumentRemoved.internalBinaryRead(reader, reader.uint32(), options, message.removed);
                    break;
                case /* bool handled */ 7:
                    message.handled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_id = 1; */
        if (message.callId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callId);
        /* elephant.repositorysocket.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentBatch document_batch = 3; */
        if (message.documentBatch)
            DocumentBatch.internalBinaryWrite(message.documentBatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentUpdate document_update = 4; */
        if (message.documentUpdate)
            DocumentUpdate.internalBinaryWrite(message.documentUpdate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.InclusionBatch inclusion_batch = 5; */
        if (message.inclusionBatch)
            InclusionBatch.internalBinaryWrite(message.inclusionBatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentRemoved removed = 6; */
        if (message.removed)
            DocumentRemoved.internalBinaryWrite(message.removed, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool handled = 7; */
        if (message.handled !== false)
            writer.tag(7, WireType.Varint).bool(message.handled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("elephant.repositorysocket.Error", [
            { no: 1, name: "error_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error_code */ 1:
                    message.errorCode = reader.string();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error_code = 1; */
        if (message.errorCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorCode);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Authenticate$Type extends MessageType<Authenticate> {
    constructor() {
        super("elephant.repositorysocket.Authenticate", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Authenticate>): Authenticate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<Authenticate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Authenticate): Authenticate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Authenticate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Authenticate
 */
export const Authenticate = new Authenticate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocuments$Type extends MessageType<GetDocuments> {
    constructor() {
        super("elephant.repositorysocket.GetDocuments", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timespan", kind: "message", T: () => Timespan },
            { no: 4, name: "labels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filter", kind: "message", T: () => DocumentFilter },
            { no: 6, name: "include", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "include_acls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocuments>): GetDocuments {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.type = "";
        message.labels = [];
        message.include = [];
        message.includeAcls = false;
        if (value !== undefined)
            reflectionMergePartial<GetDocuments>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocuments): GetDocuments {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* elephant.repository.Timespan timespan */ 3:
                    message.timespan = Timespan.internalBinaryRead(reader, reader.uint32(), options, message.timespan);
                    break;
                case /* repeated string labels */ 4:
                    message.labels.push(reader.string());
                    break;
                case /* elephant.repository.DocumentFilter filter */ 5:
                    message.filter = DocumentFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* repeated string include */ 6:
                    message.include.push(reader.string());
                    break;
                case /* bool include_acls */ 7:
                    message.includeAcls = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocuments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* elephant.repository.Timespan timespan = 3; */
        if (message.timespan)
            Timespan.internalBinaryWrite(message.timespan, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string labels = 4; */
        for (let i = 0; i < message.labels.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.labels[i]);
        /* elephant.repository.DocumentFilter filter = 5; */
        if (message.filter)
            DocumentFilter.internalBinaryWrite(message.filter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string include = 6; */
        for (let i = 0; i < message.include.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.include[i]);
        /* bool include_acls = 7; */
        if (message.includeAcls !== false)
            writer.tag(7, WireType.Varint).bool(message.includeAcls);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.GetDocuments
 */
export const GetDocuments = new GetDocuments$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseDocumentSet$Type extends MessageType<CloseDocumentSet> {
    constructor() {
        super("elephant.repositorysocket.CloseDocumentSet", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloseDocumentSet>): CloseDocumentSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        if (value !== undefined)
            reflectionMergePartial<CloseDocumentSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseDocumentSet): CloseDocumentSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseDocumentSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.CloseDocumentSet
 */
export const CloseDocumentSet = new CloseDocumentSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentBatch$Type extends MessageType<DocumentBatch> {
    constructor() {
        super("elephant.repositorysocket.DocumentBatch", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocumentState },
            { no: 3, name: "final_batch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentBatch>): DocumentBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documents = [];
        message.finalBatch = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentBatch): DocumentBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* repeated elephant.repositorysocket.DocumentState documents */ 2:
                    message.documents.push(DocumentState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool final_batch */ 3:
                    message.finalBatch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* repeated elephant.repositorysocket.DocumentState documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            DocumentState.internalBinaryWrite(message.documents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool final_batch = 3; */
        if (message.finalBatch !== false)
            writer.tag(3, WireType.Varint).bool(message.finalBatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentBatch
 */
export const DocumentBatch = new DocumentBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentState$Type extends MessageType<DocumentState> {
    constructor() {
        super("elephant.repositorysocket.DocumentState", [
            { no: 1, name: "meta", kind: "message", T: () => DocumentMeta },
            { no: 2, name: "document", kind: "message", T: () => Document }
        ]);
    }
    create(value?: PartialMessage<DocumentState>): DocumentState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocumentState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentState): DocumentState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentMeta meta */ 1:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* newsdoc.Document document */ 2:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentMeta meta = 1; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* newsdoc.Document document = 2; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentState
 */
export const DocumentState = new DocumentState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentUpdate$Type extends MessageType<DocumentUpdate> {
    constructor() {
        super("elephant.repositorysocket.DocumentUpdate", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event", kind: "message", T: () => EventlogItem },
            { no: 3, name: "meta", kind: "message", T: () => DocumentMeta },
            { no: 4, name: "document", kind: "message", T: () => Document },
            { no: 5, name: "included", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentUpdate>): DocumentUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.included = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentUpdate): DocumentUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* elephant.repository.EventlogItem event */ 2:
                    message.event = EventlogItem.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                case /* elephant.repository.DocumentMeta meta */ 3:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* newsdoc.Document document */ 4:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* bool included */ 5:
                    message.included = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* elephant.repository.EventlogItem event = 2; */
        if (message.event)
            EventlogItem.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.DocumentMeta meta = 3; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* newsdoc.Document document = 4; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool included = 5; */
        if (message.included !== false)
            writer.tag(5, WireType.Varint).bool(message.included);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentUpdate
 */
export const DocumentUpdate = new DocumentUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentRemoved$Type extends MessageType<DocumentRemoved> {
    constructor() {
        super("elephant.repositorysocket.DocumentRemoved", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentRemoved>): DocumentRemoved {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documentUuid = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentRemoved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentRemoved): DocumentRemoved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* string document_uuid */ 2:
                    message.documentUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentRemoved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* string document_uuid = 2; */
        if (message.documentUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.documentUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentRemoved
 */
export const DocumentRemoved = new DocumentRemoved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InclusionBatch$Type extends MessageType<InclusionBatch> {
    constructor() {
        super("elephant.repositorysocket.InclusionBatch", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => InclusionDocument }
        ]);
    }
    create(value?: PartialMessage<InclusionBatch>): InclusionBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documents = [];
        if (value !== undefined)
            reflectionMergePartial<InclusionBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InclusionBatch): InclusionBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* repeated elephant.repositorysocket.InclusionDocument documents */ 2:
                    message.documents.push(InclusionDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InclusionBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* repeated elephant.repositorysocket.InclusionDocument documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            InclusionDocument.internalBinaryWrite(message.documents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.InclusionBatch
 */
export const InclusionBatch = new InclusionBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InclusionDocument$Type extends MessageType<InclusionDocument> {
    constructor() {
        super("elephant.repositorysocket.InclusionDocument", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "message", T: () => DocumentState }
        ]);
    }
    create(value?: PartialMessage<InclusionDocument>): InclusionDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<InclusionDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InclusionDocument): InclusionDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* elephant.repositorysocket.DocumentState state */ 2:
                    message.state = DocumentState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InclusionDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* elephant.repositorysocket.DocumentState state = 2; */
        if (message.state)
            DocumentState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.InclusionDocument
 */
export const InclusionDocument = new InclusionDocument$Type();

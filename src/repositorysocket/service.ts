/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "repositorysocket/service.proto" (package "elephant.repositorysocket", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Document } from "../newsdoc/newsdoc";
import { DocumentMeta } from "../repository/service";
import { DocumentFilter } from "../repository/service";
import { Timespan } from "../repository/service";
import { ExtractedValues } from "../repository/service";
import { EventlogItem as EventlogItem$ } from "../repository/service";
/**
 * @generated from protobuf message elephant.repositorysocket.Call
 */
export interface Call {
    /**
     * CallID uniquely identifies this call and will be referenced in the
     * response.
     *
     * @generated from protobuf field: string call_id = 1
     */
    callId: string;
    /**
     * @generated from protobuf field: elephant.repositorysocket.Authenticate authenticate = 2
     */
    authenticate?: Authenticate;
    /**
     * @generated from protobuf field: elephant.repositorysocket.GetDocuments get_documents = 3
     */
    getDocuments?: GetDocuments;
    /**
     * @generated from protobuf field: elephant.repositorysocket.CloseDocumentSet close_document_set = 4
     */
    closeDocumentSet?: CloseDocumentSet;
    /**
     * @generated from protobuf field: elephant.repositorysocket.GetEventlog get_eventlog = 5
     */
    getEventlog?: GetEventlog;
    /**
     * @generated from protobuf field: elephant.repositorysocket.CloseEventlog close_eventlog = 6
     */
    closeEventlog?: CloseEventlog;
}
/**
 * @generated from protobuf message elephant.repositorysocket.Response
 */
export interface Response {
    /**
     * CallID is the ID of the call that this is a response to.
     *
     * @generated from protobuf field: string call_id = 1
     */
    callId: string;
    /**
     * Error is set if the call failed.
     *
     * @generated from protobuf field: elephant.repositorysocket.Error error = 2
     */
    error?: Error;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentBatch document_batch = 3
     */
    documentBatch?: DocumentBatch;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentUpdate document_update = 4
     */
    documentUpdate?: DocumentUpdate;
    /**
     * @generated from protobuf field: elephant.repositorysocket.InclusionBatch inclusion_batch = 5
     */
    inclusionBatch?: InclusionBatch;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentRemoved removed = 6
     */
    removed?: DocumentRemoved;
    /**
     * Handled is true when the call has been completely handled without
     * errors. For calls that create subscriptions this means that the
     * subscription has been created successfully.
     *
     * @generated from protobuf field: bool handled = 7
     */
    handled: boolean;
    /**
     * Events from the eventlog.
     *
     * @generated from protobuf field: elephant.repositorysocket.EventlogResponse events = 8
     */
    events?: EventlogResponse;
}
/**
 * Error is used to communicate errors.
 *
 * @generated from protobuf message elephant.repositorysocket.Error
 */
export interface Error {
    /**
     * ErrorCode classifying the error.
     *
     * @generated from protobuf field: string error_code = 1
     */
    errorCode: string;
    /**
     * ErrorMessage describing the error.
     *
     * @generated from protobuf field: string error_message = 2
     */
    errorMessage: string;
}
/**
 * Authenticate is used to authenticate a connection. The socket will be closed
 * if the client fails to reauthenticate before the token expires. The socket
 * will also be closed if the user sub changes between authenticate calls.
 *
 * Responds with RespSuccess if the connection is successfully authenticated.
 *
 * @generated from protobuf message elephant.repositorysocket.Authenticate
 */
export interface Authenticate {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message elephant.repositorysocket.GetEventlog
 */
export interface GetEventlog {
    /**
     * Name of the eventlog subscription. Opening an eventlog subscription with
     * the same name as an existing subscription will close the existing
     * subscription. This can be used together with `from` to update a
     * subscription without missing events.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * After allows the client to subscribe from after a given event ID. The
     * server only buffers a limited amount of events (defaults to 100) and
     * requesting events from before the range of that buffer will result in a
     * resume out of bounds "eventlog_resume_oob" error.
     *
     * @generated from protobuf field: optional int64 after = 2
     */
    after?: bigint;
    /**
     * DocumentTypes for which the client wants events for. If no types are
     * provided all types will be included.
     *
     * @generated from protobuf field: repeated string document_types = 3
     */
    documentTypes: string[];
    /**
     * Languages that the client wants events for. If no languages are provided
     * all languages will be included. If a document switches language the event for
     * the switch will be included even if the new document version doesn't have a
     * matching language anymore.
     *
     * @generated from protobuf field: repeated string languages = 4
     */
    languages: string[];
    /**
     * TypeSubsets are used to apply subset newsdoc value
     * extractors to documents and include the results with the event data. Keyed
     * by document type.
     *
     * @generated from protobuf field: map<string, string> type_subsets = 5
     */
    typeSubsets: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repositorysocket.EventlogResponse
 */
export interface EventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repositorysocket.EventlogItem items = 1
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repositorysocket.EventlogItem
 */
export interface EventlogItem {
    /**
     * Event from the eventlog.
     *
     * @generated from protobuf field: elephant.repository.EventlogItem event = 1
     */
    event?: EventlogItem$;
    /**
     * Subset is the extracted subset of the document. Only provided if this is a
     * document event and subset expressions have been defined for the type.
     *
     * @generated from protobuf field: repeated elephant.repository.ExtractedValues subset = 2
     */
    subset: ExtractedValues[];
}
/**
 * @generated from protobuf message elephant.repositorysocket.CloseEventlog
 */
export interface CloseEventlog {
    /**
     * Name of the eventlog subscription to close.
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * GetDocuments is used to fetch and optionally subscribe to a set of documents.
 *
 * Responds with a series of RespGetDocumentsBatch followed by
 * RespDocumentUpdate as changes occur.
 *
 * @generated from protobuf message elephant.repositorysocket.GetDocuments
 */
export interface GetDocuments {
    /**
     * SetName is the name of the document set. Required when subscribing.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Type of the documents to get.
     *
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * Timespan is the inclusive time range to get documents for. Optional, this
     * is only available for document types with time expressions and/or
     * deliverables.
     *
     * @generated from protobuf field: elephant.repository.Timespan timespan = 3
     */
    timespan?: Timespan;
    /**
     * Labels are the labels that the documents must match.
     *
     * @generated from protobuf field: repeated string labels = 4
     */
    labels: string[];
    /**
     * Filter to apply to the documents.
     *
     * @generated from protobuf field: elephant.repository.DocumentFilter filter = 5
     */
    filter?: DocumentFilter;
    /**
     * Include will include documents with an UUID that matches the uuid of the
     * newdoc extraction expression. Timespans, labels and filters will not be
     * applied to included documents.
     *
     * @generated from protobuf field: repeated string include = 6
     */
    include: string[];
    /**
     * IncludeACLs should be set to true to include ACL update events in the
     * stream of updates.
     *
     * @generated from protobuf field: bool include_acls = 7
     */
    includeAcls: boolean;
    /**
     * Subset returns a subset of the document as specified by a list of newsdoc
     * value extractors.
     *
     * @generated from protobuf field: repeated string subset = 8
     */
    subset: string[];
    /**
     * InclusionSubsets are used to apply subset newsdoc value extractors to
     * included documents. Keyed by document type.
     *
     * @generated from protobuf field: map<string, string> inclusion_subsets = 9
     */
    inclusionSubsets: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repositorysocket.InclusionSubset
 */
export interface InclusionSubset {
    /**
     * Expressions to use to extract document contents.
     *
     * @generated from protobuf field: repeated string expressions = 1
     */
    expressions: string[];
}
/**
 * CloseDocumentSet is used to stop recieving updates for a document set.
 *
 * Responds with RespSuccess if the set was closed, or error code 'not_found' if
 * the document set is unknown.
 *
 * @generated from protobuf message elephant.repositorysocket.CloseDocumentSet
 */
export interface CloseDocumentSet {
    /**
     * SetName is the name of the document set to close.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
}
/**
 * DocumentBatch is emitted in response to a CallGetDocuments message. Multiple
 * batch messages can be emitted for a single get documents call.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentBatch
 */
export interface DocumentBatch {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Documents is a batch of documents that are included in the set.
     *
     * @generated from protobuf field: repeated elephant.repositorysocket.DocumentState documents = 2
     */
    documents: DocumentState[];
    /**
     * FinalBatch is set to true for the last batch in the response.
     *
     * @generated from protobuf field: bool final_batch = 3
     */
    finalBatch: boolean;
}
/**
 * @generated from protobuf message elephant.repositorysocket.DocumentState
 */
export interface DocumentState {
    /**
     * Meta information about the document.
     *
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 1
     */
    meta?: DocumentMeta;
    /**
     * Document is the document itself.
     *
     * @generated from protobuf field: newsdoc.Document document = 2
     */
    document?: Document;
    /**
     * Subset is the extracted subset of the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ExtractedValues subset = 3
     */
    subset: ExtractedValues[];
}
/**
 * DocumentUpdate is emitted when a write operation has affected a document in a
 * set.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Event is the change event for the document.
     *
     * @generated from protobuf field: elephant.repository.EventlogItem event = 2
     */
    event?: EventlogItem$;
    /**
     * Meta information about the document, only included if the document is newly
     * added to the document set.
     *
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 3
     */
    meta?: DocumentMeta;
    /**
     * Document is included for document update events or if the document is newly
     * added to the document set.
     *
     * @generated from protobuf field: newsdoc.Document document = 4
     */
    document?: Document;
    /**
     * Included is true if the update is for a document that was added through
     * inclusion.
     *
     * @generated from protobuf field: bool included = 5
     */
    included: boolean;
    /**
     * Subset is the extracted subset of the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ExtractedValues subset = 6
     */
    subset: ExtractedValues[];
}
/**
 * DocumentRemoved is emitted when a document is removed from the set.
 *
 * @generated from protobuf message elephant.repositorysocket.DocumentRemoved
 */
export interface DocumentRemoved {
    /**
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * @generated from protobuf field: string document_uuid = 2
     */
    documentUuid: string;
}
/**
 * InclusionBatch is emitted when documents are first included by documents in
 * the set.
 *
 * @generated from protobuf message elephant.repositorysocket.InclusionBatch
 */
export interface InclusionBatch {
    /**
     * SetName is the name of the set that result is for.
     *
     * @generated from protobuf field: string set_name = 1
     */
    setName: string;
    /**
     * Documents is a batch of documents that are included in the set.
     *
     * @generated from protobuf field: repeated elephant.repositorysocket.InclusionDocument documents = 2
     */
    documents: InclusionDocument[];
}
/**
 * InclusionDocument is a document that was referenced by a document in the set.
 *
 * @generated from protobuf message elephant.repositorysocket.InclusionDocument
 */
export interface InclusionDocument {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
    /**
     * @generated from protobuf field: elephant.repositorysocket.DocumentState state = 2
     */
    state?: DocumentState;
}
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("elephant.repositorysocket.Call", [
            { no: 1, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authenticate", kind: "message", T: () => Authenticate },
            { no: 3, name: "get_documents", kind: "message", T: () => GetDocuments },
            { no: 4, name: "close_document_set", kind: "message", T: () => CloseDocumentSet },
            { no: 5, name: "get_eventlog", kind: "message", T: () => GetEventlog },
            { no: 6, name: "close_eventlog", kind: "message", T: () => CloseEventlog }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.callId = "";
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_id */ 1:
                    message.callId = reader.string();
                    break;
                case /* elephant.repositorysocket.Authenticate authenticate */ 2:
                    message.authenticate = Authenticate.internalBinaryRead(reader, reader.uint32(), options, message.authenticate);
                    break;
                case /* elephant.repositorysocket.GetDocuments get_documents */ 3:
                    message.getDocuments = GetDocuments.internalBinaryRead(reader, reader.uint32(), options, message.getDocuments);
                    break;
                case /* elephant.repositorysocket.CloseDocumentSet close_document_set */ 4:
                    message.closeDocumentSet = CloseDocumentSet.internalBinaryRead(reader, reader.uint32(), options, message.closeDocumentSet);
                    break;
                case /* elephant.repositorysocket.GetEventlog get_eventlog */ 5:
                    message.getEventlog = GetEventlog.internalBinaryRead(reader, reader.uint32(), options, message.getEventlog);
                    break;
                case /* elephant.repositorysocket.CloseEventlog close_eventlog */ 6:
                    message.closeEventlog = CloseEventlog.internalBinaryRead(reader, reader.uint32(), options, message.closeEventlog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_id = 1; */
        if (message.callId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callId);
        /* elephant.repositorysocket.Authenticate authenticate = 2; */
        if (message.authenticate)
            Authenticate.internalBinaryWrite(message.authenticate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.GetDocuments get_documents = 3; */
        if (message.getDocuments)
            GetDocuments.internalBinaryWrite(message.getDocuments, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.CloseDocumentSet close_document_set = 4; */
        if (message.closeDocumentSet)
            CloseDocumentSet.internalBinaryWrite(message.closeDocumentSet, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.GetEventlog get_eventlog = 5; */
        if (message.getEventlog)
            GetEventlog.internalBinaryWrite(message.getEventlog, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.CloseEventlog close_eventlog = 6; */
        if (message.closeEventlog)
            CloseEventlog.internalBinaryWrite(message.closeEventlog, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Call
 */
export const Call = new Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("elephant.repositorysocket.Response", [
            { no: 1, name: "call_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "message", T: () => Error },
            { no: 3, name: "document_batch", kind: "message", T: () => DocumentBatch },
            { no: 4, name: "document_update", kind: "message", T: () => DocumentUpdate },
            { no: 5, name: "inclusion_batch", kind: "message", T: () => InclusionBatch },
            { no: 6, name: "removed", kind: "message", T: () => DocumentRemoved },
            { no: 7, name: "handled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "events", kind: "message", T: () => EventlogResponse }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.callId = "";
        message.handled = false;
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string call_id */ 1:
                    message.callId = reader.string();
                    break;
                case /* elephant.repositorysocket.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* elephant.repositorysocket.DocumentBatch document_batch */ 3:
                    message.documentBatch = DocumentBatch.internalBinaryRead(reader, reader.uint32(), options, message.documentBatch);
                    break;
                case /* elephant.repositorysocket.DocumentUpdate document_update */ 4:
                    message.documentUpdate = DocumentUpdate.internalBinaryRead(reader, reader.uint32(), options, message.documentUpdate);
                    break;
                case /* elephant.repositorysocket.InclusionBatch inclusion_batch */ 5:
                    message.inclusionBatch = InclusionBatch.internalBinaryRead(reader, reader.uint32(), options, message.inclusionBatch);
                    break;
                case /* elephant.repositorysocket.DocumentRemoved removed */ 6:
                    message.removed = DocumentRemoved.internalBinaryRead(reader, reader.uint32(), options, message.removed);
                    break;
                case /* bool handled */ 7:
                    message.handled = reader.bool();
                    break;
                case /* elephant.repositorysocket.EventlogResponse events */ 8:
                    message.events = EventlogResponse.internalBinaryRead(reader, reader.uint32(), options, message.events);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string call_id = 1; */
        if (message.callId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.callId);
        /* elephant.repositorysocket.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentBatch document_batch = 3; */
        if (message.documentBatch)
            DocumentBatch.internalBinaryWrite(message.documentBatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentUpdate document_update = 4; */
        if (message.documentUpdate)
            DocumentUpdate.internalBinaryWrite(message.documentUpdate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.InclusionBatch inclusion_batch = 5; */
        if (message.inclusionBatch)
            InclusionBatch.internalBinaryWrite(message.inclusionBatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repositorysocket.DocumentRemoved removed = 6; */
        if (message.removed)
            DocumentRemoved.internalBinaryWrite(message.removed, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool handled = 7; */
        if (message.handled !== false)
            writer.tag(7, WireType.Varint).bool(message.handled);
        /* elephant.repositorysocket.EventlogResponse events = 8; */
        if (message.events)
            EventlogResponse.internalBinaryWrite(message.events, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("elephant.repositorysocket.Error", [
            { no: 1, name: "error_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error_code */ 1:
                    message.errorCode = reader.string();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error_code = 1; */
        if (message.errorCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorCode);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Authenticate$Type extends MessageType<Authenticate> {
    constructor() {
        super("elephant.repositorysocket.Authenticate", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Authenticate>): Authenticate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<Authenticate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Authenticate): Authenticate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Authenticate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.Authenticate
 */
export const Authenticate = new Authenticate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlog$Type extends MessageType<GetEventlog> {
    constructor() {
        super("elephant.repositorysocket.GetEventlog", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "after", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "document_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "languages", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type_subsets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetEventlog>): GetEventlog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.documentTypes = [];
        message.languages = [];
        message.typeSubsets = {};
        if (value !== undefined)
            reflectionMergePartial<GetEventlog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlog): GetEventlog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int64 after */ 2:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* repeated string document_types */ 3:
                    message.documentTypes.push(reader.string());
                    break;
                case /* repeated string languages */ 4:
                    message.languages.push(reader.string());
                    break;
                case /* map<string, string> type_subsets */ 5:
                    this.binaryReadMap5(message.typeSubsets, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: GetEventlog["typeSubsets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetEventlog["typeSubsets"] | undefined, val: GetEventlog["typeSubsets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for elephant.repositorysocket.GetEventlog.type_subsets");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetEventlog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int64 after = 2; */
        if (message.after !== undefined)
            writer.tag(2, WireType.Varint).int64(message.after);
        /* repeated string document_types = 3; */
        for (let i = 0; i < message.documentTypes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.documentTypes[i]);
        /* repeated string languages = 4; */
        for (let i = 0; i < message.languages.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.languages[i]);
        /* map<string, string> type_subsets = 5; */
        for (let k of globalThis.Object.keys(message.typeSubsets))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.typeSubsets[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.GetEventlog
 */
export const GetEventlog = new GetEventlog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventlogResponse$Type extends MessageType<EventlogResponse> {
    constructor() {
        super("elephant.repositorysocket.EventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<EventlogResponse>): EventlogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<EventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventlogResponse): EventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repositorysocket.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repositorysocket.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.EventlogResponse
 */
export const EventlogResponse = new EventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventlogItem$Type extends MessageType<EventlogItem> {
    constructor() {
        super("elephant.repositorysocket.EventlogItem", [
            { no: 1, name: "event", kind: "message", T: () => EventlogItem$ },
            { no: 2, name: "subset", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExtractedValues }
        ]);
    }
    create(value?: PartialMessage<EventlogItem>): EventlogItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subset = [];
        if (value !== undefined)
            reflectionMergePartial<EventlogItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventlogItem): EventlogItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.EventlogItem event */ 1:
                    message.event = EventlogItem$.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                case /* repeated elephant.repository.ExtractedValues subset */ 2:
                    message.subset.push(ExtractedValues.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventlogItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.EventlogItem event = 1; */
        if (message.event)
            EventlogItem$.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.ExtractedValues subset = 2; */
        for (let i = 0; i < message.subset.length; i++)
            ExtractedValues.internalBinaryWrite(message.subset[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.EventlogItem
 */
export const EventlogItem = new EventlogItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseEventlog$Type extends MessageType<CloseEventlog> {
    constructor() {
        super("elephant.repositorysocket.CloseEventlog", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloseEventlog>): CloseEventlog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CloseEventlog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseEventlog): CloseEventlog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseEventlog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.CloseEventlog
 */
export const CloseEventlog = new CloseEventlog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocuments$Type extends MessageType<GetDocuments> {
    constructor() {
        super("elephant.repositorysocket.GetDocuments", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timespan", kind: "message", T: () => Timespan },
            { no: 4, name: "labels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filter", kind: "message", T: () => DocumentFilter },
            { no: 6, name: "include", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "include_acls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "subset", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "inclusion_subsets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetDocuments>): GetDocuments {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.type = "";
        message.labels = [];
        message.include = [];
        message.includeAcls = false;
        message.subset = [];
        message.inclusionSubsets = {};
        if (value !== undefined)
            reflectionMergePartial<GetDocuments>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocuments): GetDocuments {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* elephant.repository.Timespan timespan */ 3:
                    message.timespan = Timespan.internalBinaryRead(reader, reader.uint32(), options, message.timespan);
                    break;
                case /* repeated string labels */ 4:
                    message.labels.push(reader.string());
                    break;
                case /* elephant.repository.DocumentFilter filter */ 5:
                    message.filter = DocumentFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* repeated string include */ 6:
                    message.include.push(reader.string());
                    break;
                case /* bool include_acls */ 7:
                    message.includeAcls = reader.bool();
                    break;
                case /* repeated string subset */ 8:
                    message.subset.push(reader.string());
                    break;
                case /* map<string, string> inclusion_subsets */ 9:
                    this.binaryReadMap9(message.inclusionSubsets, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: GetDocuments["inclusionSubsets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetDocuments["inclusionSubsets"] | undefined, val: GetDocuments["inclusionSubsets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for elephant.repositorysocket.GetDocuments.inclusion_subsets");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetDocuments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* elephant.repository.Timespan timespan = 3; */
        if (message.timespan)
            Timespan.internalBinaryWrite(message.timespan, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string labels = 4; */
        for (let i = 0; i < message.labels.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.labels[i]);
        /* elephant.repository.DocumentFilter filter = 5; */
        if (message.filter)
            DocumentFilter.internalBinaryWrite(message.filter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string include = 6; */
        for (let i = 0; i < message.include.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.include[i]);
        /* bool include_acls = 7; */
        if (message.includeAcls !== false)
            writer.tag(7, WireType.Varint).bool(message.includeAcls);
        /* repeated string subset = 8; */
        for (let i = 0; i < message.subset.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.subset[i]);
        /* map<string, string> inclusion_subsets = 9; */
        for (let k of globalThis.Object.keys(message.inclusionSubsets))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.inclusionSubsets[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.GetDocuments
 */
export const GetDocuments = new GetDocuments$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InclusionSubset$Type extends MessageType<InclusionSubset> {
    constructor() {
        super("elephant.repositorysocket.InclusionSubset", [
            { no: 1, name: "expressions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InclusionSubset>): InclusionSubset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.expressions = [];
        if (value !== undefined)
            reflectionMergePartial<InclusionSubset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InclusionSubset): InclusionSubset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string expressions */ 1:
                    message.expressions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InclusionSubset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string expressions = 1; */
        for (let i = 0; i < message.expressions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.expressions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.InclusionSubset
 */
export const InclusionSubset = new InclusionSubset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseDocumentSet$Type extends MessageType<CloseDocumentSet> {
    constructor() {
        super("elephant.repositorysocket.CloseDocumentSet", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloseDocumentSet>): CloseDocumentSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        if (value !== undefined)
            reflectionMergePartial<CloseDocumentSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseDocumentSet): CloseDocumentSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseDocumentSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.CloseDocumentSet
 */
export const CloseDocumentSet = new CloseDocumentSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentBatch$Type extends MessageType<DocumentBatch> {
    constructor() {
        super("elephant.repositorysocket.DocumentBatch", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocumentState },
            { no: 3, name: "final_batch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentBatch>): DocumentBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documents = [];
        message.finalBatch = false;
        if (value !== undefined)
            reflectionMergePartial<DocumentBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentBatch): DocumentBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* repeated elephant.repositorysocket.DocumentState documents */ 2:
                    message.documents.push(DocumentState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool final_batch */ 3:
                    message.finalBatch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* repeated elephant.repositorysocket.DocumentState documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            DocumentState.internalBinaryWrite(message.documents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool final_batch = 3; */
        if (message.finalBatch !== false)
            writer.tag(3, WireType.Varint).bool(message.finalBatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentBatch
 */
export const DocumentBatch = new DocumentBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentState$Type extends MessageType<DocumentState> {
    constructor() {
        super("elephant.repositorysocket.DocumentState", [
            { no: 1, name: "meta", kind: "message", T: () => DocumentMeta },
            { no: 2, name: "document", kind: "message", T: () => Document },
            { no: 3, name: "subset", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExtractedValues }
        ]);
    }
    create(value?: PartialMessage<DocumentState>): DocumentState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subset = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentState): DocumentState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentMeta meta */ 1:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* newsdoc.Document document */ 2:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* repeated elephant.repository.ExtractedValues subset */ 3:
                    message.subset.push(ExtractedValues.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentMeta meta = 1; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* newsdoc.Document document = 2; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.ExtractedValues subset = 3; */
        for (let i = 0; i < message.subset.length; i++)
            ExtractedValues.internalBinaryWrite(message.subset[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentState
 */
export const DocumentState = new DocumentState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentUpdate$Type extends MessageType<DocumentUpdate> {
    constructor() {
        super("elephant.repositorysocket.DocumentUpdate", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event", kind: "message", T: () => EventlogItem$ },
            { no: 3, name: "meta", kind: "message", T: () => DocumentMeta },
            { no: 4, name: "document", kind: "message", T: () => Document },
            { no: 5, name: "included", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "subset", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ExtractedValues }
        ]);
    }
    create(value?: PartialMessage<DocumentUpdate>): DocumentUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.included = false;
        message.subset = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentUpdate): DocumentUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* elephant.repository.EventlogItem event */ 2:
                    message.event = EventlogItem$.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                case /* elephant.repository.DocumentMeta meta */ 3:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* newsdoc.Document document */ 4:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* bool included */ 5:
                    message.included = reader.bool();
                    break;
                case /* repeated elephant.repository.ExtractedValues subset */ 6:
                    message.subset.push(ExtractedValues.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* elephant.repository.EventlogItem event = 2; */
        if (message.event)
            EventlogItem$.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.DocumentMeta meta = 3; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* newsdoc.Document document = 4; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool included = 5; */
        if (message.included !== false)
            writer.tag(5, WireType.Varint).bool(message.included);
        /* repeated elephant.repository.ExtractedValues subset = 6; */
        for (let i = 0; i < message.subset.length; i++)
            ExtractedValues.internalBinaryWrite(message.subset[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentUpdate
 */
export const DocumentUpdate = new DocumentUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentRemoved$Type extends MessageType<DocumentRemoved> {
    constructor() {
        super("elephant.repositorysocket.DocumentRemoved", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentRemoved>): DocumentRemoved {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documentUuid = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentRemoved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentRemoved): DocumentRemoved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* string document_uuid */ 2:
                    message.documentUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentRemoved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* string document_uuid = 2; */
        if (message.documentUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.documentUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.DocumentRemoved
 */
export const DocumentRemoved = new DocumentRemoved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InclusionBatch$Type extends MessageType<InclusionBatch> {
    constructor() {
        super("elephant.repositorysocket.InclusionBatch", [
            { no: 1, name: "set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => InclusionDocument }
        ]);
    }
    create(value?: PartialMessage<InclusionBatch>): InclusionBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setName = "";
        message.documents = [];
        if (value !== undefined)
            reflectionMergePartial<InclusionBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InclusionBatch): InclusionBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string set_name */ 1:
                    message.setName = reader.string();
                    break;
                case /* repeated elephant.repositorysocket.InclusionDocument documents */ 2:
                    message.documents.push(InclusionDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InclusionBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string set_name = 1; */
        if (message.setName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setName);
        /* repeated elephant.repositorysocket.InclusionDocument documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            InclusionDocument.internalBinaryWrite(message.documents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.InclusionBatch
 */
export const InclusionBatch = new InclusionBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InclusionDocument$Type extends MessageType<InclusionDocument> {
    constructor() {
        super("elephant.repositorysocket.InclusionDocument", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "message", T: () => DocumentState }
        ]);
    }
    create(value?: PartialMessage<InclusionDocument>): InclusionDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<InclusionDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InclusionDocument): InclusionDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* elephant.repositorysocket.DocumentState state */ 2:
                    message.state = DocumentState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InclusionDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* elephant.repositorysocket.DocumentState state = 2; */
        if (message.state)
            DocumentState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repositorysocket.InclusionDocument
 */
export const InclusionDocument = new InclusionDocument$Type();

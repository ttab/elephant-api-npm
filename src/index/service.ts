/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "index/service.proto" (package "elephant.index", syntax proto3)
// tslint:disable
// @ts-nocheck
import { GetMappingsResponseV1 } from "./search_v1";
import { GetMappingsRequestV1 } from "./search_v1";
import { QueryResponseV1 } from "./search_v1";
import { QueryRequestV1 } from "./search_v1";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message elephant.index.RegisterClusterRequest
 */
export interface RegisterClusterRequest {
    /**
     * Name used to identify the cluster.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Endpoint for the cluster.
     *
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * Auth is used to specify the authentication method.
     *
     * @generated from protobuf field: elephant.index.RegisterClusterAuth auth = 3;
     */
    auth?: RegisterClusterAuth;
}
/**
 * @generated from protobuf message elephant.index.RegisterClusterAuth
 */
export interface RegisterClusterAuth {
    /**
     * IAM authentication.
     *
     * @generated from protobuf field: bool iam = 1;
     */
    iam: boolean;
}
/**
 * @generated from protobuf message elephant.index.RegisterClusterResponse
 */
export interface RegisterClusterResponse {
}
/**
 * @generated from protobuf message elephant.index.ReindexRequest
 */
export interface ReindexRequest {
    /**
     * Cluster that we should re-index set to.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
}
/**
 * @generated from protobuf message elephant.index.ReindexResponse
 */
export interface ReindexResponse {
    /**
     * Name of the new index set.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.index.ListClustersRequest
 */
export interface ListClustersRequest {
}
/**
 * @generated from protobuf message elephant.index.ListClustersResponse
 */
export interface ListClustersResponse {
    /**
     * @generated from protobuf field: repeated elephant.index.Cluster clusters = 1;
     */
    clusters: Cluster[];
}
/**
 * @generated from protobuf message elephant.index.Cluster
 */
export interface Cluster {
    /**
     * Name used to identify the cluster.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Endpoint for the cluster.
     *
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * Number of index sets in the cluster.
     *
     * @generated from protobuf field: int64 index_set_count = 3;
     */
    indexSetCount: bigint;
    /**
     * Auth options for the cluster.
     *
     * @generated from protobuf field: elephant.index.ClusterAuth auth = 4;
     */
    auth?: ClusterAuth;
}
/**
 * @generated from protobuf message elephant.index.ClusterAuth
 */
export interface ClusterAuth {
    /**
     * IAM authentication.
     *
     * @generated from protobuf field: bool iam = 1;
     */
    iam: boolean;
}
/**
 * @generated from protobuf message elephant.index.DeleteClusterRequest
 */
export interface DeleteClusterRequest {
    /**
     * Name of the cluster to delete.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.index.DeleteClusterResponse
 */
export interface DeleteClusterResponse {
}
/**
 * @generated from protobuf message elephant.index.DeleteIndexSetRequest
 */
export interface DeleteIndexSetRequest {
    /**
     * Name of the index set to delete.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.index.DeleteIndexSetResponse
 */
export interface DeleteIndexSetResponse {
}
/**
 * @generated from protobuf message elephant.index.SetIndexSetStatusRequest
 */
export interface SetIndexSetStatusRequest {
    /**
     * Name of the index set to set the status of.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Active means that search requests are being routed to this index set. There
     * is always exactly one active index set at a time. Setting an index set to
     * active will deactivate but not disable the currently active index set.
     *
     * @generated from protobuf field: bool active = 2;
     */
    active: boolean;
    /**
     * ForceActive is used to force the activation of an index set that lags more
     * than 10 events behind the currently active set.
     *
     * @generated from protobuf field: bool force_active = 3;
     */
    forceActive: boolean;
    /**
     * Enabled means that documents should index to the index set. Disabling an
     * index set will only pause index seting, and it can later be
     * resumed. Disabling an index set does not deactivate it.
     *
     * @generated from protobuf field: bool enabled = 4;
     */
    enabled: boolean;
}
/**
 * @generated from protobuf message elephant.index.SetIndexSetStatusResponse
 */
export interface SetIndexSetStatusResponse {
}
/**
 * @generated from protobuf message elephant.index.PartialReindexRequest
 */
export interface PartialReindexRequest {
    /**
     * IndexSet to re-index.
     *
     * @generated from protobuf field: string index_set = 1;
     */
    indexSet: string;
    /**
     * Position to start from.
     *
     * @generated from protobuf field: int64 position = 2;
     */
    position: bigint;
}
/**
 * @generated from protobuf message elephant.index.PartialReindexResponse
 */
export interface PartialReindexResponse {
}
/**
 * @generated from protobuf message elephant.index.ListIndexSetsRequest
 */
export interface ListIndexSetsRequest {
    /**
     * Cluster can be used to filter by cluster.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * OnlyActive only returns the currently active index set.
     *
     * @generated from protobuf field: bool only_active = 2;
     */
    onlyActive: boolean;
    /**
     * Status can be used to filter index sets by their enabled/disabled status.
     *
     * @generated from protobuf field: elephant.index.EnabledFilter status = 3;
     */
    status: EnabledFilter;
    /**
     * Cursor to the page that should be returned. Omit to get the first page.
     *
     * @generated from protobuf field: string cursor = 4;
     */
    cursor: string;
}
/**
 * @generated from protobuf message elephant.index.ListIndexSetsResponse
 */
export interface ListIndexSetsResponse {
    /**
     * IndexSets that matched the criteria.
     *
     * @generated from protobuf field: repeated elephant.index.IndexSet index_sets = 1;
     */
    indexSets: IndexSet[];
    /**
     * NextPage cursor to use to get the next page of index sets. Empty if no more
     * index sets exist.
     *
     * @generated from protobuf field: string next_page = 2;
     */
    nextPage: string;
}
/**
 * @generated from protobuf message elephant.index.IndexSet
 */
export interface IndexSet {
    /**
     * Name of the index set.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Cluster that the index set has been created in.
     *
     * @generated from protobuf field: string cluster = 2;
     */
    cluster: string;
    /**
     * Enabled status of the index set.
     *
     * @generated from protobuf field: bool enabled = 3;
     */
    enabled: boolean;
    /**
     * Active status of the index set.
     *
     * @generated from protobuf field: bool active = 4;
     */
    active: boolean;
    /**
     * Position in the repository content log.
     *
     * @generated from protobuf field: int64 position = 5;
     */
    position: bigint;
}
/**
 * @generated from protobuf enum elephant.index.EnabledFilter
 */
export enum EnabledFilter {
    /**
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    STATUS_UNSPECIFIED = 0,
    /**
     * STATUS_ENABLED means that documents are currently being indexed to the
     * index set.
     *
     * @generated from protobuf enum value: STATUS_ENABLED = 1;
     */
    STATUS_ENABLED = 1,
    /**
     * STATUS_DISABLED means that no documents are being indexed to the index set.
     *
     * @generated from protobuf enum value: STATUS_DISABLED = 3;
     */
    STATUS_DISABLED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class RegisterClusterRequest$Type extends MessageType<RegisterClusterRequest> {
    constructor() {
        super("elephant.index.RegisterClusterRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "auth", kind: "message", T: () => RegisterClusterAuth }
        ]);
    }
    create(value?: PartialMessage<RegisterClusterRequest>): RegisterClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.endpoint = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterClusterRequest): RegisterClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* elephant.index.RegisterClusterAuth auth */ 3:
                    message.auth = RegisterClusterAuth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* elephant.index.RegisterClusterAuth auth = 3; */
        if (message.auth)
            RegisterClusterAuth.internalBinaryWrite(message.auth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.RegisterClusterRequest
 */
export const RegisterClusterRequest = new RegisterClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterClusterAuth$Type extends MessageType<RegisterClusterAuth> {
    constructor() {
        super("elephant.index.RegisterClusterAuth", [
            { no: 1, name: "iam", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterClusterAuth>): RegisterClusterAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iam = false;
        if (value !== undefined)
            reflectionMergePartial<RegisterClusterAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterClusterAuth): RegisterClusterAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool iam */ 1:
                    message.iam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterClusterAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool iam = 1; */
        if (message.iam !== false)
            writer.tag(1, WireType.Varint).bool(message.iam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.RegisterClusterAuth
 */
export const RegisterClusterAuth = new RegisterClusterAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterClusterResponse$Type extends MessageType<RegisterClusterResponse> {
    constructor() {
        super("elephant.index.RegisterClusterResponse", []);
    }
    create(value?: PartialMessage<RegisterClusterResponse>): RegisterClusterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterClusterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterClusterResponse): RegisterClusterResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterClusterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.RegisterClusterResponse
 */
export const RegisterClusterResponse = new RegisterClusterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReindexRequest$Type extends MessageType<ReindexRequest> {
    constructor() {
        super("elephant.index.ReindexRequest", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReindexRequest>): ReindexRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        if (value !== undefined)
            reflectionMergePartial<ReindexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReindexRequest): ReindexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReindexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ReindexRequest
 */
export const ReindexRequest = new ReindexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReindexResponse$Type extends MessageType<ReindexResponse> {
    constructor() {
        super("elephant.index.ReindexResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReindexResponse>): ReindexResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ReindexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReindexResponse): ReindexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReindexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ReindexResponse
 */
export const ReindexResponse = new ReindexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListClustersRequest$Type extends MessageType<ListClustersRequest> {
    constructor() {
        super("elephant.index.ListClustersRequest", []);
    }
    create(value?: PartialMessage<ListClustersRequest>): ListClustersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListClustersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListClustersRequest): ListClustersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListClustersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ListClustersRequest
 */
export const ListClustersRequest = new ListClustersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListClustersResponse$Type extends MessageType<ListClustersResponse> {
    constructor() {
        super("elephant.index.ListClustersResponse", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<ListClustersResponse>): ListClustersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<ListClustersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListClustersResponse): ListClustersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.index.Cluster clusters */ 1:
                    message.clusters.push(Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListClustersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.index.Cluster clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            Cluster.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ListClustersResponse
 */
export const ListClustersResponse = new ListClustersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("elephant.index.Cluster", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index_set_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "auth", kind: "message", T: () => ClusterAuth }
        ]);
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.endpoint = "";
        message.indexSetCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* int64 index_set_count */ 3:
                    message.indexSetCount = reader.int64().toBigInt();
                    break;
                case /* elephant.index.ClusterAuth auth */ 4:
                    message.auth = ClusterAuth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* int64 index_set_count = 3; */
        if (message.indexSetCount !== 0n)
            writer.tag(3, WireType.Varint).int64(message.indexSetCount);
        /* elephant.index.ClusterAuth auth = 4; */
        if (message.auth)
            ClusterAuth.internalBinaryWrite(message.auth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterAuth$Type extends MessageType<ClusterAuth> {
    constructor() {
        super("elephant.index.ClusterAuth", [
            { no: 1, name: "iam", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClusterAuth>): ClusterAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iam = false;
        if (value !== undefined)
            reflectionMergePartial<ClusterAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterAuth): ClusterAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool iam */ 1:
                    message.iam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool iam = 1; */
        if (message.iam !== false)
            writer.tag(1, WireType.Varint).bool(message.iam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ClusterAuth
 */
export const ClusterAuth = new ClusterAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteClusterRequest$Type extends MessageType<DeleteClusterRequest> {
    constructor() {
        super("elephant.index.DeleteClusterRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteClusterRequest>): DeleteClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteClusterRequest): DeleteClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.DeleteClusterRequest
 */
export const DeleteClusterRequest = new DeleteClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteClusterResponse$Type extends MessageType<DeleteClusterResponse> {
    constructor() {
        super("elephant.index.DeleteClusterResponse", []);
    }
    create(value?: PartialMessage<DeleteClusterResponse>): DeleteClusterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteClusterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteClusterResponse): DeleteClusterResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteClusterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.DeleteClusterResponse
 */
export const DeleteClusterResponse = new DeleteClusterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteIndexSetRequest$Type extends MessageType<DeleteIndexSetRequest> {
    constructor() {
        super("elephant.index.DeleteIndexSetRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteIndexSetRequest>): DeleteIndexSetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteIndexSetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteIndexSetRequest): DeleteIndexSetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteIndexSetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.DeleteIndexSetRequest
 */
export const DeleteIndexSetRequest = new DeleteIndexSetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteIndexSetResponse$Type extends MessageType<DeleteIndexSetResponse> {
    constructor() {
        super("elephant.index.DeleteIndexSetResponse", []);
    }
    create(value?: PartialMessage<DeleteIndexSetResponse>): DeleteIndexSetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteIndexSetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteIndexSetResponse): DeleteIndexSetResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteIndexSetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.DeleteIndexSetResponse
 */
export const DeleteIndexSetResponse = new DeleteIndexSetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIndexSetStatusRequest$Type extends MessageType<SetIndexSetStatusRequest> {
    constructor() {
        super("elephant.index.SetIndexSetStatusRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "force_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetIndexSetStatusRequest>): SetIndexSetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.active = false;
        message.forceActive = false;
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<SetIndexSetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIndexSetStatusRequest): SetIndexSetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool active */ 2:
                    message.active = reader.bool();
                    break;
                case /* bool force_active */ 3:
                    message.forceActive = reader.bool();
                    break;
                case /* bool enabled */ 4:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetIndexSetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool active = 2; */
        if (message.active !== false)
            writer.tag(2, WireType.Varint).bool(message.active);
        /* bool force_active = 3; */
        if (message.forceActive !== false)
            writer.tag(3, WireType.Varint).bool(message.forceActive);
        /* bool enabled = 4; */
        if (message.enabled !== false)
            writer.tag(4, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.SetIndexSetStatusRequest
 */
export const SetIndexSetStatusRequest = new SetIndexSetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIndexSetStatusResponse$Type extends MessageType<SetIndexSetStatusResponse> {
    constructor() {
        super("elephant.index.SetIndexSetStatusResponse", []);
    }
    create(value?: PartialMessage<SetIndexSetStatusResponse>): SetIndexSetStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetIndexSetStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIndexSetStatusResponse): SetIndexSetStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetIndexSetStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.SetIndexSetStatusResponse
 */
export const SetIndexSetStatusResponse = new SetIndexSetStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PartialReindexRequest$Type extends MessageType<PartialReindexRequest> {
    constructor() {
        super("elephant.index.PartialReindexRequest", [
            { no: 1, name: "index_set", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PartialReindexRequest>): PartialReindexRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.indexSet = "";
        message.position = 0n;
        if (value !== undefined)
            reflectionMergePartial<PartialReindexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PartialReindexRequest): PartialReindexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_set */ 1:
                    message.indexSet = reader.string();
                    break;
                case /* int64 position */ 2:
                    message.position = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PartialReindexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_set = 1; */
        if (message.indexSet !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.indexSet);
        /* int64 position = 2; */
        if (message.position !== 0n)
            writer.tag(2, WireType.Varint).int64(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.PartialReindexRequest
 */
export const PartialReindexRequest = new PartialReindexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PartialReindexResponse$Type extends MessageType<PartialReindexResponse> {
    constructor() {
        super("elephant.index.PartialReindexResponse", []);
    }
    create(value?: PartialMessage<PartialReindexResponse>): PartialReindexResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PartialReindexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PartialReindexResponse): PartialReindexResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PartialReindexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.PartialReindexResponse
 */
export const PartialReindexResponse = new PartialReindexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListIndexSetsRequest$Type extends MessageType<ListIndexSetsRequest> {
    constructor() {
        super("elephant.index.ListIndexSetsRequest", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "only_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "status", kind: "enum", T: () => ["elephant.index.EnabledFilter", EnabledFilter] },
            { no: 4, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListIndexSetsRequest>): ListIndexSetsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.onlyActive = false;
        message.status = 0;
        message.cursor = "";
        if (value !== undefined)
            reflectionMergePartial<ListIndexSetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListIndexSetsRequest): ListIndexSetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* bool only_active */ 2:
                    message.onlyActive = reader.bool();
                    break;
                case /* elephant.index.EnabledFilter status */ 3:
                    message.status = reader.int32();
                    break;
                case /* string cursor */ 4:
                    message.cursor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListIndexSetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* bool only_active = 2; */
        if (message.onlyActive !== false)
            writer.tag(2, WireType.Varint).bool(message.onlyActive);
        /* elephant.index.EnabledFilter status = 3; */
        if (message.status !== 0)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* string cursor = 4; */
        if (message.cursor !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ListIndexSetsRequest
 */
export const ListIndexSetsRequest = new ListIndexSetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListIndexSetsResponse$Type extends MessageType<ListIndexSetsResponse> {
    constructor() {
        super("elephant.index.ListIndexSetsResponse", [
            { no: 1, name: "index_sets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IndexSet },
            { no: 2, name: "next_page", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListIndexSetsResponse>): ListIndexSetsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.indexSets = [];
        message.nextPage = "";
        if (value !== undefined)
            reflectionMergePartial<ListIndexSetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListIndexSetsResponse): ListIndexSetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.index.IndexSet index_sets */ 1:
                    message.indexSets.push(IndexSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page */ 2:
                    message.nextPage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListIndexSetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.index.IndexSet index_sets = 1; */
        for (let i = 0; i < message.indexSets.length; i++)
            IndexSet.internalBinaryWrite(message.indexSets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page = 2; */
        if (message.nextPage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.ListIndexSetsResponse
 */
export const ListIndexSetsResponse = new ListIndexSetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexSet$Type extends MessageType<IndexSet> {
    constructor() {
        super("elephant.index.IndexSet", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "position", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IndexSet>): IndexSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.cluster = "";
        message.enabled = false;
        message.active = false;
        message.position = 0n;
        if (value !== undefined)
            reflectionMergePartial<IndexSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexSet): IndexSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string cluster */ 2:
                    message.cluster = reader.string();
                    break;
                case /* bool enabled */ 3:
                    message.enabled = reader.bool();
                    break;
                case /* bool active */ 4:
                    message.active = reader.bool();
                    break;
                case /* int64 position */ 5:
                    message.position = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string cluster = 2; */
        if (message.cluster !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cluster);
        /* bool enabled = 3; */
        if (message.enabled !== false)
            writer.tag(3, WireType.Varint).bool(message.enabled);
        /* bool active = 4; */
        if (message.active !== false)
            writer.tag(4, WireType.Varint).bool(message.active);
        /* int64 position = 5; */
        if (message.position !== 0n)
            writer.tag(5, WireType.Varint).int64(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.index.IndexSet
 */
export const IndexSet = new IndexSet$Type();
/**
 * @generated ServiceType for protobuf service elephant.index.Management
 */
export const Management = new ServiceType("elephant.index.Management", [
    { name: "RegisterCluster", options: {}, I: RegisterClusterRequest, O: RegisterClusterResponse },
    { name: "ListClusters", options: {}, I: ListClustersRequest, O: ListClustersResponse },
    { name: "DeleteCluster", options: {}, I: DeleteClusterRequest, O: DeleteClusterResponse },
    { name: "DeleteIndexSet", options: {}, I: DeleteIndexSetRequest, O: DeleteIndexSetResponse },
    { name: "Reindex", options: {}, I: ReindexRequest, O: ReindexResponse },
    { name: "PartialReindex", options: {}, I: PartialReindexRequest, O: PartialReindexResponse },
    { name: "ListIndexSets", options: {}, I: ListIndexSetsRequest, O: ListIndexSetsResponse },
    { name: "SetIndexSetStatus", options: {}, I: SetIndexSetStatusRequest, O: SetIndexSetStatusResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.index.SearchV1
 */
export const SearchV1 = new ServiceType("elephant.index.SearchV1", [
    { name: "Query", options: {}, I: QueryRequestV1, O: QueryResponseV1 },
    { name: "GetMappings", options: {}, I: GetMappingsRequestV1, O: GetMappingsResponseV1 }
]);

/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "repository/service.proto" (package "elephant.repository", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Document } from "../newsdoc/newsdoc";
/**
 * @generated from protobuf message elephant.repository.GetStatusRequest
 */
export interface GetStatusRequest {
    /**
     * UUID of the document to get the status history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Name of the status to get.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * ID of the status to get. Optional, will default to the latest status.
     *
     * @generated from protobuf field: int64 id = 3;
     */
    id: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusResponse
 */
export interface GetStatusResponse {
    /**
     * @generated from protobuf field: elephant.repository.Status status = 1;
     */
    status?: Status;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryRequest
 */
export interface GetStatusHistoryRequest {
    /**
     * UUID of the document to get the status history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Name of the status to get.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Before is a status ID used to page backwards through the status history. If
     * no ID or a zero ID is provided the list will start with the lastest status.
     *
     * @generated from protobuf field: int64 before = 3;
     */
    before: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryReponse
 */
export interface GetStatusHistoryReponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Status statuses = 1;
     */
    statuses: Status[];
}
/**
 * @generated from protobuf message elephant.repository.GetStatusOverviewRequest
 */
export interface GetStatusOverviewRequest {
    /**
     * UUIDs to get statuses for.
     *
     * @generated from protobuf field: repeated string uuids = 1;
     */
    uuids: string[];
    /**
     * Statuses to return information for.
     *
     * @generated from protobuf field: repeated string statuses = 2;
     */
    statuses: string[];
    /**
     * GetMeta can be used to load any set status metadata.
     *
     * @generated from protobuf field: bool get_meta = 3;
     */
    getMeta: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusOverviewResponse
 */
export interface GetStatusOverviewResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.StatusOverviewItem items = 1;
     */
    items: StatusOverviewItem[];
}
/**
 * @generated from protobuf message elephant.repository.StatusOverviewItem
 */
export interface StatusOverviewItem {
    /**
     * UUID of the document.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version the document is at.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Modified timestamp is the RFC3339 timestamp for the last change that
     * affected the document.
     *
     * @generated from protobuf field: string modified = 3;
     */
    modified: string;
    /**
     * Heads are the last statuses.
     *
     * @generated from protobuf field: map<string, elephant.repository.Status> heads = 4;
     */
    heads: {
        [key: string]: Status;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetPermissionsRequest
 */
export interface GetPermissionsRequest {
    /**
     * UUID of the document to get the permissions for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetPermissionsResponse
 */
export interface GetPermissionsResponse {
    /**
     * Permissions that the client has for the document. The map is keyed by the
     * permission the client has and the value is either the client subject, the
     * unit URI if the permission was granted through a unit membership, or
     * "scope://[name]" if it was granted through elevated privileges.
     *
     * @generated from protobuf field: map<string, string> permissions = 1;
     */
    permissions: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogRequest
 */
export interface GetEventlogRequest {
    /**
     * After specifies the event ID after which to start returning events. A
     * negative value of -N will start from the N most recent events.
     *
     * @generated from protobuf field: int64 after = 1;
     */
    after: bigint;
    /**
     * Wait is the maximum time to wait for new events. Defaults to 2000.
     *
     * @generated from protobuf field: int32 wait_ms = 2;
     */
    waitMs: number;
    /**
     * BatchSize is the number of events we want in the response. Defaults to 10.
     *
     * @generated from protobuf field: int32 batch_size = 3;
     */
    batchSize: number;
    /**
     * BatchWaitMs is the maximum time we wait for a batch to be filled. Defaults to 200.
     *
     * @generated from protobuf field: int32 batch_wait_ms = 4;
     */
    batchWaitMs: number;
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogResponse
 */
export interface GetEventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.EventlogItem items = 1;
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repository.GetCompactedEventlogRequest
 */
export interface GetCompactedEventlogRequest {
    /**
     * After specifies the event ID after which to start returning events.
     *
     * @generated from protobuf field: int64 after = 1;
     */
    after: bigint;
    /**
     * Until allows us to control the number of events we want to evaluate when
     * compacting. Must be between 1 and 10000 more than `after`, and cannot be
     * greater than the current last event.
     *
     * @generated from protobuf field: int64 until = 3;
     */
    until: bigint;
    /**
     * Limit restricts the number of events we want returned for each
     * call. Together with `offset` this allows us to page through the unique
     * document events between `after` and `until`. Defaults to 0, meaning no
     * limit.
     *
     * @generated from protobuf field: int32 limit = 4;
     */
    limit: number;
    /**
     * Offset allows us to skip N number of events relative to `after`. So while
     * `after` and until allows us to paginate through the log as a whole,
     * `offset` and `limit` allows us to page through the unique document events
     * between `after` and `until`. Defaults to 0, meaning no offset.
     *
     * @generated from protobuf field: int32 offset = 5;
     */
    offset: number;
    /**
     * Type is used to only return events for documents of the given
     * type. Defaults to empty, which will return events for all document types.
     *
     * @generated from protobuf field: string type = 6;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.GetCompactedEventlogResponse
 */
export interface GetCompactedEventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.EventlogItem items = 1;
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repository.EventlogItem
 */
export interface EventlogItem {
    /**
     * Id of the event.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Event type, one of: "document", "status", "acl", "delete_document",
     * "restore_finished".
     *
     * @generated from protobuf field: string event = 2;
     */
    event: string;
    /**
     * Uuid of the document that was affected.
     *
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * Timestamp that the event occurred, as an RFC3339 timestamp.
     *
     * @generated from protobuf field: string timestamp = 4;
     */
    timestamp: string;
    /**
     * Version of the document.
     *
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
    /**
     * Status that was affected, if it was a "status" event.
     *
     * @generated from protobuf field: string status = 6;
     */
    status: string;
    /**
     * StatusId is the ID of the created status.
     *
     * @generated from protobuf field: int64 status_id = 7;
     */
    statusId: bigint;
    /**
     * Acl entry, if it was an "acl" event.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 8;
     */
    acl: ACLEntry[];
    /**
     * UpdaterUri is the URI for the subject that performed the update.
     *
     * @generated from protobuf field: string updater_uri = 9;
     */
    updaterUri: string;
    /**
     * Type of the affected document.
     *
     * @generated from protobuf field: string type = 10;
     */
    type: string;
    /**
     * Language of the affected document.
     *
     * @generated from protobuf field: string language = 11;
     */
    language: string;
    /**
     * OldLanguage of the document if the document changed language.
     *
     * @generated from protobuf field: string old_language = 12;
     */
    oldLanguage: string;
    /**
     * MainDocument UUID if the document is a metadata document.
     *
     * @generated from protobuf field: string main_document = 13;
     */
    mainDocument: string;
    /**
     * SystemState is set to "restoring" if this event was generated from a
     * restore operation. If the event wasn't generated by a special operation it
     * is left empty.
     *
     * @generated from protobuf field: string system_state = 14;
     */
    systemState: string;
}
/**
 * @generated from protobuf message elephant.repository.RunReportRequest
 */
export interface RunReportRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.RunReportResponse
 */
export interface RunReportResponse {
    /**
     * @generated from protobuf field: repeated string tables = 1;
     */
    tables: string[];
    /**
     * @generated from protobuf field: bytes spreadsheet = 2;
     */
    spreadsheet: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.TestReportRequest
 */
export interface TestReportRequest {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
}
/**
 * @generated from protobuf message elephant.repository.TestReportResponse
 */
export interface TestReportResponse {
    /**
     * @generated from protobuf field: repeated string tables = 1;
     */
    tables: string[];
    /**
     * @generated from protobuf field: bytes spreadsheet = 2;
     */
    spreadsheet: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.DeleteReportRequest
 */
export interface DeleteReportRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteReportResponse
 */
export interface DeleteReportResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetReportRequest
 */
export interface GetReportRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.GetReportResponse
 */
export interface GetReportResponse {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: string next_execution = 3;
     */
    nextExecution: string;
}
/**
 * @generated from protobuf message elephant.repository.UpdateReportRequest
 */
export interface UpdateReportRequest {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
}
/**
 * @generated from protobuf message elephant.repository.ListReportsRequest
 */
export interface ListReportsRequest {
}
/**
 * @generated from protobuf message elephant.repository.ListReportsResponse
 */
export interface ListReportsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.ReportListItem reports = 1;
     */
    reports: ReportListItem[];
}
/**
 * @generated from protobuf message elephant.repository.ReportListItem
 */
export interface ReportListItem {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: string cron_expression = 3;
     */
    cronExpression: string;
    /**
     * @generated from protobuf field: string cron_timezone = 4;
     */
    cronTimezone: string; // (default UTC)
}
/**
 * @generated from protobuf message elephant.repository.Report
 */
export interface Report {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: bool generate_sheet = 3;
     */
    generateSheet: boolean;
    /**
     * @generated from protobuf field: string cron_expression = 4;
     */
    cronExpression: string;
    /**
     * @generated from protobuf field: string cron_timezone = 7;
     */
    cronTimezone: string; // (default UTC)
    /**
     * @generated from protobuf field: repeated string slack_channels = 5;
     */
    slackChannels: string[];
    /**
     * @generated from protobuf field: repeated elephant.repository.ReportQuery queries = 6;
     */
    queries: ReportQuery[];
}
/**
 * @generated from protobuf message elephant.repository.ReportQuery
 */
export interface ReportQuery {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated int32 summarise = 2;
     */
    summarise: number[];
    /**
     * @generated from protobuf field: string sql = 3;
     */
    sql: string;
    /**
     * @generated from protobuf field: repeated elephant.repository.ReportValue value_processing = 4;
     */
    valueProcessing: ReportValue[];
}
/**
 * @generated from protobuf message elephant.repository.ReportValue
 */
export interface ReportValue {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: repeated string processors = 2;
     */
    processors: string[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateReportResponse
 */
export interface UpdateReportResponse {
    /**
     * @generated from protobuf field: string next_execution = 1;
     */
    nextExecution: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesRequest
 */
export interface GetStatusRulesRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesResponse
 */
export interface GetStatusRulesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.StatusRule rules = 1;
     */
    rules: StatusRule[];
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesRequest
 */
export interface GetStatusesRequest {
}
/**
 * @generated from protobuf message elephant.repository.WorkflowStatus
 */
export interface WorkflowStatus {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesResponse
 */
export interface GetStatusesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.WorkflowStatus statuses = 1;
     */
    statuses: WorkflowStatus[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusRequest
 */
export interface UpdateStatusRequest {
    /**
     * Type that the status is valid for.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Name of the status.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Disabled disables the status so that it cannot be used when setting new
     * statuses.
     *
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusResponse
 */
export interface UpdateStatusResponse {
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleRequest
 */
export interface CreateStatusRuleRequest {
    /**
     * @generated from protobuf field: elephant.repository.StatusRule rule = 1;
     */
    rule?: StatusRule;
}
/**
 * @generated from protobuf message elephant.repository.StatusRule
 */
export interface StatusRule {
    /**
     * Type that the status rule applies to.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Name of the rule.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Description of the rule.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * AccessRule whether this rule acts as access control.
     *
     * @generated from protobuf field: bool access_rule = 4;
     */
    accessRule: boolean;
    /**
     * AppliesTo is a list of statuses that this rule applies to.
     *
     * @generated from protobuf field: repeated string applies_to = 5;
     */
    appliesTo: string[];
    /**
     * Expression that is evaluated for the rule.
     *
     * @generated from protobuf field: string expression = 7;
     */
    expression: string;
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleResponse
 */
export interface CreateStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export interface DeleteStatusRuleRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export interface DeleteStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentRequest
 */
export interface GetDocumentRequest {
    /**
     * UUID of the document to get.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version to get, omit to get latest (or use status).
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Status is used to fetch the version of the document references by the last
     * status update. Can be used instead of specifying a version.
     *
     * @generated from protobuf field: string status = 3;
     */
    status: string;
    /**
     * Lock will lock the document for updates. This only affects the creation of
     * new versions of the document, statuses can still be updated.
     *
     * @generated from protobuf field: bool lock = 4;
     */
    lock: boolean;
    /**
     * MetaDocument controls the inclusion of associated meta
     * documents. "META_INCLUDE" will include the document if it
     * exists. "META_ONLY" will only return the meta document, and will return a
     * not found error if it doesn't exist.
     *
     * @generated from protobuf field: elephant.repository.GetMetaDoc meta_document = 5;
     */
    metaDocument: GetMetaDoc;
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentResponse
 */
export interface GetDocumentResponse {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Status is returned if the document was requested by status name.
     *
     * @generated from protobuf field: elephant.repository.Status status = 3;
     */
    status?: Status;
    /**
     * Meta contains the meta document, if requested, and if it exists.
     *
     * @generated from protobuf field: elephant.repository.MetaDocument meta = 4;
     */
    meta?: MetaDocument;
    /**
     * IsMetaDocument is true if the document is a meta document.
     *
     * @generated from protobuf field: bool is_meta_document = 5;
     */
    isMetaDocument: boolean;
    /**
     * MainDocument is the UUID of the main document if this is a meta document.
     *
     * @generated from protobuf field: string main_document = 6;
     */
    mainDocument: string;
}
/**
 * @generated from protobuf message elephant.repository.BulkGetRequest
 */
export interface BulkGetRequest {
    /**
     * Documents to get.
     *
     * @generated from protobuf field: repeated elephant.repository.BulkGetReference documents = 1;
     */
    documents: BulkGetReference[];
}
/**
 * @generated from protobuf message elephant.repository.BulkGetReference
 */
export interface BulkGetReference {
    /**
     * UUID of the document to get.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version to get, omit to get latest.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.BulkGetResponse
 */
export interface BulkGetResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.BulkGetItem items = 1;
     */
    items: BulkGetItem[];
}
/**
 * @generated from protobuf message elephant.repository.BulkGetItem
 */
export interface BulkGetItem {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.MetaDocument
 */
export interface MetaDocument {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryRequest
 */
export interface GetHistoryRequest {
    /**
     * UUID of the document to get the history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Before is which version number we should start fetching history from, omit
     * to start with the latest version.
     *
     * @generated from protobuf field: int64 before = 2;
     */
    before: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryResponse
 */
export interface GetHistoryResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.DocumentVersion versions = 1;
     */
    versions: DocumentVersion[];
}
/**
 * @generated from protobuf message elephant.repository.DocumentVersion
 */
export interface DocumentVersion {
    /**
     * Version of the document.
     *
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * Created timestamp is the RFC3339 timestamp for when the version was
     * created.
     *
     * @generated from protobuf field: string created = 2;
     */
    created: string;
    /**
     * Creator of the version.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Meta data to for the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 4;
     */
    meta: {
        [key: string]: string;
    };
}
/**
 * UpdateRequest creates a new document version and/or sets statuses and ACLs
 * for a document. The update is transactional will fail or succed as a whole.
 *
 * If the document fails validation an "invalid_argument" error will be returned
 * with the number of errors as meta "err_count" and the individual errors as
 * "0", "1", "2"... Use the Validate method to get th errors as structured data.
 *
 * @generated from protobuf message elephant.repository.UpdateRequest
 */
export interface UpdateRequest {
    /**
     * UUID of the document to update.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Document version to create.
     *
     * @generated from protobuf field: newsdoc.Document document = 2;
     */
    document?: Document;
    /**
     * Meta data to associate with the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the update to be performed, or -1 to only perform
     * the update if the document doesn't already exist.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
    /**
     * Status updates to perform.
     *
     * @generated from protobuf field: repeated elephant.repository.StatusUpdate status = 5;
     */
    status: StatusUpdate[];
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 6;
     */
    acl: ACLEntry[];
    /**
     * ImportDirective can be used to preserve timestamps and authorship
     * information from originating systems, but requires the "import_directive"
     * scope for use.
     *
     * @generated from protobuf field: elephant.repository.ImportDirective import_directive = 7;
     */
    importDirective?: ImportDirective;
    /**
     * LockToken is used for explicit pessimistic locking.
     *
     * @generated from protobuf field: string lockToken = 8;
     */
    lockToken: string;
    /**
     * UpdateMetaDocument can be set to true to update the meta document instead
     * of the document identified by the UUID.
     *
     * @generated from protobuf field: bool update_meta_document = 9;
     */
    updateMetaDocument: boolean;
}
/**
 * ImportDirective can be used to preserve timestamps and authorship information
 * from originating systems.
 *
 * @generated from protobuf message elephant.repository.ImportDirective
 */
export interface ImportDirective {
    /**
     * @generated from protobuf field: string originally_created = 1;
     */
    originallyCreated: string;
    /**
     * @generated from protobuf field: string original_creator = 2;
     */
    originalCreator: string;
}
/**
 * UpdateResponse describes the result of an update request.
 *
 * @generated from protobuf message elephant.repository.UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.BulkUpdateRequest
 */
export interface BulkUpdateRequest {
    /**
     * @generated from protobuf field: repeated elephant.repository.UpdateRequest updates = 1;
     */
    updates: UpdateRequest[];
}
/**
 * @generated from protobuf message elephant.repository.BulkUpdateResponse
 */
export interface BulkUpdateResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.UpdateResponse updates = 1;
     */
    updates: UpdateResponse[];
}
/**
 * @generated from protobuf message elephant.repository.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
}
/**
 * @generated from protobuf message elephant.repository.ValidateResponse
 */
export interface ValidateResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.ValidationResult errors = 1;
     */
    errors: ValidationResult[];
}
/**
 * @generated from protobuf message elephant.repository.ValidationResult
 */
export interface ValidationResult {
    /**
     * @generated from protobuf field: repeated elephant.repository.EntityRef entity = 1;
     */
    entity: EntityRef[];
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message elephant.repository.EntityRef
 */
export interface EntityRef {
    /**
     * RefType is type of entity that's referenced, one of "block", "property",
     * "attribute", "data attribute", or "parameter."
     *
     * @generated from protobuf field: string ref_type = 1;
     */
    refType: string;
    /**
     * Kind is the block type, one of "link", "meta", or "content".
     *
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * Index is the position of the entity in an array, where applicable.
     *
     * @generated from protobuf field: int64 index = 3;
     */
    index: bigint;
    /**
     * Name is the name of the entity, where applicable.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * Type is the type of the entity, where applicable.
     *
     * @generated from protobuf field: string type = 5;
     */
    type: string;
    /**
     * Rel is the relationship for the entity, where applicable.
     *
     * @generated from protobuf field: string rel = 6;
     */
    rel: string;
}
/**
 * @generated from protobuf message elephant.repository.StatusUpdate
 */
export interface StatusUpdate {
    /**
     * Name of the status to set.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version to set the status for. Set to -1 to signal that the status no
     * longer is valid for the document. Optional if part of a document update
     * request as it then will default to the version being written.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Meta data to include with the status update.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the status id that you require
     * to be the current one for the status to be set, or -1 to only perform the
     * update if the status hasn't previously been set.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsRequest
 */
export interface UpdatePermissionsRequest {
    /**
     * UUID of the document to update permissions for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Set (upsert based on URI) this list of ACL entries.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry list = 2;
     */
    list: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsResponse
 */
export interface UpdatePermissionsResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentRequest
 */
export interface DeleteDocumentRequest {
    /**
     * UUID of the document to delete.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Meta data to include with the delete record.
     *
     * @generated from protobuf field: map<string, string> meta = 2;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the delete to be performed.
     *
     * @generated from protobuf field: int64 if_match = 3;
     */
    ifMatch: bigint;
    /**
     * LockToken is used for explicit pessimistic locking.
     *
     * @generated from protobuf field: string lockToken = 8;
     */
    lockToken: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentResponse
 */
export interface DeleteDocumentResponse {
}
/**
 * @generated from protobuf message elephant.repository.RestoreRequest
 */
export interface RestoreRequest {
    /**
     * UUID of the document to restore.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * DeleteRecordID for the specific instance of the document that was deleted.
     *
     * @generated from protobuf field: int64 delete_record_id = 2;
     */
    deleteRecordId: bigint;
    /**
     * ACL that should be set for the restored document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 3;
     */
    acl: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.RestoreResponse
 */
export interface RestoreResponse {
}
/**
 * @generated from protobuf message elephant.repository.PurgeRequest
 */
export interface PurgeRequest {
    /**
     * UUID of the document to purge.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * DeleteRecordID for the specific instance of the document that should be
     * purged.
     *
     * @generated from protobuf field: int64 delete_record_id = 2;
     */
    deleteRecordId: bigint;
}
/**
 * @generated from protobuf message elephant.repository.PurgeResponse
 */
export interface PurgeResponse {
}
/**
 * @generated from protobuf message elephant.repository.ListDeletedRequest
 */
export interface ListDeletedRequest {
    /**
     * UUID of the document list deletions of. Optional.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * BeforeID is used to paginate backwards in deletions. Optional.
     *
     * @generated from protobuf field: int64 before_id = 2;
     */
    beforeId: bigint;
    /**
     * BeforeDate is used to get deletions going back from before the specified
     * date YYYY-MM-DD. Optional, will be ignored if before_id is specified.
     *
     * @generated from protobuf field: string before_date = 3;
     */
    beforeDate: string;
    /**
     * Timezone that the date should be interpreted in.
     *
     * @generated from protobuf field: string timezone = 4;
     */
    timezone: string;
}
/**
 * @generated from protobuf message elephant.repository.ListDeletedResponse
 */
export interface ListDeletedResponse {
    /**
     * Deletes that have been performed on document instances with the given UUID.
     *
     * @generated from protobuf field: repeated elephant.repository.DeleteRecord deletes = 1;
     */
    deletes: DeleteRecord[];
}
/**
 * @generated from protobuf message elephant.repository.DeleteRecord
 */
export interface DeleteRecord {
    /**
     * ID of the delete record.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * UUID of the document.
     *
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
    /**
     * URI of the document.
     *
     * @generated from protobuf field: string uri = 3;
     */
    uri: string;
    /**
     * Type of the document.
     *
     * @generated from protobuf field: string type = 4;
     */
    type: string;
    /**
     * Version that the document had at the time of restore.
     *
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
    /**
     * Creation time for the delete record, as an RFC3339 timestamp.
     *
     * @generated from protobuf field: string created = 6;
     */
    created: string;
    /**
     * Creator of the delete record.
     *
     * @generated from protobuf field: string creator = 7;
     */
    creator: string;
    /**
     * Meta data included with the delete record.
     *
     * @generated from protobuf field: map<string, string> meta = 8;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * Language that the document was in.
     *
     * @generated from protobuf field: string language = 9;
     */
    language: string;
    /**
     * Finalised is the time, as an RFC3339 timestamp, that the document finished
     * deleting. Empty if the delete is in progress.
     *
     * @generated from protobuf field: string finalised = 10;
     */
    finalised: string;
    /**
     * Purged is the time, as an RFC3339 timestamp, all archived data for the
     * document was purged. Empty if the document hasn't been purged.
     *
     * @generated from protobuf field: string purged = 11;
     */
    purged: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetaRequest
 */
export interface GetMetaRequest {
    /**
     * UUID of the document to get metadata for
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetaResponse
 */
export interface GetMetaResponse {
    /**
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 1;
     */
    meta?: DocumentMeta;
}
/**
 * @generated from protobuf message elephant.repository.DocumentMeta
 */
export interface DocumentMeta {
    /**
     * Created timestamp is the RFC3339 timestamp for when the document was
     * created.
     *
     * @generated from protobuf field: string created = 1;
     */
    created: string;
    /**
     * Modified timestamp is the RFC3339 timestamp for the last change that
     * affected the document.
     *
     * @generated from protobuf field: string modified = 2;
     */
    modified: string;
    /**
     * CurrentVersion is the last written version of the document.
     *
     * @generated from protobuf field: int64 current_version = 3;
     */
    currentVersion: bigint;
    /**
     * Heads are the last statuses.
     *
     * @generated from protobuf field: map<string, elephant.repository.Status> heads = 4;
     */
    heads: {
        [key: string]: Status;
    };
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 5;
     */
    acl: ACLEntry[];
    /**
     * Document lock, if any
     *
     * @generated from protobuf field: elephant.repository.Lock lock = 6;
     */
    lock?: Lock;
    /**
     * IsMetaDocument is true if the document is a meta document.
     *
     * @generated from protobuf field: bool is_meta_document = 7;
     */
    isMetaDocument: boolean;
    /**
     * MainDocument is the UUID of the main document if this is a meta document.
     *
     * @generated from protobuf field: string main_document = 8;
     */
    mainDocument: string;
}
/**
 * @generated from protobuf message elephant.repository.Status
 */
export interface Status {
    /**
     * ID of the status.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Version of the document that the status refers to.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Creator of the status.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Created timestamp is the RFC3339 timestamp for when the status was created.
     *
     * @generated from protobuf field: string created = 4;
     */
    created: string;
    /**
     * Meta data for the status.
     *
     * @generated from protobuf field: map<string, string> meta = 5;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * MetaDocumentVersion is the version the meta document had at the time the
     * status was set.
     *
     * @generated from protobuf field: int64 meta_doc_version = 6;
     */
    metaDocVersion: bigint;
}
/**
 * @generated from protobuf message elephant.repository.ACLEntry
 */
export interface ACLEntry {
    /**
     * URI that identifies the party that's granted access.
     *
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * Permissions given to the grantee.
     *
     * @generated from protobuf field: repeated string permissions = 2;
     */
    permissions: string[];
}
/**
 * @generated from protobuf message elephant.repository.Lock
 */
export interface Lock {
    /**
     * Lock token string
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * URI of the lock owner
     *
     * @generated from protobuf field: string uri = 2;
     */
    uri: string;
    /**
     * Created timestamp is the RFC3339 timestamp for when the lock was created.
     *
     * @generated from protobuf field: string created = 3;
     */
    created: string;
    /**
     * Expires timestamp is the RFC3339 timestamp for when the lock will expire.
     *
     * @generated from protobuf field: string expires = 4;
     */
    expires: string;
    /**
     * URI identifying the locking application.
     *
     * @generated from protobuf field: string app = 5;
     */
    app: string;
    /**
     * Optional free-form comment.
     *
     * @generated from protobuf field: string comment = 6;
     */
    comment: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeRequest
 */
export interface RegisterMetaTypeRequest {
    /**
     * Type to use as a meta type.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Exclusive - set to true to only allow the type to be used as a meta type.
     *
     * @generated from protobuf field: bool exclusive = 2;
     */
    exclusive: boolean;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeResponse
 */
export interface RegisterMetaTypeResponse {
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeUseRequest
 */
export interface RegisterMetaTypeUseRequest {
    /**
     * MainType to use the meta type for.
     *
     * @generated from protobuf field: string main_type = 1;
     */
    mainType: string;
    /**
     * MetaType to use for the main document.
     *
     * @generated from protobuf field: string meta_type = 2;
     */
    metaType: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeUseResponse
 */
export interface RegisterMetaTypeUseResponse {
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaRequest
 */
export interface RegisterSchemaRequest {
    /**
     * Schema to register. The spec can be omitted if a schema URL is passed.
     *
     * @generated from protobuf field: elephant.repository.Schema schema = 1;
     */
    schema?: Schema;
    /**
     * Activate the registered schema immediately.
     *
     * @generated from protobuf field: bool activate = 2;
     */
    activate: boolean;
    /**
     * SchemaURL is an HTTP(S) url to the schema to load, can be passed instead of
     * an inline schema spec.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
    /**
     * SchemaSHA256 is a SHA256 checksum to validate the response body from the
     * schema URL against.
     *
     * @generated from protobuf field: string schema_sha256 = 4;
     */
    schemaSha256: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaResponse
 */
export interface RegisterSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaRequest
 */
export interface SetActiveSchemaRequest {
    /**
     * Name is the name of the schema to activate or deactivate, required.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to activate, required when activating a new version.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * Deactivate is used to disable a schema, activate new schema versions
     * instead if you want to start using a new version.
     *
     * @generated from protobuf field: bool deactivate = 3;
     */
    deactivate: boolean;
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaResponse
 */
export interface SetActiveSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * Name of the schema to get.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to get, optional. The currently active version of the
     * schema will be returned if no version is specified.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: bytes spec = 2;
     */
    spec: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export interface GetAllActiveSchemasRequest {
    /**
     * @generated from protobuf field: int64 wait_seconds = 1;
     */
    waitSeconds: bigint;
    /**
     * @generated from protobuf field: map<string, string> known = 2;
     */
    known: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export interface GetAllActiveSchemasResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Schema schemas = 1;
     */
    schemas: Schema[];
}
/**
 * @generated from protobuf message elephant.repository.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: string spec = 3;
     */
    spec: string;
}
/**
 * @generated from protobuf message elephant.repository.GetDeprecationsRequest
 */
export interface GetDeprecationsRequest {
}
/**
 * @generated from protobuf message elephant.repository.Deprecation
 */
export interface Deprecation {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: bool enforced = 2;
     */
    enforced: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetDeprecationsResponse
 */
export interface GetDeprecationsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Deprecation deprecations = 1;
     */
    deprecations: Deprecation[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateDeprecationRequest
 */
export interface UpdateDeprecationRequest {
    /**
     * @generated from protobuf field: elephant.repository.Deprecation deprecation = 1;
     */
    deprecation?: Deprecation;
}
/**
 * @generated from protobuf message elephant.repository.UpdateDeprecationResponse
 */
export interface UpdateDeprecationResponse {
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindRequest
 */
export interface RegisterMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindResponse
 */
export interface RegisterMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindRequest
 */
export interface DeleteMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindResponse
 */
export interface DeleteMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsRequest
 */
export interface GetMetricKindsRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsResponse
 */
export interface GetMetricKindsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.MetricKind kinds = 1;
     */
    kinds: MetricKind[];
}
/**
 * @generated from protobuf message elephant.repository.MetricKind
 */
export interface MetricKind {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricRequest
 */
export interface RegisterMetricRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
    /**
     * @generated from protobuf field: int64 value = 5;
     */
    value: bigint;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricResponse
 */
export interface RegisterMetricResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Metric metrics = 2;
     */
    metrics: Metric[];
}
/**
 * @generated from protobuf message elephant.repository.Metric
 */
export interface Metric {
    /**
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: int64 value = 3;
     */
    value: bigint;
}
/**
 * @generated from protobuf message elephant.repository.LockRequest
 */
export interface LockRequest {
    /**
     * UUID of the document to lock
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock TTL in milliseconds
     *
     * @generated from protobuf field: int32 ttl = 2;
     */
    ttl: number;
    /**
     * Name of the locking application. Optional.
     *
     * @generated from protobuf field: string app = 3;
     */
    app: string;
    /**
     * Free-form comment string. Optional.
     *
     * @generated from protobuf field: string comment = 4;
     */
    comment: string;
}
/**
 * @generated from protobuf message elephant.repository.LockResponse
 */
export interface LockResponse {
    /**
     * Generated lock token in UUID format.
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * Expires is the RFC3339 timestamp when the lock will expire.
     *
     * @generated from protobuf field: string expires = 2;
     */
    expires: string;
}
/**
 * @generated from protobuf message elephant.repository.ExtendLockRequest
 */
export interface ExtendLockRequest {
    /**
     * UUID of the document to extend the lock for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock TTL in milliseconds.
     *
     * @generated from protobuf field: int32 ttl = 2;
     */
    ttl: number;
    /**
     * Lock token in UUID format.
     *
     * @generated from protobuf field: string token = 3;
     */
    token: string;
}
/**
 * @generated from protobuf message elephant.repository.UnlockRequest
 */
export interface UnlockRequest {
    /**
     * UUID of the document to unlock
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock token in UUID format.
     *
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * @generated from protobuf message elephant.repository.UnlockResponse
 */
export interface UnlockResponse {
}
/**
 * @generated from protobuf enum elephant.repository.GetMetaDoc
 */
export enum GetMetaDoc {
    /**
     * @generated from protobuf enum value: META_NONE = 0;
     */
    META_NONE = 0,
    /**
     * @generated from protobuf enum value: META_INCLUDE = 1;
     */
    META_INCLUDE = 1,
    /**
     * @generated from protobuf enum value: META_ONLY = 2;
     */
    META_ONLY = 2
}
/**
 * @generated from protobuf enum elephant.repository.MetricAggregation
 */
export enum MetricAggregation {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: REPLACE = 1;
     */
    REPLACE = 1,
    /**
     * @generated from protobuf enum value: INCREMENT = 2;
     */
    INCREMENT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("elephant.repository.GetStatusRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 id */ 3:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 id = 3; */
        if (message.id !== 0n)
            writer.tag(3, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse$Type extends MessageType<GetStatusResponse> {
    constructor() {
        super("elephant.repository.GetStatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse>): GetStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse): GetStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusResponse
 */
export const GetStatusResponse = new GetStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryRequest$Type extends MessageType<GetStatusHistoryRequest> {
    constructor() {
        super("elephant.repository.GetStatusHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryRequest>): GetStatusHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        message.before = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryRequest): GetStatusHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 before */ 3:
                    message.before = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 before = 3; */
        if (message.before !== 0n)
            writer.tag(3, WireType.Varint).int64(message.before);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryRequest
 */
export const GetStatusHistoryRequest = new GetStatusHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryReponse$Type extends MessageType<GetStatusHistoryReponse> {
    constructor() {
        super("elephant.repository.GetStatusHistoryReponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryReponse>): GetStatusHistoryReponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryReponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryReponse): GetStatusHistoryReponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Status statuses */ 1:
                    message.statuses.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryReponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Status statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            Status.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryReponse
 */
export const GetStatusHistoryReponse = new GetStatusHistoryReponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusOverviewRequest$Type extends MessageType<GetStatusOverviewRequest> {
    constructor() {
        super("elephant.repository.GetStatusOverviewRequest", [
            { no: 1, name: "uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "statuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "get_meta", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusOverviewRequest>): GetStatusOverviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuids = [];
        message.statuses = [];
        message.getMeta = false;
        if (value !== undefined)
            reflectionMergePartial<GetStatusOverviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusOverviewRequest): GetStatusOverviewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string uuids */ 1:
                    message.uuids.push(reader.string());
                    break;
                case /* repeated string statuses */ 2:
                    message.statuses.push(reader.string());
                    break;
                case /* bool get_meta */ 3:
                    message.getMeta = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusOverviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.uuids[i]);
        /* repeated string statuses = 2; */
        for (let i = 0; i < message.statuses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.statuses[i]);
        /* bool get_meta = 3; */
        if (message.getMeta !== false)
            writer.tag(3, WireType.Varint).bool(message.getMeta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusOverviewRequest
 */
export const GetStatusOverviewRequest = new GetStatusOverviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusOverviewResponse$Type extends MessageType<GetStatusOverviewResponse> {
    constructor() {
        super("elephant.repository.GetStatusOverviewResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusOverviewItem }
        ]);
    }
    create(value?: PartialMessage<GetStatusOverviewResponse>): GetStatusOverviewResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusOverviewResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusOverviewResponse): GetStatusOverviewResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.StatusOverviewItem items */ 1:
                    message.items.push(StatusOverviewItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusOverviewResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.StatusOverviewItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            StatusOverviewItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusOverviewResponse
 */
export const GetStatusOverviewResponse = new GetStatusOverviewResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusOverviewItem$Type extends MessageType<StatusOverviewItem> {
    constructor() {
        super("elephant.repository.StatusOverviewItem", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "modified", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } }
        ]);
    }
    create(value?: PartialMessage<StatusOverviewItem>): StatusOverviewItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        message.modified = "";
        message.heads = {};
        if (value !== undefined)
            reflectionMergePartial<StatusOverviewItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusOverviewItem): StatusOverviewItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string modified */ 3:
                    message.modified = reader.string();
                    break;
                case /* map<string, elephant.repository.Status> heads */ 4:
                    this.binaryReadMap4(message.heads, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: StatusOverviewItem["heads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatusOverviewItem["heads"] | undefined, val: StatusOverviewItem["heads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.StatusOverviewItem.heads");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    internalBinaryWrite(message: StatusOverviewItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string modified = 3; */
        if (message.modified !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.modified);
        /* map<string, elephant.repository.Status> heads = 4; */
        for (let k of globalThis.Object.keys(message.heads)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.heads[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusOverviewItem
 */
export const StatusOverviewItem = new StatusOverviewItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsRequest$Type extends MessageType<GetPermissionsRequest> {
    constructor() {
        super("elephant.repository.GetPermissionsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsRequest>): GetPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsRequest): GetPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetPermissionsRequest
 */
export const GetPermissionsRequest = new GetPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsResponse$Type extends MessageType<GetPermissionsResponse> {
    constructor() {
        super("elephant.repository.GetPermissionsResponse", [
            { no: 1, name: "permissions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsResponse>): GetPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = {};
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsResponse): GetPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> permissions */ 1:
                    this.binaryReadMap1(message.permissions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetPermissionsResponse["permissions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetPermissionsResponse["permissions"] | undefined, val: GetPermissionsResponse["permissions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetPermissionsResponse.permissions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> permissions = 1; */
        for (let k of globalThis.Object.keys(message.permissions))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.permissions[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetPermissionsResponse
 */
export const GetPermissionsResponse = new GetPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogRequest$Type extends MessageType<GetEventlogRequest> {
    constructor() {
        super("elephant.repository.GetEventlogRequest", [
            { no: 1, name: "after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "wait_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "batch_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "batch_wait_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEventlogRequest>): GetEventlogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.after = 0n;
        message.waitMs = 0;
        message.batchSize = 0;
        message.batchWaitMs = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEventlogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogRequest): GetEventlogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 after */ 1:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* int32 wait_ms */ 2:
                    message.waitMs = reader.int32();
                    break;
                case /* int32 batch_size */ 3:
                    message.batchSize = reader.int32();
                    break;
                case /* int32 batch_wait_ms */ 4:
                    message.batchWaitMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 after = 1; */
        if (message.after !== 0n)
            writer.tag(1, WireType.Varint).int64(message.after);
        /* int32 wait_ms = 2; */
        if (message.waitMs !== 0)
            writer.tag(2, WireType.Varint).int32(message.waitMs);
        /* int32 batch_size = 3; */
        if (message.batchSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.batchSize);
        /* int32 batch_wait_ms = 4; */
        if (message.batchWaitMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.batchWaitMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogRequest
 */
export const GetEventlogRequest = new GetEventlogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogResponse$Type extends MessageType<GetEventlogResponse> {
    constructor() {
        super("elephant.repository.GetEventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<GetEventlogResponse>): GetEventlogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetEventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogResponse): GetEventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogResponse
 */
export const GetEventlogResponse = new GetEventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCompactedEventlogRequest$Type extends MessageType<GetCompactedEventlogRequest> {
    constructor() {
        super("elephant.repository.GetCompactedEventlogRequest", [
            { no: 1, name: "after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "until", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCompactedEventlogRequest>): GetCompactedEventlogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.after = 0n;
        message.until = 0n;
        message.limit = 0;
        message.offset = 0;
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<GetCompactedEventlogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCompactedEventlogRequest): GetCompactedEventlogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 after */ 1:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* int64 until */ 3:
                    message.until = reader.int64().toBigInt();
                    break;
                case /* int32 limit */ 4:
                    message.limit = reader.int32();
                    break;
                case /* int32 offset */ 5:
                    message.offset = reader.int32();
                    break;
                case /* string type */ 6:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCompactedEventlogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 after = 1; */
        if (message.after !== 0n)
            writer.tag(1, WireType.Varint).int64(message.after);
        /* int64 until = 3; */
        if (message.until !== 0n)
            writer.tag(3, WireType.Varint).int64(message.until);
        /* int32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).int32(message.limit);
        /* int32 offset = 5; */
        if (message.offset !== 0)
            writer.tag(5, WireType.Varint).int32(message.offset);
        /* string type = 6; */
        if (message.type !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetCompactedEventlogRequest
 */
export const GetCompactedEventlogRequest = new GetCompactedEventlogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCompactedEventlogResponse$Type extends MessageType<GetCompactedEventlogResponse> {
    constructor() {
        super("elephant.repository.GetCompactedEventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<GetCompactedEventlogResponse>): GetCompactedEventlogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetCompactedEventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCompactedEventlogResponse): GetCompactedEventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCompactedEventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetCompactedEventlogResponse
 */
export const GetCompactedEventlogResponse = new GetCompactedEventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventlogItem$Type extends MessageType<EventlogItem> {
    constructor() {
        super("elephant.repository.EventlogItem", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "status_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 9, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "old_language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "system_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventlogItem>): EventlogItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.event = "";
        message.uuid = "";
        message.timestamp = "";
        message.version = 0n;
        message.status = "";
        message.statusId = 0n;
        message.acl = [];
        message.updaterUri = "";
        message.type = "";
        message.language = "";
        message.oldLanguage = "";
        message.mainDocument = "";
        message.systemState = "";
        if (value !== undefined)
            reflectionMergePartial<EventlogItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventlogItem): EventlogItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string event */ 2:
                    message.event = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* string timestamp */ 4:
                    message.timestamp = reader.string();
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* int64 status_id */ 7:
                    message.statusId = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 8:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updater_uri */ 9:
                    message.updaterUri = reader.string();
                    break;
                case /* string type */ 10:
                    message.type = reader.string();
                    break;
                case /* string language */ 11:
                    message.language = reader.string();
                    break;
                case /* string old_language */ 12:
                    message.oldLanguage = reader.string();
                    break;
                case /* string main_document */ 13:
                    message.mainDocument = reader.string();
                    break;
                case /* string system_state */ 14:
                    message.systemState = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventlogItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string event = 2; */
        if (message.event !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.event);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* string timestamp = 4; */
        if (message.timestamp !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.timestamp);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* int64 status_id = 7; */
        if (message.statusId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.statusId);
        /* repeated elephant.repository.ACLEntry acl = 8; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string updater_uri = 9; */
        if (message.updaterUri !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updaterUri);
        /* string type = 10; */
        if (message.type !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.type);
        /* string language = 11; */
        if (message.language !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.language);
        /* string old_language = 12; */
        if (message.oldLanguage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.oldLanguage);
        /* string main_document = 13; */
        if (message.mainDocument !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.mainDocument);
        /* string system_state = 14; */
        if (message.systemState !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.systemState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EventlogItem
 */
export const EventlogItem = new EventlogItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunReportRequest$Type extends MessageType<RunReportRequest> {
    constructor() {
        super("elephant.repository.RunReportRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunReportRequest>): RunReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RunReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunReportRequest): RunReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RunReportRequest
 */
export const RunReportRequest = new RunReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunReportResponse$Type extends MessageType<RunReportResponse> {
    constructor() {
        super("elephant.repository.RunReportResponse", [
            { no: 1, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spreadsheet", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RunReportResponse>): RunReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tables = [];
        message.spreadsheet = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RunReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunReportResponse): RunReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tables */ 1:
                    message.tables.push(reader.string());
                    break;
                case /* bytes spreadsheet */ 2:
                    message.spreadsheet = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tables[i]);
        /* bytes spreadsheet = 2; */
        if (message.spreadsheet.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spreadsheet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RunReportResponse
 */
export const RunReportResponse = new RunReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReportRequest$Type extends MessageType<TestReportRequest> {
    constructor() {
        super("elephant.repository.TestReportRequest", [
            { no: 1, name: "report", kind: "message", T: () => Report }
        ]);
    }
    create(value?: PartialMessage<TestReportRequest>): TestReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TestReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReportRequest): TestReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.TestReportRequest
 */
export const TestReportRequest = new TestReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReportResponse$Type extends MessageType<TestReportResponse> {
    constructor() {
        super("elephant.repository.TestReportResponse", [
            { no: 1, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spreadsheet", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TestReportResponse>): TestReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tables = [];
        message.spreadsheet = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TestReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReportResponse): TestReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tables */ 1:
                    message.tables.push(reader.string());
                    break;
                case /* bytes spreadsheet */ 2:
                    message.spreadsheet = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tables[i]);
        /* bytes spreadsheet = 2; */
        if (message.spreadsheet.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spreadsheet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.TestReportResponse
 */
export const TestReportResponse = new TestReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteReportRequest$Type extends MessageType<DeleteReportRequest> {
    constructor() {
        super("elephant.repository.DeleteReportRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteReportRequest>): DeleteReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteReportRequest): DeleteReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteReportRequest
 */
export const DeleteReportRequest = new DeleteReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteReportResponse$Type extends MessageType<DeleteReportResponse> {
    constructor() {
        super("elephant.repository.DeleteReportResponse", []);
    }
    create(value?: PartialMessage<DeleteReportResponse>): DeleteReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteReportResponse): DeleteReportResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteReportResponse
 */
export const DeleteReportResponse = new DeleteReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportRequest$Type extends MessageType<GetReportRequest> {
    constructor() {
        super("elephant.repository.GetReportRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReportRequest>): GetReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportRequest): GetReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetReportRequest
 */
export const GetReportRequest = new GetReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportResponse$Type extends MessageType<GetReportResponse> {
    constructor() {
        super("elephant.repository.GetReportResponse", [
            { no: 1, name: "report", kind: "message", T: () => Report },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "next_execution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReportResponse>): GetReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.nextExecution = "";
        if (value !== undefined)
            reflectionMergePartial<GetReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportResponse): GetReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* string next_execution */ 3:
                    message.nextExecution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* string next_execution = 3; */
        if (message.nextExecution !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nextExecution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetReportResponse
 */
export const GetReportResponse = new GetReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateReportRequest$Type extends MessageType<UpdateReportRequest> {
    constructor() {
        super("elephant.repository.UpdateReportRequest", [
            { no: 1, name: "report", kind: "message", T: () => Report },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateReportRequest>): UpdateReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateReportRequest): UpdateReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateReportRequest
 */
export const UpdateReportRequest = new UpdateReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListReportsRequest$Type extends MessageType<ListReportsRequest> {
    constructor() {
        super("elephant.repository.ListReportsRequest", []);
    }
    create(value?: PartialMessage<ListReportsRequest>): ListReportsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListReportsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListReportsRequest): ListReportsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListReportsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListReportsRequest
 */
export const ListReportsRequest = new ListReportsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListReportsResponse$Type extends MessageType<ListReportsResponse> {
    constructor() {
        super("elephant.repository.ListReportsResponse", [
            { no: 1, name: "reports", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReportListItem }
        ]);
    }
    create(value?: PartialMessage<ListReportsResponse>): ListReportsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reports = [];
        if (value !== undefined)
            reflectionMergePartial<ListReportsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListReportsResponse): ListReportsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.ReportListItem reports */ 1:
                    message.reports.push(ReportListItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListReportsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.ReportListItem reports = 1; */
        for (let i = 0; i < message.reports.length; i++)
            ReportListItem.internalBinaryWrite(message.reports[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListReportsResponse
 */
export const ListReportsResponse = new ListReportsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportListItem$Type extends MessageType<ReportListItem> {
    constructor() {
        super("elephant.repository.ReportListItem", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cron_expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cron_timezone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReportListItem>): ReportListItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.title = "";
        message.cronExpression = "";
        message.cronTimezone = "";
        if (value !== undefined)
            reflectionMergePartial<ReportListItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportListItem): ReportListItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string cron_expression */ 3:
                    message.cronExpression = reader.string();
                    break;
                case /* string cron_timezone */ 4:
                    message.cronTimezone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportListItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string cron_expression = 3; */
        if (message.cronExpression !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cronExpression);
        /* string cron_timezone = 4; */
        if (message.cronTimezone !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cronTimezone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ReportListItem
 */
export const ReportListItem = new ReportListItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Report$Type extends MessageType<Report> {
    constructor() {
        super("elephant.repository.Report", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "generate_sheet", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cron_expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "cron_timezone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "slack_channels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "queries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReportQuery }
        ]);
    }
    create(value?: PartialMessage<Report>): Report {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.title = "";
        message.generateSheet = false;
        message.cronExpression = "";
        message.cronTimezone = "";
        message.slackChannels = [];
        message.queries = [];
        if (value !== undefined)
            reflectionMergePartial<Report>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Report): Report {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* bool generate_sheet */ 3:
                    message.generateSheet = reader.bool();
                    break;
                case /* string cron_expression */ 4:
                    message.cronExpression = reader.string();
                    break;
                case /* string cron_timezone */ 7:
                    message.cronTimezone = reader.string();
                    break;
                case /* repeated string slack_channels */ 5:
                    message.slackChannels.push(reader.string());
                    break;
                case /* repeated elephant.repository.ReportQuery queries */ 6:
                    message.queries.push(ReportQuery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Report, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* bool generate_sheet = 3; */
        if (message.generateSheet !== false)
            writer.tag(3, WireType.Varint).bool(message.generateSheet);
        /* string cron_expression = 4; */
        if (message.cronExpression !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cronExpression);
        /* string cron_timezone = 7; */
        if (message.cronTimezone !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cronTimezone);
        /* repeated string slack_channels = 5; */
        for (let i = 0; i < message.slackChannels.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.slackChannels[i]);
        /* repeated elephant.repository.ReportQuery queries = 6; */
        for (let i = 0; i < message.queries.length; i++)
            ReportQuery.internalBinaryWrite(message.queries[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Report
 */
export const Report = new Report$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportQuery$Type extends MessageType<ReportQuery> {
    constructor() {
        super("elephant.repository.ReportQuery", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summarise", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value_processing", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReportValue }
        ]);
    }
    create(value?: PartialMessage<ReportQuery>): ReportQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.summarise = [];
        message.sql = "";
        message.valueProcessing = [];
        if (value !== undefined)
            reflectionMergePartial<ReportQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportQuery): ReportQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated int32 summarise */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.summarise.push(reader.int32());
                    else
                        message.summarise.push(reader.int32());
                    break;
                case /* string sql */ 3:
                    message.sql = reader.string();
                    break;
                case /* repeated elephant.repository.ReportValue value_processing */ 4:
                    message.valueProcessing.push(ReportValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated int32 summarise = 2; */
        if (message.summarise.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.summarise.length; i++)
                writer.int32(message.summarise[i]);
            writer.join();
        }
        /* string sql = 3; */
        if (message.sql !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sql);
        /* repeated elephant.repository.ReportValue value_processing = 4; */
        for (let i = 0; i < message.valueProcessing.length; i++)
            ReportValue.internalBinaryWrite(message.valueProcessing[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ReportQuery
 */
export const ReportQuery = new ReportQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportValue$Type extends MessageType<ReportValue> {
    constructor() {
        super("elephant.repository.ReportValue", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "processors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReportValue>): ReportValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.column = "";
        message.processors = [];
        if (value !== undefined)
            reflectionMergePartial<ReportValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportValue): ReportValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* repeated string processors */ 2:
                    message.processors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* repeated string processors = 2; */
        for (let i = 0; i < message.processors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.processors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ReportValue
 */
export const ReportValue = new ReportValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateReportResponse$Type extends MessageType<UpdateReportResponse> {
    constructor() {
        super("elephant.repository.UpdateReportResponse", [
            { no: 1, name: "next_execution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateReportResponse>): UpdateReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nextExecution = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateReportResponse): UpdateReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_execution */ 1:
                    message.nextExecution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_execution = 1; */
        if (message.nextExecution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nextExecution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateReportResponse
 */
export const UpdateReportResponse = new UpdateReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesRequest$Type extends MessageType<GetStatusRulesRequest> {
    constructor() {
        super("elephant.repository.GetStatusRulesRequest", []);
    }
    create(value?: PartialMessage<GetStatusRulesRequest>): GetStatusRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesRequest): GetStatusRulesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesRequest
 */
export const GetStatusRulesRequest = new GetStatusRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesResponse$Type extends MessageType<GetStatusRulesResponse> {
    constructor() {
        super("elephant.repository.GetStatusRulesResponse", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<GetStatusRulesResponse>): GetStatusRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesResponse): GetStatusRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.StatusRule rules */ 1:
                    message.rules.push(StatusRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.StatusRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            StatusRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesResponse
 */
export const GetStatusRulesResponse = new GetStatusRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesRequest$Type extends MessageType<GetStatusesRequest> {
    constructor() {
        super("elephant.repository.GetStatusesRequest", []);
    }
    create(value?: PartialMessage<GetStatusesRequest>): GetStatusesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesRequest): GetStatusesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesRequest
 */
export const GetStatusesRequest = new GetStatusesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatus$Type extends MessageType<WorkflowStatus> {
    constructor() {
        super("elephant.repository.WorkflowStatus", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatus>): WorkflowStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatus): WorkflowStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.WorkflowStatus
 */
export const WorkflowStatus = new WorkflowStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesResponse$Type extends MessageType<GetStatusesResponse> {
    constructor() {
        super("elephant.repository.GetStatusesResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowStatus }
        ]);
    }
    create(value?: PartialMessage<GetStatusesResponse>): GetStatusesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesResponse): GetStatusesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.WorkflowStatus statuses */ 1:
                    message.statuses.push(WorkflowStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.WorkflowStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            WorkflowStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesResponse
 */
export const GetStatusesResponse = new GetStatusesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusRequest$Type extends MessageType<UpdateStatusRequest> {
    constructor() {
        super("elephant.repository.UpdateStatusRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusRequest>): UpdateStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        message.disabled = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusRequest): UpdateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusRequest
 */
export const UpdateStatusRequest = new UpdateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusResponse$Type extends MessageType<UpdateStatusResponse> {
    constructor() {
        super("elephant.repository.UpdateStatusResponse", []);
    }
    create(value?: PartialMessage<UpdateStatusResponse>): UpdateStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusResponse): UpdateStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusResponse
 */
export const UpdateStatusResponse = new UpdateStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleRequest$Type extends MessageType<CreateStatusRuleRequest> {
    constructor() {
        super("elephant.repository.CreateStatusRuleRequest", [
            { no: 1, name: "rule", kind: "message", T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<CreateStatusRuleRequest>): CreateStatusRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleRequest): CreateStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.StatusRule rule */ 1:
                    message.rule = StatusRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.StatusRule rule = 1; */
        if (message.rule)
            StatusRule.internalBinaryWrite(message.rule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleRequest
 */
export const CreateStatusRuleRequest = new CreateStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusRule$Type extends MessageType<StatusRule> {
    constructor() {
        super("elephant.repository.StatusRule", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_rule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "applies_to", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusRule>): StatusRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        message.description = "";
        message.accessRule = false;
        message.appliesTo = [];
        message.expression = "";
        if (value !== undefined)
            reflectionMergePartial<StatusRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusRule): StatusRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool access_rule */ 4:
                    message.accessRule = reader.bool();
                    break;
                case /* repeated string applies_to */ 5:
                    message.appliesTo.push(reader.string());
                    break;
                case /* string expression */ 7:
                    message.expression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool access_rule = 4; */
        if (message.accessRule !== false)
            writer.tag(4, WireType.Varint).bool(message.accessRule);
        /* repeated string applies_to = 5; */
        for (let i = 0; i < message.appliesTo.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.appliesTo[i]);
        /* string expression = 7; */
        if (message.expression !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusRule
 */
export const StatusRule = new StatusRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleResponse$Type extends MessageType<CreateStatusRuleResponse> {
    constructor() {
        super("elephant.repository.CreateStatusRuleResponse", []);
    }
    create(value?: PartialMessage<CreateStatusRuleResponse>): CreateStatusRuleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleResponse): CreateStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleResponse
 */
export const CreateStatusRuleResponse = new CreateStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleRequest$Type extends MessageType<DeleteStatusRuleRequest> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusRuleRequest>): DeleteStatusRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleRequest): DeleteStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export const DeleteStatusRuleRequest = new DeleteStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleResponse$Type extends MessageType<DeleteStatusRuleResponse> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleResponse", []);
    }
    create(value?: PartialMessage<DeleteStatusRuleResponse>): DeleteStatusRuleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleResponse): DeleteStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export const DeleteStatusRuleResponse = new DeleteStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentRequest$Type extends MessageType<GetDocumentRequest> {
    constructor() {
        super("elephant.repository.GetDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "meta_document", kind: "enum", T: () => ["elephant.repository.GetMetaDoc", GetMetaDoc] }
        ]);
    }
    create(value?: PartialMessage<GetDocumentRequest>): GetDocumentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        message.status = "";
        message.lock = false;
        message.metaDocument = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentRequest): GetDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* bool lock */ 4:
                    message.lock = reader.bool();
                    break;
                case /* elephant.repository.GetMetaDoc meta_document */ 5:
                    message.metaDocument = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* bool lock = 4; */
        if (message.lock !== false)
            writer.tag(4, WireType.Varint).bool(message.lock);
        /* elephant.repository.GetMetaDoc meta_document = 5; */
        if (message.metaDocument !== 0)
            writer.tag(5, WireType.Varint).int32(message.metaDocument);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentRequest
 */
export const GetDocumentRequest = new GetDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentResponse$Type extends MessageType<GetDocumentResponse> {
    constructor() {
        super("elephant.repository.GetDocumentResponse", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "status", kind: "message", T: () => Status },
            { no: 4, name: "meta", kind: "message", T: () => MetaDocument },
            { no: 5, name: "is_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentResponse>): GetDocumentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.isMetaDocument = false;
        message.mainDocument = "";
        if (value !== undefined)
            reflectionMergePartial<GetDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentResponse): GetDocumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* elephant.repository.Status status */ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* elephant.repository.MetaDocument meta */ 4:
                    message.meta = MetaDocument.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* bool is_meta_document */ 5:
                    message.isMetaDocument = reader.bool();
                    break;
                case /* string main_document */ 6:
                    message.mainDocument = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* elephant.repository.Status status = 3; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.MetaDocument meta = 4; */
        if (message.meta)
            MetaDocument.internalBinaryWrite(message.meta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_meta_document = 5; */
        if (message.isMetaDocument !== false)
            writer.tag(5, WireType.Varint).bool(message.isMetaDocument);
        /* string main_document = 6; */
        if (message.mainDocument !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mainDocument);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentResponse
 */
export const GetDocumentResponse = new GetDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetRequest$Type extends MessageType<BulkGetRequest> {
    constructor() {
        super("elephant.repository.BulkGetRequest", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkGetReference }
        ]);
    }
    create(value?: PartialMessage<BulkGetRequest>): BulkGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = [];
        if (value !== undefined)
            reflectionMergePartial<BulkGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetRequest): BulkGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.BulkGetReference documents */ 1:
                    message.documents.push(BulkGetReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.BulkGetReference documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            BulkGetReference.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetRequest
 */
export const BulkGetRequest = new BulkGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetReference$Type extends MessageType<BulkGetReference> {
    constructor() {
        super("elephant.repository.BulkGetReference", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BulkGetReference>): BulkGetReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<BulkGetReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetReference): BulkGetReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetReference
 */
export const BulkGetReference = new BulkGetReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetResponse$Type extends MessageType<BulkGetResponse> {
    constructor() {
        super("elephant.repository.BulkGetResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkGetItem }
        ]);
    }
    create(value?: PartialMessage<BulkGetResponse>): BulkGetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<BulkGetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetResponse): BulkGetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.BulkGetItem items */ 1:
                    message.items.push(BulkGetItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.BulkGetItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            BulkGetItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetResponse
 */
export const BulkGetResponse = new BulkGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetItem$Type extends MessageType<BulkGetItem> {
    constructor() {
        super("elephant.repository.BulkGetItem", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BulkGetItem>): BulkGetItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<BulkGetItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetItem): BulkGetItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetItem
 */
export const BulkGetItem = new BulkGetItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaDocument$Type extends MessageType<MetaDocument> {
    constructor() {
        super("elephant.repository.MetaDocument", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MetaDocument>): MetaDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<MetaDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaDocument): MetaDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetaDocument
 */
export const MetaDocument = new MetaDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryRequest$Type extends MessageType<GetHistoryRequest> {
    constructor() {
        super("elephant.repository.GetHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetHistoryRequest>): GetHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.before = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryRequest): GetHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 before */ 2:
                    message.before = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 before = 2; */
        if (message.before !== 0n)
            writer.tag(2, WireType.Varint).int64(message.before);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryRequest
 */
export const GetHistoryRequest = new GetHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryResponse$Type extends MessageType<GetHistoryResponse> {
    constructor() {
        super("elephant.repository.GetHistoryResponse", [
            { no: 1, name: "versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentVersion }
        ]);
    }
    create(value?: PartialMessage<GetHistoryResponse>): GetHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versions = [];
        if (value !== undefined)
            reflectionMergePartial<GetHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryResponse): GetHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.DocumentVersion versions */ 1:
                    message.versions.push(DocumentVersion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.DocumentVersion versions = 1; */
        for (let i = 0; i < message.versions.length; i++)
            DocumentVersion.internalBinaryWrite(message.versions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryResponse
 */
export const GetHistoryResponse = new GetHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentVersion$Type extends MessageType<DocumentVersion> {
    constructor() {
        super("elephant.repository.DocumentVersion", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<DocumentVersion>): DocumentVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.created = "";
        message.creator = "";
        message.meta = {};
        if (value !== undefined)
            reflectionMergePartial<DocumentVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentVersion): DocumentVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string created */ 2:
                    message.created = reader.string();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* map<string, string> meta */ 4:
                    this.binaryReadMap4(message.meta, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentVersion["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentVersion["meta"] | undefined, val: DocumentVersion["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentVersion.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DocumentVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string created = 2; */
        if (message.created !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.created);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* map<string, string> meta = 4; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentVersion
 */
export const DocumentVersion = new DocumentVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRequest$Type extends MessageType<UpdateRequest> {
    constructor() {
        super("elephant.repository.UpdateRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document", kind: "message", T: () => Document },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusUpdate },
            { no: 6, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 7, name: "import_directive", kind: "message", T: () => ImportDirective },
            { no: 8, name: "lockToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "update_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateRequest>): UpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.meta = {};
        message.ifMatch = 0n;
        message.status = [];
        message.acl = [];
        message.lockToken = "";
        message.updateMetaDocument = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRequest): UpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* newsdoc.Document document */ 2:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.StatusUpdate status */ 5:
                    message.status.push(StatusUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 6:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* elephant.repository.ImportDirective import_directive */ 7:
                    message.importDirective = ImportDirective.internalBinaryRead(reader, reader.uint32(), options, message.importDirective);
                    break;
                case /* string lockToken */ 8:
                    message.lockToken = reader.string();
                    break;
                case /* bool update_meta_document */ 9:
                    message.updateMetaDocument = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: UpdateRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateRequest["meta"] | undefined, val: UpdateRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.UpdateRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* newsdoc.Document document = 2; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> meta = 3; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        /* repeated elephant.repository.StatusUpdate status = 5; */
        for (let i = 0; i < message.status.length; i++)
            StatusUpdate.internalBinaryWrite(message.status[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.ACLEntry acl = 6; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.ImportDirective import_directive = 7; */
        if (message.importDirective)
            ImportDirective.internalBinaryWrite(message.importDirective, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string lockToken = 8; */
        if (message.lockToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lockToken);
        /* bool update_meta_document = 9; */
        if (message.updateMetaDocument !== false)
            writer.tag(9, WireType.Varint).bool(message.updateMetaDocument);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateRequest
 */
export const UpdateRequest = new UpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDirective$Type extends MessageType<ImportDirective> {
    constructor() {
        super("elephant.repository.ImportDirective", [
            { no: 1, name: "originally_created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "original_creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportDirective>): ImportDirective {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originallyCreated = "";
        message.originalCreator = "";
        if (value !== undefined)
            reflectionMergePartial<ImportDirective>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDirective): ImportDirective {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string originally_created */ 1:
                    message.originallyCreated = reader.string();
                    break;
                case /* string original_creator */ 2:
                    message.originalCreator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDirective, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string originally_created = 1; */
        if (message.originallyCreated !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originallyCreated);
        /* string original_creator = 2; */
        if (message.originalCreator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalCreator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ImportDirective
 */
export const ImportDirective = new ImportDirective$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("elephant.repository.UpdateResponse", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkUpdateRequest$Type extends MessageType<BulkUpdateRequest> {
    constructor() {
        super("elephant.repository.BulkUpdateRequest", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UpdateRequest }
        ]);
    }
    create(value?: PartialMessage<BulkUpdateRequest>): BulkUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<BulkUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkUpdateRequest): BulkUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.UpdateRequest updates */ 1:
                    message.updates.push(UpdateRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.UpdateRequest updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            UpdateRequest.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkUpdateRequest
 */
export const BulkUpdateRequest = new BulkUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkUpdateResponse$Type extends MessageType<BulkUpdateResponse> {
    constructor() {
        super("elephant.repository.BulkUpdateResponse", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UpdateResponse }
        ]);
    }
    create(value?: PartialMessage<BulkUpdateResponse>): BulkUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<BulkUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkUpdateResponse): BulkUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.UpdateResponse updates */ 1:
                    message.updates.push(UpdateResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.UpdateResponse updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            UpdateResponse.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkUpdateResponse
 */
export const BulkUpdateResponse = new BulkUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("elephant.repository.ValidateRequest", [
            { no: 1, name: "document", kind: "message", T: () => Document }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateResponse$Type extends MessageType<ValidateResponse> {
    constructor() {
        super("elephant.repository.ValidateResponse", [
            { no: 1, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidationResult }
        ]);
    }
    create(value?: PartialMessage<ValidateResponse>): ValidateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ValidateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateResponse): ValidateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.ValidationResult errors */ 1:
                    message.errors.push(ValidationResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.ValidationResult errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            ValidationResult.internalBinaryWrite(message.errors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateResponse
 */
export const ValidateResponse = new ValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationResult$Type extends MessageType<ValidationResult> {
    constructor() {
        super("elephant.repository.ValidationResult", [
            { no: 1, name: "entity", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EntityRef },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidationResult>): ValidationResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entity = [];
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ValidationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidationResult): ValidationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EntityRef entity */ 1:
                    message.entity.push(EntityRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EntityRef entity = 1; */
        for (let i = 0; i < message.entity.length; i++)
            EntityRef.internalBinaryWrite(message.entity[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidationResult
 */
export const ValidationResult = new ValidationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityRef$Type extends MessageType<EntityRef> {
    constructor() {
        super("elephant.repository.EntityRef", [
            { no: 1, name: "ref_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "rel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntityRef>): EntityRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refType = "";
        message.kind = "";
        message.index = 0n;
        message.name = "";
        message.type = "";
        message.rel = "";
        if (value !== undefined)
            reflectionMergePartial<EntityRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityRef): EntityRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ref_type */ 1:
                    message.refType = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* int64 index */ 3:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string rel */ 6:
                    message.rel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ref_type = 1; */
        if (message.refType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refType);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* int64 index = 3; */
        if (message.index !== 0n)
            writer.tag(3, WireType.Varint).int64(message.index);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string rel = 6; */
        if (message.rel !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EntityRef
 */
export const EntityRef = new EntityRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusUpdate$Type extends MessageType<StatusUpdate> {
    constructor() {
        super("elephant.repository.StatusUpdate", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StatusUpdate>): StatusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = 0n;
        message.meta = {};
        message.ifMatch = 0n;
        if (value !== undefined)
            reflectionMergePartial<StatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusUpdate): StatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: StatusUpdate["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatusUpdate["meta"] | undefined, val: StatusUpdate["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.StatusUpdate.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: StatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* map<string, string> meta = 3; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusUpdate
 */
export const StatusUpdate = new StatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsRequest$Type extends MessageType<UpdatePermissionsRequest> {
    constructor() {
        super("elephant.repository.UpdatePermissionsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<UpdatePermissionsRequest>): UpdatePermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsRequest): UpdatePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated elephant.repository.ACLEntry list */ 2:
                    message.list.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated elephant.repository.ACLEntry list = 2; */
        for (let i = 0; i < message.list.length; i++)
            ACLEntry.internalBinaryWrite(message.list[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsRequest
 */
export const UpdatePermissionsRequest = new UpdatePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsResponse$Type extends MessageType<UpdatePermissionsResponse> {
    constructor() {
        super("elephant.repository.UpdatePermissionsResponse", []);
    }
    create(value?: PartialMessage<UpdatePermissionsResponse>): UpdatePermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsResponse): UpdatePermissionsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdatePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsResponse
 */
export const UpdatePermissionsResponse = new UpdatePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentRequest$Type extends MessageType<DeleteDocumentRequest> {
    constructor() {
        super("elephant.repository.DeleteDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "lockToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocumentRequest>): DeleteDocumentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.meta = {};
        message.ifMatch = 0n;
        message.lockToken = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentRequest): DeleteDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* map<string, string> meta */ 2:
                    this.binaryReadMap2(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 3:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                case /* string lockToken */ 8:
                    message.lockToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: DeleteDocumentRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteDocumentRequest["meta"] | undefined, val: DeleteDocumentRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DeleteDocumentRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* map<string, string> meta = 2; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 3; */
        if (message.ifMatch !== 0n)
            writer.tag(3, WireType.Varint).int64(message.ifMatch);
        /* string lockToken = 8; */
        if (message.lockToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lockToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentRequest
 */
export const DeleteDocumentRequest = new DeleteDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentResponse$Type extends MessageType<DeleteDocumentResponse> {
    constructor() {
        super("elephant.repository.DeleteDocumentResponse", []);
    }
    create(value?: PartialMessage<DeleteDocumentResponse>): DeleteDocumentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentResponse): DeleteDocumentResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentResponse
 */
export const DeleteDocumentResponse = new DeleteDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreRequest$Type extends MessageType<RestoreRequest> {
    constructor() {
        super("elephant.repository.RestoreRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delete_record_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<RestoreRequest>): RestoreRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.deleteRecordId = 0n;
        message.acl = [];
        if (value !== undefined)
            reflectionMergePartial<RestoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreRequest): RestoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 delete_record_id */ 2:
                    message.deleteRecordId = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 3:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 delete_record_id = 2; */
        if (message.deleteRecordId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.deleteRecordId);
        /* repeated elephant.repository.ACLEntry acl = 3; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RestoreRequest
 */
export const RestoreRequest = new RestoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreResponse$Type extends MessageType<RestoreResponse> {
    constructor() {
        super("elephant.repository.RestoreResponse", []);
    }
    create(value?: PartialMessage<RestoreResponse>): RestoreResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RestoreResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreResponse): RestoreResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RestoreResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RestoreResponse
 */
export const RestoreResponse = new RestoreResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurgeRequest$Type extends MessageType<PurgeRequest> {
    constructor() {
        super("elephant.repository.PurgeRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delete_record_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PurgeRequest>): PurgeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.deleteRecordId = 0n;
        if (value !== undefined)
            reflectionMergePartial<PurgeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurgeRequest): PurgeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 delete_record_id */ 2:
                    message.deleteRecordId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PurgeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 delete_record_id = 2; */
        if (message.deleteRecordId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.deleteRecordId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.PurgeRequest
 */
export const PurgeRequest = new PurgeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurgeResponse$Type extends MessageType<PurgeResponse> {
    constructor() {
        super("elephant.repository.PurgeResponse", []);
    }
    create(value?: PartialMessage<PurgeResponse>): PurgeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PurgeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurgeResponse): PurgeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PurgeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.PurgeResponse
 */
export const PurgeResponse = new PurgeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDeletedRequest$Type extends MessageType<ListDeletedRequest> {
    constructor() {
        super("elephant.repository.ListDeletedRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "before_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timezone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDeletedRequest>): ListDeletedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.beforeId = 0n;
        message.beforeDate = "";
        message.timezone = "";
        if (value !== undefined)
            reflectionMergePartial<ListDeletedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDeletedRequest): ListDeletedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 before_id */ 2:
                    message.beforeId = reader.int64().toBigInt();
                    break;
                case /* string before_date */ 3:
                    message.beforeDate = reader.string();
                    break;
                case /* string timezone */ 4:
                    message.timezone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDeletedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 before_id = 2; */
        if (message.beforeId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.beforeId);
        /* string before_date = 3; */
        if (message.beforeDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.beforeDate);
        /* string timezone = 4; */
        if (message.timezone !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.timezone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListDeletedRequest
 */
export const ListDeletedRequest = new ListDeletedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDeletedResponse$Type extends MessageType<ListDeletedResponse> {
    constructor() {
        super("elephant.repository.ListDeletedResponse", [
            { no: 1, name: "deletes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeleteRecord }
        ]);
    }
    create(value?: PartialMessage<ListDeletedResponse>): ListDeletedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deletes = [];
        if (value !== undefined)
            reflectionMergePartial<ListDeletedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDeletedResponse): ListDeletedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.DeleteRecord deletes */ 1:
                    message.deletes.push(DeleteRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDeletedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.DeleteRecord deletes = 1; */
        for (let i = 0; i < message.deletes.length; i++)
            DeleteRecord.internalBinaryWrite(message.deletes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListDeletedResponse
 */
export const ListDeletedResponse = new ListDeletedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRecord$Type extends MessageType<DeleteRecord> {
    constructor() {
        super("elephant.repository.DeleteRecord", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 9, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "finalised", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "purged", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteRecord>): DeleteRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.uuid = "";
        message.uri = "";
        message.type = "";
        message.version = 0n;
        message.created = "";
        message.creator = "";
        message.meta = {};
        message.language = "";
        message.finalised = "";
        message.purged = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRecord): DeleteRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* string uri */ 3:
                    message.uri = reader.string();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string created */ 6:
                    message.created = reader.string();
                    break;
                case /* string creator */ 7:
                    message.creator = reader.string();
                    break;
                case /* map<string, string> meta */ 8:
                    this.binaryReadMap8(message.meta, reader, options);
                    break;
                case /* string language */ 9:
                    message.language = reader.string();
                    break;
                case /* string finalised */ 10:
                    message.finalised = reader.string();
                    break;
                case /* string purged */ 11:
                    message.purged = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: DeleteRecord["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteRecord["meta"] | undefined, val: DeleteRecord["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DeleteRecord.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* string uri = 3; */
        if (message.uri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uri);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        /* string created = 6; */
        if (message.created !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.created);
        /* string creator = 7; */
        if (message.creator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.creator);
        /* map<string, string> meta = 8; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* string language = 9; */
        if (message.language !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.language);
        /* string finalised = 10; */
        if (message.finalised !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.finalised);
        /* string purged = 11; */
        if (message.purged !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.purged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteRecord
 */
export const DeleteRecord = new DeleteRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaRequest$Type extends MessageType<GetMetaRequest> {
    constructor() {
        super("elephant.repository.GetMetaRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetaRequest>): GetMetaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetMetaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaRequest): GetMetaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaRequest
 */
export const GetMetaRequest = new GetMetaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaResponse$Type extends MessageType<GetMetaResponse> {
    constructor() {
        super("elephant.repository.GetMetaResponse", [
            { no: 1, name: "meta", kind: "message", T: () => DocumentMeta }
        ]);
    }
    create(value?: PartialMessage<GetMetaResponse>): GetMetaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMetaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaResponse): GetMetaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentMeta meta */ 1:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentMeta meta = 1; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaResponse
 */
export const GetMetaResponse = new GetMetaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMeta$Type extends MessageType<DocumentMeta> {
    constructor() {
        super("elephant.repository.DocumentMeta", [
            { no: 1, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "modified", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } },
            { no: 5, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 6, name: "lock", kind: "message", T: () => Lock },
            { no: 7, name: "is_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentMeta>): DocumentMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.created = "";
        message.modified = "";
        message.currentVersion = 0n;
        message.heads = {};
        message.acl = [];
        message.isMetaDocument = false;
        message.mainDocument = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentMeta): DocumentMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string created */ 1:
                    message.created = reader.string();
                    break;
                case /* string modified */ 2:
                    message.modified = reader.string();
                    break;
                case /* int64 current_version */ 3:
                    message.currentVersion = reader.int64().toBigInt();
                    break;
                case /* map<string, elephant.repository.Status> heads */ 4:
                    this.binaryReadMap4(message.heads, reader, options);
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 5:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* elephant.repository.Lock lock */ 6:
                    message.lock = Lock.internalBinaryRead(reader, reader.uint32(), options, message.lock);
                    break;
                case /* bool is_meta_document */ 7:
                    message.isMetaDocument = reader.bool();
                    break;
                case /* string main_document */ 8:
                    message.mainDocument = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentMeta["heads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentMeta["heads"] | undefined, val: DocumentMeta["heads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentMeta.heads");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    internalBinaryWrite(message: DocumentMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string created = 1; */
        if (message.created !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.created);
        /* string modified = 2; */
        if (message.modified !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modified);
        /* int64 current_version = 3; */
        if (message.currentVersion !== 0n)
            writer.tag(3, WireType.Varint).int64(message.currentVersion);
        /* map<string, elephant.repository.Status> heads = 4; */
        for (let k of globalThis.Object.keys(message.heads)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.heads[k], writer, options);
            writer.join().join();
        }
        /* repeated elephant.repository.ACLEntry acl = 5; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.Lock lock = 6; */
        if (message.lock)
            Lock.internalBinaryWrite(message.lock, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool is_meta_document = 7; */
        if (message.isMetaDocument !== false)
            writer.tag(7, WireType.Varint).bool(message.isMetaDocument);
        /* string main_document = 8; */
        if (message.mainDocument !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.mainDocument);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentMeta
 */
export const DocumentMeta = new DocumentMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("elephant.repository.Status", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "meta_doc_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.version = 0n;
        message.creator = "";
        message.created = "";
        message.meta = {};
        message.metaDocVersion = 0n;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* string created */ 4:
                    message.created = reader.string();
                    break;
                case /* map<string, string> meta */ 5:
                    this.binaryReadMap5(message.meta, reader, options);
                    break;
                case /* int64 meta_doc_version */ 6:
                    message.metaDocVersion = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Status["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Status["meta"] | undefined, val: Status["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.Status.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* string created = 4; */
        if (message.created !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.created);
        /* map<string, string> meta = 5; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 meta_doc_version = 6; */
        if (message.metaDocVersion !== 0n)
            writer.tag(6, WireType.Varint).int64(message.metaDocVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ACLEntry$Type extends MessageType<ACLEntry> {
    constructor() {
        super("elephant.repository.ACLEntry", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ACLEntry>): ACLEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<ACLEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ACLEntry): ACLEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* repeated string permissions */ 2:
                    message.permissions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ACLEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* repeated string permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.permissions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ACLEntry
 */
export const ACLEntry = new ACLEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Lock$Type extends MessageType<Lock> {
    constructor() {
        super("elephant.repository.Lock", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expires", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "app", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Lock>): Lock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.uri = "";
        message.created = "";
        message.expires = "";
        message.app = "";
        message.comment = "";
        if (value !== undefined)
            reflectionMergePartial<Lock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Lock): Lock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string uri */ 2:
                    message.uri = reader.string();
                    break;
                case /* string created */ 3:
                    message.created = reader.string();
                    break;
                case /* string expires */ 4:
                    message.expires = reader.string();
                    break;
                case /* string app */ 5:
                    message.app = reader.string();
                    break;
                case /* string comment */ 6:
                    message.comment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Lock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string uri = 2; */
        if (message.uri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uri);
        /* string created = 3; */
        if (message.created !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.created);
        /* string expires = 4; */
        if (message.expires !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.expires);
        /* string app = 5; */
        if (message.app !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.app);
        /* string comment = 6; */
        if (message.comment !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.comment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Lock
 */
export const Lock = new Lock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeRequest$Type extends MessageType<RegisterMetaTypeRequest> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "exclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetaTypeRequest>): RegisterMetaTypeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.exclusive = false;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeRequest): RegisterMetaTypeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool exclusive */ 2:
                    message.exclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetaTypeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bool exclusive = 2; */
        if (message.exclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.exclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeRequest
 */
export const RegisterMetaTypeRequest = new RegisterMetaTypeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeResponse$Type extends MessageType<RegisterMetaTypeResponse> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeResponse", []);
    }
    create(value?: PartialMessage<RegisterMetaTypeResponse>): RegisterMetaTypeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeResponse): RegisterMetaTypeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetaTypeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeResponse
 */
export const RegisterMetaTypeResponse = new RegisterMetaTypeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeUseRequest$Type extends MessageType<RegisterMetaTypeUseRequest> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeUseRequest", [
            { no: 1, name: "main_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "meta_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetaTypeUseRequest>): RegisterMetaTypeUseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mainType = "";
        message.metaType = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeUseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeUseRequest): RegisterMetaTypeUseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string main_type */ 1:
                    message.mainType = reader.string();
                    break;
                case /* string meta_type */ 2:
                    message.metaType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetaTypeUseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string main_type = 1; */
        if (message.mainType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mainType);
        /* string meta_type = 2; */
        if (message.metaType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.metaType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeUseRequest
 */
export const RegisterMetaTypeUseRequest = new RegisterMetaTypeUseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeUseResponse$Type extends MessageType<RegisterMetaTypeUseResponse> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeUseResponse", []);
    }
    create(value?: PartialMessage<RegisterMetaTypeUseResponse>): RegisterMetaTypeUseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeUseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeUseResponse): RegisterMetaTypeUseResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetaTypeUseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeUseResponse
 */
export const RegisterMetaTypeUseResponse = new RegisterMetaTypeUseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaRequest$Type extends MessageType<RegisterSchemaRequest> {
    constructor() {
        super("elephant.repository.RegisterSchemaRequest", [
            { no: 1, name: "schema", kind: "message", T: () => Schema },
            { no: 2, name: "activate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "schema_sha256", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterSchemaRequest>): RegisterSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activate = false;
        message.schemaUrl = "";
        message.schemaSha256 = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaRequest): RegisterSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Schema schema */ 1:
                    message.schema = Schema.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* bool activate */ 2:
                    message.activate = reader.bool();
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                case /* string schema_sha256 */ 4:
                    message.schemaSha256 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Schema schema = 1; */
        if (message.schema)
            Schema.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool activate = 2; */
        if (message.activate !== false)
            writer.tag(2, WireType.Varint).bool(message.activate);
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        /* string schema_sha256 = 4; */
        if (message.schemaSha256 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.schemaSha256);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaRequest
 */
export const RegisterSchemaRequest = new RegisterSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaResponse$Type extends MessageType<RegisterSchemaResponse> {
    constructor() {
        super("elephant.repository.RegisterSchemaResponse", []);
    }
    create(value?: PartialMessage<RegisterSchemaResponse>): RegisterSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaResponse): RegisterSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaResponse
 */
export const RegisterSchemaResponse = new RegisterSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaRequest$Type extends MessageType<SetActiveSchemaRequest> {
    constructor() {
        super("elephant.repository.SetActiveSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deactivate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetActiveSchemaRequest>): SetActiveSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.deactivate = false;
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaRequest): SetActiveSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* bool deactivate */ 3:
                    message.deactivate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetActiveSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* bool deactivate = 3; */
        if (message.deactivate !== false)
            writer.tag(3, WireType.Varint).bool(message.deactivate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaRequest
 */
export const SetActiveSchemaRequest = new SetActiveSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaResponse$Type extends MessageType<SetActiveSchemaResponse> {
    constructor() {
        super("elephant.repository.SetActiveSchemaResponse", []);
    }
    create(value?: PartialMessage<SetActiveSchemaResponse>): SetActiveSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaResponse): SetActiveSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetActiveSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaResponse
 */
export const SetActiveSchemaResponse = new SetActiveSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("elephant.repository.GetSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("elephant.repository.GetSchemaResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spec", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.spec = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* bytes spec */ 2:
                    message.spec = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* bytes spec = 2; */
        if (message.spec.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasRequest$Type extends MessageType<GetAllActiveSchemasRequest> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasRequest", [
            { no: 1, name: "wait_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "known", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasRequest>): GetAllActiveSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.waitSeconds = 0n;
        message.known = {};
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasRequest): GetAllActiveSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 wait_seconds */ 1:
                    message.waitSeconds = reader.int64().toBigInt();
                    break;
                case /* map<string, string> known */ 2:
                    this.binaryReadMap2(message.known, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GetAllActiveSchemasRequest["known"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAllActiveSchemasRequest["known"] | undefined, val: GetAllActiveSchemasRequest["known"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetAllActiveSchemasRequest.known");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetAllActiveSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 wait_seconds = 1; */
        if (message.waitSeconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.waitSeconds);
        /* map<string, string> known = 2; */
        for (let k of globalThis.Object.keys(message.known))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.known[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export const GetAllActiveSchemasRequest = new GetAllActiveSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasResponse$Type extends MessageType<GetAllActiveSchemasResponse> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasResponse", [
            { no: 1, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Schema }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasResponse>): GetAllActiveSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemas = [];
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasResponse): GetAllActiveSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Schema schemas */ 1:
                    message.schemas.push(Schema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllActiveSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Schema schemas = 1; */
        for (let i = 0; i < message.schemas.length; i++)
            Schema.internalBinaryWrite(message.schemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export const GetAllActiveSchemasResponse = new GetAllActiveSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("elephant.repository.Schema", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spec", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.spec = "";
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* string spec */ 3:
                    message.spec = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* string spec = 3; */
        if (message.spec !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeprecationsRequest$Type extends MessageType<GetDeprecationsRequest> {
    constructor() {
        super("elephant.repository.GetDeprecationsRequest", []);
    }
    create(value?: PartialMessage<GetDeprecationsRequest>): GetDeprecationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDeprecationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeprecationsRequest): GetDeprecationsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDeprecationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeprecationsRequest
 */
export const GetDeprecationsRequest = new GetDeprecationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deprecation$Type extends MessageType<Deprecation> {
    constructor() {
        super("elephant.repository.Deprecation", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enforced", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Deprecation>): Deprecation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.enforced = false;
        if (value !== undefined)
            reflectionMergePartial<Deprecation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deprecation): Deprecation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* bool enforced */ 2:
                    message.enforced = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deprecation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* bool enforced = 2; */
        if (message.enforced !== false)
            writer.tag(2, WireType.Varint).bool(message.enforced);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Deprecation
 */
export const Deprecation = new Deprecation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeprecationsResponse$Type extends MessageType<GetDeprecationsResponse> {
    constructor() {
        super("elephant.repository.GetDeprecationsResponse", [
            { no: 1, name: "deprecations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Deprecation }
        ]);
    }
    create(value?: PartialMessage<GetDeprecationsResponse>): GetDeprecationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deprecations = [];
        if (value !== undefined)
            reflectionMergePartial<GetDeprecationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeprecationsResponse): GetDeprecationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Deprecation deprecations */ 1:
                    message.deprecations.push(Deprecation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeprecationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Deprecation deprecations = 1; */
        for (let i = 0; i < message.deprecations.length; i++)
            Deprecation.internalBinaryWrite(message.deprecations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeprecationsResponse
 */
export const GetDeprecationsResponse = new GetDeprecationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeprecationRequest$Type extends MessageType<UpdateDeprecationRequest> {
    constructor() {
        super("elephant.repository.UpdateDeprecationRequest", [
            { no: 1, name: "deprecation", kind: "message", T: () => Deprecation }
        ]);
    }
    create(value?: PartialMessage<UpdateDeprecationRequest>): UpdateDeprecationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDeprecationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeprecationRequest): UpdateDeprecationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Deprecation deprecation */ 1:
                    message.deprecation = Deprecation.internalBinaryRead(reader, reader.uint32(), options, message.deprecation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDeprecationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Deprecation deprecation = 1; */
        if (message.deprecation)
            Deprecation.internalBinaryWrite(message.deprecation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateDeprecationRequest
 */
export const UpdateDeprecationRequest = new UpdateDeprecationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeprecationResponse$Type extends MessageType<UpdateDeprecationResponse> {
    constructor() {
        super("elephant.repository.UpdateDeprecationResponse", []);
    }
    create(value?: PartialMessage<UpdateDeprecationResponse>): UpdateDeprecationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDeprecationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeprecationResponse): UpdateDeprecationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateDeprecationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateDeprecationResponse
 */
export const UpdateDeprecationResponse = new UpdateDeprecationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindRequest$Type extends MessageType<RegisterMetricKindRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricKindRequest>): RegisterMetricKindRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aggregation = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindRequest): RegisterMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindRequest
 */
export const RegisterMetricKindRequest = new RegisterMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindResponse$Type extends MessageType<RegisterMetricKindResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricKindResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricKindResponse>): RegisterMetricKindResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindResponse): RegisterMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindResponse
 */
export const RegisterMetricKindResponse = new RegisterMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindRequest$Type extends MessageType<DeleteMetricKindRequest> {
    constructor() {
        super("elephant.repository.DeleteMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMetricKindRequest>): DeleteMetricKindRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindRequest): DeleteMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindRequest
 */
export const DeleteMetricKindRequest = new DeleteMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindResponse$Type extends MessageType<DeleteMetricKindResponse> {
    constructor() {
        super("elephant.repository.DeleteMetricKindResponse", []);
    }
    create(value?: PartialMessage<DeleteMetricKindResponse>): DeleteMetricKindResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindResponse): DeleteMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindResponse
 */
export const DeleteMetricKindResponse = new DeleteMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsRequest$Type extends MessageType<GetMetricKindsRequest> {
    constructor() {
        super("elephant.repository.GetMetricKindsRequest", []);
    }
    create(value?: PartialMessage<GetMetricKindsRequest>): GetMetricKindsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsRequest): GetMetricKindsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMetricKindsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsRequest
 */
export const GetMetricKindsRequest = new GetMetricKindsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsResponse$Type extends MessageType<GetMetricKindsResponse> {
    constructor() {
        super("elephant.repository.GetMetricKindsResponse", [
            { no: 1, name: "kinds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricKind }
        ]);
    }
    create(value?: PartialMessage<GetMetricKindsResponse>): GetMetricKindsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kinds = [];
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsResponse): GetMetricKindsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.MetricKind kinds */ 1:
                    message.kinds.push(MetricKind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricKindsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.MetricKind kinds = 1; */
        for (let i = 0; i < message.kinds.length; i++)
            MetricKind.internalBinaryWrite(message.kinds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsResponse
 */
export const GetMetricKindsResponse = new GetMetricKindsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricKind$Type extends MessageType<MetricKind> {
    constructor() {
        super("elephant.repository.MetricKind", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<MetricKind>): MetricKind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aggregation = 0;
        if (value !== undefined)
            reflectionMergePartial<MetricKind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricKind): MetricKind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricKind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetricKind
 */
export const MetricKind = new MetricKind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricRequest$Type extends MessageType<RegisterMetricRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricRequest>): RegisterMetricRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.kind = "";
        message.label = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricRequest): RegisterMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* int64 value */ 5:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* int64 value = 5; */
        if (message.value !== 0n)
            writer.tag(5, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricRequest
 */
export const RegisterMetricRequest = new RegisterMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricResponse$Type extends MessageType<RegisterMetricResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricResponse>): RegisterMetricResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricResponse): RegisterMetricResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricResponse
 */
export const RegisterMetricResponse = new RegisterMetricResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsRequest$Type extends MessageType<GetMetricsRequest> {
    constructor() {
        super("elephant.repository.GetMetricsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetricsRequest>): GetMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.kind = "";
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<GetMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsRequest): GetMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricsRequest
 */
export const GetMetricsRequest = new GetMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsResponse$Type extends MessageType<GetMetricsResponse> {
    constructor() {
        super("elephant.repository.GetMetricsResponse", [
            { no: 2, name: "metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Metric }
        ]);
    }
    create(value?: PartialMessage<GetMetricsResponse>): GetMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metrics = [];
        if (value !== undefined)
            reflectionMergePartial<GetMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsResponse): GetMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Metric metrics */ 2:
                    message.metrics.push(Metric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Metric metrics = 2; */
        for (let i = 0; i < message.metrics.length; i++)
            Metric.internalBinaryWrite(message.metrics[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricsResponse
 */
export const GetMetricsResponse = new GetMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metric$Type extends MessageType<Metric> {
    constructor() {
        super("elephant.repository.Metric", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Metric>): Metric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.label = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metric): Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* int64 value */ 3:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* int64 value = 3; */
        if (message.value !== 0n)
            writer.tag(3, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Metric
 */
export const Metric = new Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockRequest$Type extends MessageType<LockRequest> {
    constructor() {
        super("elephant.repository.LockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ttl", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "app", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LockRequest>): LockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.ttl = 0;
        message.app = "";
        message.comment = "";
        if (value !== undefined)
            reflectionMergePartial<LockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockRequest): LockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int32 ttl */ 2:
                    message.ttl = reader.int32();
                    break;
                case /* string app */ 3:
                    message.app = reader.string();
                    break;
                case /* string comment */ 4:
                    message.comment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int32 ttl = 2; */
        if (message.ttl !== 0)
            writer.tag(2, WireType.Varint).int32(message.ttl);
        /* string app = 3; */
        if (message.app !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.app);
        /* string comment = 4; */
        if (message.comment !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.comment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.LockRequest
 */
export const LockRequest = new LockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockResponse$Type extends MessageType<LockResponse> {
    constructor() {
        super("elephant.repository.LockResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expires", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LockResponse>): LockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.expires = "";
        if (value !== undefined)
            reflectionMergePartial<LockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockResponse): LockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string expires */ 2:
                    message.expires = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string expires = 2; */
        if (message.expires !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.expires);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.LockResponse
 */
export const LockResponse = new LockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendLockRequest$Type extends MessageType<ExtendLockRequest> {
    constructor() {
        super("elephant.repository.ExtendLockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ttl", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExtendLockRequest>): ExtendLockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.ttl = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ExtendLockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendLockRequest): ExtendLockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int32 ttl */ 2:
                    message.ttl = reader.int32();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendLockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int32 ttl = 2; */
        if (message.ttl !== 0)
            writer.tag(2, WireType.Varint).int32(message.ttl);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ExtendLockRequest
 */
export const ExtendLockRequest = new ExtendLockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockRequest$Type extends MessageType<UnlockRequest> {
    constructor() {
        super("elephant.repository.UnlockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockRequest>): UnlockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<UnlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockRequest): UnlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UnlockRequest
 */
export const UnlockRequest = new UnlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockResponse$Type extends MessageType<UnlockResponse> {
    constructor() {
        super("elephant.repository.UnlockResponse", []);
    }
    create(value?: PartialMessage<UnlockResponse>): UnlockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UnlockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockResponse): UnlockResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UnlockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UnlockResponse
 */
export const UnlockResponse = new UnlockResponse$Type();
/**
 * @generated ServiceType for protobuf service elephant.repository.Documents
 */
export const Documents = new ServiceType("elephant.repository.Documents", [
    { name: "Get", options: {}, I: GetDocumentRequest, O: GetDocumentResponse },
    { name: "BulkGet", options: {}, I: BulkGetRequest, O: BulkGetResponse },
    { name: "GetHistory", options: {}, I: GetHistoryRequest, O: GetHistoryResponse },
    { name: "Update", options: {}, I: UpdateRequest, O: UpdateResponse },
    { name: "BulkUpdate", options: {}, I: BulkUpdateRequest, O: BulkUpdateResponse },
    { name: "Validate", options: {}, I: ValidateRequest, O: ValidateResponse },
    { name: "Delete", options: {}, I: DeleteDocumentRequest, O: DeleteDocumentResponse },
    { name: "ListDeleted", options: {}, I: ListDeletedRequest, O: ListDeletedResponse },
    { name: "Restore", options: {}, I: RestoreRequest, O: RestoreResponse },
    { name: "Purge", options: {}, I: PurgeRequest, O: PurgeResponse },
    { name: "GetMeta", options: {}, I: GetMetaRequest, O: GetMetaResponse },
    { name: "Eventlog", options: {}, I: GetEventlogRequest, O: GetEventlogResponse },
    { name: "CompactedEventlog", options: {}, I: GetCompactedEventlogRequest, O: GetCompactedEventlogResponse },
    { name: "GetStatus", options: {}, I: GetStatusRequest, O: GetStatusResponse },
    { name: "GetStatusHistory", options: {}, I: GetStatusHistoryRequest, O: GetStatusHistoryReponse },
    { name: "GetStatusOverview", options: {}, I: GetStatusOverviewRequest, O: GetStatusOverviewResponse },
    { name: "GetPermissions", options: {}, I: GetPermissionsRequest, O: GetPermissionsResponse },
    { name: "Lock", options: {}, I: LockRequest, O: LockResponse },
    { name: "ExtendLock", options: {}, I: ExtendLockRequest, O: LockResponse },
    { name: "Unlock", options: {}, I: UnlockRequest, O: UnlockResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Schemas
 */
export const Schemas = new ServiceType("elephant.repository.Schemas", [
    { name: "Register", options: {}, I: RegisterSchemaRequest, O: RegisterSchemaResponse },
    { name: "SetActive", options: {}, I: SetActiveSchemaRequest, O: SetActiveSchemaResponse },
    { name: "Get", options: {}, I: GetSchemaRequest, O: GetSchemaResponse },
    { name: "GetAllActive", options: {}, I: GetAllActiveSchemasRequest, O: GetAllActiveSchemasResponse },
    { name: "RegisterMetaType", options: {}, I: RegisterMetaTypeRequest, O: RegisterMetaTypeResponse },
    { name: "RegisterMetaTypeUse", options: {}, I: RegisterMetaTypeUseRequest, O: RegisterMetaTypeUseResponse },
    { name: "GetDeprecations", options: {}, I: GetDeprecationsRequest, O: GetDeprecationsResponse },
    { name: "UpdateDeprecation", options: {}, I: UpdateDeprecationRequest, O: UpdateDeprecationResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Workflows
 */
export const Workflows = new ServiceType("elephant.repository.Workflows", [
    { name: "UpdateStatus", options: {}, I: UpdateStatusRequest, O: UpdateStatusResponse },
    { name: "GetStatuses", options: {}, I: GetStatusesRequest, O: GetStatusesResponse },
    { name: "CreateStatusRule", options: {}, I: CreateStatusRuleRequest, O: CreateStatusRuleResponse },
    { name: "DeleteStatusRule", options: {}, I: DeleteStatusRuleRequest, O: DeleteStatusRuleResponse },
    { name: "GetStatusRules", options: {}, I: GetStatusRulesRequest, O: GetStatusRulesResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Reports
 */
export const Reports = new ServiceType("elephant.repository.Reports", [
    { name: "List", options: {}, I: ListReportsRequest, O: ListReportsResponse },
    { name: "Update", options: {}, I: UpdateReportRequest, O: UpdateReportResponse },
    { name: "Get", options: {}, I: GetReportRequest, O: GetReportResponse },
    { name: "Delete", options: {}, I: DeleteReportRequest, O: DeleteReportResponse },
    { name: "Run", options: {}, I: RunReportRequest, O: RunReportResponse },
    { name: "Test", options: {}, I: TestReportRequest, O: TestReportResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Metrics
 */
export const Metrics = new ServiceType("elephant.repository.Metrics", [
    { name: "RegisterKind", options: {}, I: RegisterMetricKindRequest, O: RegisterMetricKindResponse },
    { name: "DeleteKind", options: {}, I: DeleteMetricKindRequest, O: DeleteMetricKindResponse },
    { name: "GetKinds", options: {}, I: GetMetricKindsRequest, O: GetMetricKindsResponse },
    { name: "RegisterMetric", options: {}, I: RegisterMetricRequest, O: RegisterMetricResponse },
    { name: "GetMetrics", options: {}, I: GetMetricsRequest, O: GetMetricsResponse }
]);

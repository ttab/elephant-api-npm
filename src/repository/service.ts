/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "repository/service.proto" (package "elephant.repository", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Document } from "../newsdoc/newsdoc";
/**
 * @generated from protobuf message elephant.repository.GetStatusRequest
 */
export interface GetStatusRequest {
    /**
     * UUID of the document to get the status history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Name of the status to get.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * ID of the status to get. Optional, will default to the latest status.
     *
     * @generated from protobuf field: int64 id = 3;
     */
    id: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusResponse
 */
export interface GetStatusResponse {
    /**
     * @generated from protobuf field: elephant.repository.Status status = 1;
     */
    status?: Status;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryRequest
 */
export interface GetStatusHistoryRequest {
    /**
     * UUID of the document to get the status history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Name of the status to get.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Before is a status ID used to page backwards through the status history. If
     * no ID or a zero ID is provided the list will start with the lastest status.
     *
     * @generated from protobuf field: int64 before = 3;
     */
    before: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryReponse
 */
export interface GetStatusHistoryReponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Status statuses = 1;
     */
    statuses: Status[];
}
/**
 * @generated from protobuf message elephant.repository.GetNilStatusesRequest
 */
export interface GetNilStatusesRequest {
    /**
     * UUID of the document to get the nil statuses for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Names of statuses to get, optional. Defaults to all statuses.
     *
     * @generated from protobuf field: repeated string names = 2;
     */
    names: string[];
}
/**
 * @generated from protobuf message elephant.repository.GetNilStatusesResponse
 */
export interface GetNilStatusesResponse {
    /**
     * @generated from protobuf field: map<string, elephant.repository.DocumentStatuses> statuses = 1;
     */
    statuses: {
        [key: string]: DocumentStatuses;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetStatusOverviewRequest
 */
export interface GetStatusOverviewRequest {
    /**
     * UUIDs to get statuses for.
     *
     * @generated from protobuf field: repeated string uuids = 1;
     */
    uuids: string[];
    /**
     * Statuses to return information for. Optional, omit to only return workflow
     * state.
     *
     * @generated from protobuf field: repeated string statuses = 2;
     */
    statuses: string[];
    /**
     * GetMeta can be used to load any set status metadata.
     *
     * @generated from protobuf field: bool get_meta = 3;
     */
    getMeta: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusOverviewResponse
 */
export interface GetStatusOverviewResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.StatusOverviewItem items = 1;
     */
    items: StatusOverviewItem[];
}
/**
 * @generated from protobuf message elephant.repository.StatusOverviewItem
 */
export interface StatusOverviewItem {
    /**
     * UUID of the document.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version is the current version (last written version) of the document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Modified timestamp is the RFC3339 timestamp for the last change that
     * affected the document.
     *
     * @generated from protobuf field: string modified = 3;
     */
    modified: string;
    /**
     * Heads are the last statuses.
     *
     * @generated from protobuf field: map<string, elephant.repository.Status> heads = 4;
     */
    heads: {
        [key: string]: Status;
    };
    /**
     * WorkflowState that the document is in.
     *
     * @generated from protobuf field: string workflow_state = 5;
     */
    workflowState: string;
    /**
     * WorkflowCheckpoint that the document reached most recently.
     *
     * @generated from protobuf field: string workflow_checkpoint = 6;
     */
    workflowCheckpoint: string;
    /**
     * CreatorURI is the URI of the subject that created the document.
     *
     * @generated from protobuf field: string creator_uri = 7;
     */
    creatorUri: string;
    /**
     * UpdaterURI is the URI of the subject that last updated the document.
     *
     * @generated from protobuf field: string updater_uri = 8;
     */
    updaterUri: string;
}
/**
 * @generated from protobuf message elephant.repository.GetPermissionsRequest
 */
export interface GetPermissionsRequest {
    /**
     * UUID of the document to get the permissions for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetPermissionsResponse
 */
export interface GetPermissionsResponse {
    /**
     * Permissions that the client has for the document. The map is keyed by the
     * permission the client has and the value is either the client subject, the
     * unit URI if the permission was granted through a unit membership, or
     * "scope://[name]" if it was granted through elevated privileges.
     *
     * @generated from protobuf field: map<string, string> permissions = 1;
     */
    permissions: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogRequest
 */
export interface GetEventlogRequest {
    /**
     * After specifies the event ID after which to start returning events. A
     * negative value of -N will start from the N most recent events.
     *
     * @generated from protobuf field: int64 after = 1;
     */
    after: bigint;
    /**
     * Wait is the maximum time to wait for new events. Defaults to 2000.
     *
     * @generated from protobuf field: int32 wait_ms = 2;
     */
    waitMs: number;
    /**
     * BatchSize is the number of events we want in the response. Defaults to 10.
     *
     * @generated from protobuf field: int32 batch_size = 3;
     */
    batchSize: number;
    /**
     * BatchWaitMs is the maximum time we wait for a batch to be filled. Defaults to 200.
     *
     * @generated from protobuf field: int32 batch_wait_ms = 4;
     */
    batchWaitMs: number;
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogResponse
 */
export interface GetEventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.EventlogItem items = 1;
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repository.GetCompactedEventlogRequest
 */
export interface GetCompactedEventlogRequest {
    /**
     * After specifies the event ID after which to start returning events.
     *
     * @generated from protobuf field: int64 after = 1;
     */
    after: bigint;
    /**
     * Until allows us to control the number of events we want to evaluate when
     * compacting. Must be between 1 and 10000 more than `after`, and cannot be
     * greater than the current last event.
     *
     * @generated from protobuf field: int64 until = 3;
     */
    until: bigint;
    /**
     * Limit restricts the number of events we want returned for each
     * call. Together with `offset` this allows us to page through the unique
     * document events between `after` and `until`. Defaults to 0, meaning no
     * limit.
     *
     * @generated from protobuf field: int32 limit = 4;
     */
    limit: number;
    /**
     * Offset allows us to skip N number of events relative to `after`. So while
     * `after` and until allows us to paginate through the log as a whole,
     * `offset` and `limit` allows us to page through the unique document events
     * between `after` and `until`. Defaults to 0, meaning no offset.
     *
     * @generated from protobuf field: int32 offset = 5;
     */
    offset: number;
    /**
     * Type is used to only return events for documents of the given
     * type. Defaults to empty, which will return events for all document types.
     *
     * @generated from protobuf field: string type = 6;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.GetCompactedEventlogResponse
 */
export interface GetCompactedEventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.EventlogItem items = 1;
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repository.EventlogItem
 */
export interface EventlogItem {
    /**
     * Id of the event.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Event type, one of: "document", "status", "acl", "delete_document",
     * "restore_finished".
     *
     * @generated from protobuf field: string event = 2;
     */
    event: string;
    /**
     * Uuid of the document that was affected.
     *
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * Timestamp that the event occurred, as an RFC3339 timestamp.
     *
     * @generated from protobuf field: string timestamp = 4;
     */
    timestamp: string;
    /**
     * Version of the document.
     *
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
    /**
     * Status that was affected, if it was a "status" event.
     *
     * @generated from protobuf field: string status = 6;
     */
    status: string;
    /**
     * StatusId is the ID of the created status.
     *
     * @generated from protobuf field: int64 status_id = 7;
     */
    statusId: bigint;
    /**
     * Acl entry, if it was an "acl" event.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 8;
     */
    acl: ACLEntry[];
    /**
     * UpdaterUri is the URI for the subject that performed the update.
     *
     * @generated from protobuf field: string updater_uri = 9;
     */
    updaterUri: string;
    /**
     * Type of the affected document.
     *
     * @generated from protobuf field: string type = 10;
     */
    type: string;
    /**
     * Language of the affected document.
     *
     * @generated from protobuf field: string language = 11;
     */
    language: string;
    /**
     * OldLanguage of the document if the document changed language.
     *
     * @generated from protobuf field: string old_language = 12;
     */
    oldLanguage: string;
    /**
     * MainDocument UUID if the document is a metadata document.
     *
     * @generated from protobuf field: string main_document = 13;
     */
    mainDocument: string;
    /**
     * SystemState is set to "restoring" if this event was generated from a
     * restore operation. If the event wasn't generated by a special operation it
     * is left empty.
     *
     * @generated from protobuf field: string system_state = 14;
     */
    systemState: string;
    /**
     * WorkflowState that the document is in.
     *
     * @generated from protobuf field: string workflow_state = 15;
     */
    workflowState: string;
    /**
     * WorkflowCheckpoint that the document reached most recently.
     *
     * @generated from protobuf field: string workflow_checkpoint = 16;
     */
    workflowCheckpoint: string;
    /**
     * MainDocumentType is the type of the main document if the document is a
     * metadata document.
     *
     * @generated from protobuf field: string main_document_type = 17;
     */
    mainDocumentType: string;
    /**
     * AttachedObjects contains the object names, f.ex. "image" or "audio", when
     * when objects (files) were attached together with a document update.
     *
     * @generated from protobuf field: repeated string attached_objects = 18;
     */
    attachedObjects: string[];
    /**
     * DetachedObjects contains the object names, f.ex. "image" or "audio", when
     * when objects (files) were detached in a document update.
     *
     * @generated from protobuf field: repeated string detached_objects = 19;
     */
    detachedObjects: string[];
    /**
     * DeleteRecordId is the ID of the delete record if this was a delete event.
     *
     * @generated from protobuf field: int64 delete_record_id = 20;
     */
    deleteRecordId: bigint;
    /**
     * DocumentNonce is the unique nonce for this document. If the document is deleted and
     * recreated with the same ID it will still have a unique nonce.
     *
     * @generated from protobuf field: string document_nonce = 21;
     */
    documentNonce: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesRequest
 */
export interface GetStatusRulesRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesResponse
 */
export interface GetStatusRulesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.StatusRule rules = 1;
     */
    rules: StatusRule[];
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesRequest
 */
export interface GetStatusesRequest {
    /**
     * Type of documents to get statuses from.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.SetWorkflowRequest
 */
export interface SetWorkflowRequest {
    /**
     * Type of the document that this workflow is for.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Workflow declaration.
     *
     * @generated from protobuf field: elephant.repository.DocumentWorkflow workflow = 2;
     */
    workflow?: DocumentWorkflow;
}
/**
 * @generated from protobuf message elephant.repository.DocumentWorkflow
 */
export interface DocumentWorkflow {
    /**
     * StepZero is the step that the state begins in, or reverts to after a
     * checkpoint.
     *
     * @generated from protobuf field: string step_zero = 1;
     */
    stepZero: string;
    /**
     * Checkpoint is the status that should be used as the state checkpoint.
     *
     * @generated from protobuf field: string checkpoint = 2;
     */
    checkpoint: string;
    /**
     * NegativeCheckpoint is the state that should be used when the checkpoint
     * status is set using a negative version.
     *
     * @generated from protobuf field: string negative_checkpoint = 3;
     */
    negativeCheckpoint: string;
    /**
     * Steps are the names of statuses that should be used as steps between
     * checkpoints.
     *
     * @generated from protobuf field: repeated string steps = 4;
     */
    steps: string[];
}
/**
 * @generated from protobuf message elephant.repository.SetWorkflowResponse
 */
export interface SetWorkflowResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetWorkflowRequest
 */
export interface GetWorkflowRequest {
    /**
     * Type of the document to get workflow for.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.GetWorkflowResponse
 */
export interface GetWorkflowResponse {
    /**
     * Workflow declaration.
     *
     * @generated from protobuf field: elephant.repository.DocumentWorkflow workflow = 1;
     */
    workflow?: DocumentWorkflow;
    /**
     * UpdaterURI identifies the user that last updated the workflow.
     *
     * @generated from protobuf field: string updater_uri = 2;
     */
    updaterUri: string;
    /**
     * Updated is the update time as a RFC3339 timestamp.
     *
     * @generated from protobuf field: string updated = 3;
     */
    updated: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteWorkflowRequest
 */
export interface DeleteWorkflowRequest {
    /**
     * Type of the document to remove the workflow for.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteWorkflowResponse
 */
export interface DeleteWorkflowResponse {
}
/**
 * @generated from protobuf message elephant.repository.WorkflowStatus
 */
export interface WorkflowStatus {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesResponse
 */
export interface GetStatusesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.WorkflowStatus statuses = 1;
     */
    statuses: WorkflowStatus[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusRequest
 */
export interface UpdateStatusRequest {
    /**
     * Type that the status is valid for.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Name of the status.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Disabled disables the status so that it cannot be used when setting new
     * statuses.
     *
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusResponse
 */
export interface UpdateStatusResponse {
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleRequest
 */
export interface CreateStatusRuleRequest {
    /**
     * @generated from protobuf field: elephant.repository.StatusRule rule = 1;
     */
    rule?: StatusRule;
}
/**
 * @generated from protobuf message elephant.repository.StatusRule
 */
export interface StatusRule {
    /**
     * Type that the status rule applies to.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Name of the rule.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Description of the rule.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * AccessRule whether this rule acts as access control.
     *
     * @generated from protobuf field: bool access_rule = 4;
     */
    accessRule: boolean;
    /**
     * AppliesTo is a list of statuses that this rule applies to.
     *
     * @generated from protobuf field: repeated string applies_to = 5;
     */
    appliesTo: string[];
    /**
     * Expression that is evaluated for the rule.
     *
     * @generated from protobuf field: string expression = 7;
     */
    expression: string;
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleResponse
 */
export interface CreateStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export interface DeleteStatusRuleRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export interface DeleteStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentRequest
 */
export interface GetDocumentRequest {
    /**
     * UUID of the document to get.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version to get, omit to get latest (or use status).
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Status is used to fetch the version of the document references by the last
     * status update. Can be used instead of specifying a version.
     *
     * @generated from protobuf field: string status = 3;
     */
    status: string;
    /**
     * Lock will lock the document for updates. This only affects the creation of
     * new versions of the document, statuses can still be updated.
     *
     * @generated from protobuf field: bool lock = 4;
     */
    lock: boolean;
    /**
     * MetaDocument controls the inclusion of associated meta
     * documents. "META_INCLUDE" will include the document if it
     * exists. "META_ONLY" will only return the meta document, and will return a
     * not found error if it doesn't exist.
     *
     * @generated from protobuf field: elephant.repository.GetMetaDoc meta_document = 5;
     */
    metaDocument: GetMetaDoc;
    /**
     * MetaDocumentVersion is used to fetch a specific version of meta document.
     * Can not be used with status. If status is specified,
     * the version the meta document had at the time the status was set is returned.
     * If ommited and status is not used, the latest meta document version is returned.
     *
     * @generated from protobuf field: int64 meta_document_version = 6;
     */
    metaDocumentVersion: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentResponse
 */
export interface GetDocumentResponse {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Status is returned if the document was requested by status name.
     *
     * @generated from protobuf field: elephant.repository.Status status = 3;
     */
    status?: Status;
    /**
     * Meta contains the meta document, if requested, and if it exists.
     *
     * @generated from protobuf field: elephant.repository.MetaDocument meta = 4;
     */
    meta?: MetaDocument;
    /**
     * IsMetaDocument is true if the document is a meta document.
     *
     * @generated from protobuf field: bool is_meta_document = 5;
     */
    isMetaDocument: boolean;
    /**
     * MainDocument is the UUID of the main document if this is a meta document.
     *
     * @generated from protobuf field: string main_document = 6;
     */
    mainDocument: string;
}
/**
 * @generated from protobuf message elephant.repository.BulkGetRequest
 */
export interface BulkGetRequest {
    /**
     * Documents to get.
     *
     * @generated from protobuf field: repeated elephant.repository.BulkGetReference documents = 1;
     */
    documents: BulkGetReference[];
}
/**
 * @generated from protobuf message elephant.repository.BulkGetReference
 */
export interface BulkGetReference {
    /**
     * UUID of the document to get.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version to get, omit to get latest.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.BulkGetResponse
 */
export interface BulkGetResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.BulkGetItem items = 1;
     */
    items: BulkGetItem[];
}
/**
 * @generated from protobuf message elephant.repository.BulkGetItem
 */
export interface BulkGetItem {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.MetaDocument
 */
export interface MetaDocument {
    /**
     * Document is the requested document.
     *
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
    /**
     * Version is the version of the returned document.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryRequest
 */
export interface GetHistoryRequest {
    /**
     * UUID of the document to get the history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Before is which version number we should start fetching history from, omit
     * to start with the latest version.
     *
     * @generated from protobuf field: int64 before = 2;
     */
    before: bigint;
    /**
     * LoadStatuses loads any statuses set on the document versions.
     *
     * @generated from protobuf field: bool load_statuses = 3;
     */
    loadStatuses: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryResponse
 */
export interface GetHistoryResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.DocumentVersion versions = 1;
     */
    versions: DocumentVersion[];
}
/**
 * @generated from protobuf message elephant.repository.DocumentVersion
 */
export interface DocumentVersion {
    /**
     * Version of the document.
     *
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * Created timestamp is the RFC3339 timestamp for when the version was
     * created.
     *
     * @generated from protobuf field: string created = 2;
     */
    created: string;
    /**
     * Creator of the version.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Meta data to for the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 4;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * Statuses that have been set for the document version.
     *
     * @generated from protobuf field: map<string, elephant.repository.DocumentStatuses> statuses = 5;
     */
    statuses: {
        [key: string]: DocumentStatuses;
    };
}
/**
 * @generated from protobuf message elephant.repository.DocumentStatuses
 */
export interface DocumentStatuses {
    /**
     * @generated from protobuf field: repeated elephant.repository.Status items = 5;
     */
    items: Status[];
}
/**
 * UpdateRequest creates a new document version and/or sets statuses and ACLs
 * for a document. The update is transactional will fail or succed as a whole.
 *
 * If the document fails validation an "invalid_argument" error will be returned
 * with the number of errors as meta "err_count" and the individual errors as
 * "0", "1", "2"... Use the Validate method to get th errors as structured data.
 *
 * @generated from protobuf message elephant.repository.UpdateRequest
 */
export interface UpdateRequest {
    /**
     * UUID of the document to update.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Document version to create.
     *
     * @generated from protobuf field: newsdoc.Document document = 2;
     */
    document?: Document;
    /**
     * Meta data to associate with the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the update to be performed, or -1 to only perform
     * the update if the document doesn't already exist.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
    /**
     * Status updates to perform.
     *
     * @generated from protobuf field: repeated elephant.repository.StatusUpdate status = 5;
     */
    status: StatusUpdate[];
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 6;
     */
    acl: ACLEntry[];
    /**
     * ImportDirective can be used to preserve timestamps and authorship
     * information from originating systems, but requires the "import_directive"
     * scope for use.
     *
     * @generated from protobuf field: elephant.repository.ImportDirective import_directive = 7;
     */
    importDirective?: ImportDirective;
    /**
     * LockToken is used for explicit pessimistic locking.
     *
     * @generated from protobuf field: string lockToken = 8;
     */
    lockToken: string;
    /**
     * UpdateMetaDocument can be set to true to update the meta document instead
     * of the document identified by the UUID.
     *
     * @generated from protobuf field: bool update_meta_document = 9;
     */
    updateMetaDocument: boolean;
    /**
     * IfWorkflowState is used to only perform the update if it's in the specified
     * workflow state.
     *
     * @generated from protobuf field: string if_workflow_state = 10;
     */
    ifWorkflowState: string;
    /**
     * IfStatusHeads is used to only perform the update if the status heads match.
     *
     * @generated from protobuf field: map<string, int64> if_status_heads = 11;
     */
    ifStatusHeads: {
        [key: string]: bigint;
    };
    /**
     * AttachObjects is used to attach uploaded objects to a document. This must
     * be done in combination with a document create or update. The key is the
     * object name, f.ex. "image" or "audio", and the value is an upload ID. See
     * CreateUpload().
     *
     * @generated from protobuf field: map<string, string> attach_objects = 12;
     */
    attachObjects: {
        [key: string]: string;
    };
    /**
     * DetatchObjects is used to detach uploaded objects from a document. This
     * must be done in combination with a document create or update.
     *
     * @generated from protobuf field: repeated string detach_objects = 13;
     */
    detachObjects: string[];
}
/**
 * ImportDirective can be used to preserve timestamps and authorship information
 * from originating systems.
 *
 * @generated from protobuf message elephant.repository.ImportDirective
 */
export interface ImportDirective {
    /**
     * @generated from protobuf field: string originally_created = 1;
     */
    originallyCreated: string;
    /**
     * @generated from protobuf field: string original_creator = 2;
     */
    originalCreator: string;
}
/**
 * UpdateResponse describes the result of an update request.
 *
 * @generated from protobuf message elephant.repository.UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.BulkUpdateRequest
 */
export interface BulkUpdateRequest {
    /**
     * @generated from protobuf field: repeated elephant.repository.UpdateRequest updates = 1;
     */
    updates: UpdateRequest[];
}
/**
 * @generated from protobuf message elephant.repository.BulkUpdateResponse
 */
export interface BulkUpdateResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.UpdateResponse updates = 1;
     */
    updates: UpdateResponse[];
}
/**
 * @generated from protobuf message elephant.repository.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: newsdoc.Document document = 1;
     */
    document?: Document;
}
/**
 * @generated from protobuf message elephant.repository.ValidateResponse
 */
export interface ValidateResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.ValidationResult errors = 1;
     */
    errors: ValidationResult[];
}
/**
 * @generated from protobuf message elephant.repository.ValidationResult
 */
export interface ValidationResult {
    /**
     * @generated from protobuf field: repeated elephant.repository.EntityRef entity = 1;
     */
    entity: EntityRef[];
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message elephant.repository.EntityRef
 */
export interface EntityRef {
    /**
     * RefType is type of entity that's referenced, one of "block", "property",
     * "attribute", "data attribute", or "parameter."
     *
     * @generated from protobuf field: string ref_type = 1;
     */
    refType: string;
    /**
     * Kind is the block type, one of "link", "meta", or "content".
     *
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * Index is the position of the entity in an array, where applicable.
     *
     * @generated from protobuf field: int64 index = 3;
     */
    index: bigint;
    /**
     * Name is the name of the entity, where applicable.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * Type is the type of the entity, where applicable.
     *
     * @generated from protobuf field: string type = 5;
     */
    type: string;
    /**
     * Rel is the relationship for the entity, where applicable.
     *
     * @generated from protobuf field: string rel = 6;
     */
    rel: string;
}
/**
 * @generated from protobuf message elephant.repository.StatusUpdate
 */
export interface StatusUpdate {
    /**
     * Name of the status to set.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version to set the status for. Set to -1 to signal that the status no
     * longer is valid for the document. Optional if part of a document update
     * request as it then will default to the version being written.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Meta data to include with the status update.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the status id that you require
     * to be the current one for the status to be set, or -1 to only perform the
     * update if the status hasn't previously been set.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsRequest
 */
export interface UpdatePermissionsRequest {
    /**
     * UUID of the document to update permissions for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Set (upsert based on URI) this list of ACL entries.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry list = 2;
     */
    list: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsResponse
 */
export interface UpdatePermissionsResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentRequest
 */
export interface DeleteDocumentRequest {
    /**
     * UUID of the document to delete.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Meta data to include with the delete record.
     *
     * @generated from protobuf field: map<string, string> meta = 2;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the delete to be performed.
     *
     * @generated from protobuf field: int64 if_match = 3;
     */
    ifMatch: bigint;
    /**
     * LockToken is used for explicit pessimistic locking.
     *
     * @generated from protobuf field: string lockToken = 8;
     */
    lockToken: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentResponse
 */
export interface DeleteDocumentResponse {
}
/**
 * @generated from protobuf message elephant.repository.RestoreRequest
 */
export interface RestoreRequest {
    /**
     * UUID of the document to restore.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * DeleteRecordID for the specific instance of the document that was deleted.
     *
     * @generated from protobuf field: int64 delete_record_id = 2;
     */
    deleteRecordId: bigint;
    /**
     * ACL that should be set for the restored document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 3;
     */
    acl: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.RestoreResponse
 */
export interface RestoreResponse {
}
/**
 * @generated from protobuf message elephant.repository.PurgeRequest
 */
export interface PurgeRequest {
    /**
     * UUID of the document to purge.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * DeleteRecordID for the specific instance of the document that should be
     * purged.
     *
     * @generated from protobuf field: int64 delete_record_id = 2;
     */
    deleteRecordId: bigint;
}
/**
 * @generated from protobuf message elephant.repository.PurgeResponse
 */
export interface PurgeResponse {
}
/**
 * @generated from protobuf message elephant.repository.ListDeletedRequest
 */
export interface ListDeletedRequest {
    /**
     * UUID of the document list deletions of. Optional.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * BeforeID is used to paginate backwards in deletions. Optional.
     *
     * @generated from protobuf field: int64 before_id = 2;
     */
    beforeId: bigint;
    /**
     * BeforeDate is used to get deletions going back from before the specified
     * date YYYY-MM-DD. Optional, will be ignored if before_id is specified.
     *
     * @generated from protobuf field: string before_date = 3;
     */
    beforeDate: string;
    /**
     * Timezone that the date should be interpreted in.
     *
     * @generated from protobuf field: string timezone = 4;
     */
    timezone: string;
}
/**
 * @generated from protobuf message elephant.repository.ListDeletedResponse
 */
export interface ListDeletedResponse {
    /**
     * Deletes that have been performed on document instances with the given UUID.
     *
     * @generated from protobuf field: repeated elephant.repository.DeleteRecord deletes = 1;
     */
    deletes: DeleteRecord[];
}
/**
 * @generated from protobuf message elephant.repository.DeleteRecord
 */
export interface DeleteRecord {
    /**
     * ID of the delete record.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * UUID of the document.
     *
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
    /**
     * URI of the document.
     *
     * @generated from protobuf field: string uri = 3;
     */
    uri: string;
    /**
     * Type of the document.
     *
     * @generated from protobuf field: string type = 4;
     */
    type: string;
    /**
     * Version that the document had at the time of restore.
     *
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
    /**
     * Creation time for the delete record, as an RFC3339 timestamp.
     *
     * @generated from protobuf field: string created = 6;
     */
    created: string;
    /**
     * Creator of the delete record.
     *
     * @generated from protobuf field: string creator = 7;
     */
    creator: string;
    /**
     * Meta data included with the delete record.
     *
     * @generated from protobuf field: map<string, string> meta = 8;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * Language that the document was in.
     *
     * @generated from protobuf field: string language = 9;
     */
    language: string;
    /**
     * Finalised is the time, as an RFC3339 timestamp, that the document finished
     * deleting. Empty if the delete is in progress.
     *
     * @generated from protobuf field: string finalised = 10;
     */
    finalised: string;
    /**
     * Purged is the time, as an RFC3339 timestamp, all archived data for the
     * document was purged. Empty if the document hasn't been purged.
     *
     * @generated from protobuf field: string purged = 11;
     */
    purged: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetaRequest
 */
export interface GetMetaRequest {
    /**
     * UUID of the document to get metadata for
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetaResponse
 */
export interface GetMetaResponse {
    /**
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 1;
     */
    meta?: DocumentMeta;
}
/**
 * @generated from protobuf message elephant.repository.DocumentMeta
 */
export interface DocumentMeta {
    /**
     * Created timestamp is the RFC3339 timestamp for when the document was
     * created.
     *
     * @generated from protobuf field: string created = 1;
     */
    created: string;
    /**
     * Modified timestamp is the RFC3339 timestamp for the last change that
     * affected the document.
     *
     * @generated from protobuf field: string modified = 2;
     */
    modified: string;
    /**
     * CurrentVersion is the last written version of the document.
     *
     * @generated from protobuf field: int64 current_version = 3;
     */
    currentVersion: bigint;
    /**
     * Heads are the last statuses.
     *
     * @generated from protobuf field: map<string, elephant.repository.Status> heads = 4;
     */
    heads: {
        [key: string]: Status;
    };
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 5;
     */
    acl: ACLEntry[];
    /**
     * Document lock, if any
     *
     * @generated from protobuf field: elephant.repository.Lock lock = 6;
     */
    lock?: Lock;
    /**
     * IsMetaDocument is true if the document is a meta document.
     *
     * @generated from protobuf field: bool is_meta_document = 7;
     */
    isMetaDocument: boolean;
    /**
     * MainDocument is the UUID of the main document if this is a meta document.
     *
     * @generated from protobuf field: string main_document = 8;
     */
    mainDocument: string;
    /**
     * WorkflowState that the document is in.
     *
     * @generated from protobuf field: string workflow_state = 9;
     */
    workflowState: string;
    /**
     * WorkflowCheckpoint that the document reached most recently.
     *
     * @generated from protobuf field: string workflow_checkpoint = 10;
     */
    workflowCheckpoint: string;
    /**
     * CreatorURI is the identity of the party that created the document.
     *
     * @generated from protobuf field: string creator_uri = 11;
     */
    creatorUri: string;
    /**
     * UpdaterURI is the identity of the party that last updated the document.
     *
     * @generated from protobuf field: string updater_uri = 12;
     */
    updaterUri: string;
    /**
     * Attachments are the names of the attached objects (files) for a document.
     *
     * @generated from protobuf field: repeated elephant.repository.AttachmentRef attachments = 13;
     */
    attachments: AttachmentRef[];
    /**
     * Nonce is the unique nonce for this document. If the document is deleted and
     * recreated with the same ID it will still have a unique nonce.
     *
     * @generated from protobuf field: string nonce = 14;
     */
    nonce: string;
}
/**
 * @generated from protobuf message elephant.repository.AttachmentRef
 */
export interface AttachmentRef {
    /**
     * Name of the attachment.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version is the current version of the attachment.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.Status
 */
export interface Status {
    /**
     * ID of the status.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Version of the document that the status refers to.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Creator of the status.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Created timestamp is the RFC3339 timestamp for when the status was created.
     *
     * @generated from protobuf field: string created = 4;
     */
    created: string;
    /**
     * Meta data for the status.
     *
     * @generated from protobuf field: map<string, string> meta = 5;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * MetaDocumentVersion is the version the meta document had at the time the
     * status was set.
     *
     * @generated from protobuf field: int64 meta_doc_version = 6;
     */
    metaDocVersion: bigint;
}
/**
 * @generated from protobuf message elephant.repository.ACLEntry
 */
export interface ACLEntry {
    /**
     * URI that identifies the party that's granted access.
     *
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * Permissions given to the grantee.
     *
     * @generated from protobuf field: repeated string permissions = 2;
     */
    permissions: string[];
}
/**
 * @generated from protobuf message elephant.repository.Lock
 */
export interface Lock {
    /**
     * Lock token string
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * URI of the lock owner
     *
     * @generated from protobuf field: string uri = 2;
     */
    uri: string;
    /**
     * Created timestamp is the RFC3339 timestamp for when the lock was created.
     *
     * @generated from protobuf field: string created = 3;
     */
    created: string;
    /**
     * Expires timestamp is the RFC3339 timestamp for when the lock will expire.
     *
     * @generated from protobuf field: string expires = 4;
     */
    expires: string;
    /**
     * URI identifying the locking application.
     *
     * @generated from protobuf field: string app = 5;
     */
    app: string;
    /**
     * Optional free-form comment.
     *
     * @generated from protobuf field: string comment = 6;
     */
    comment: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeRequest
 */
export interface RegisterMetaTypeRequest {
    /**
     * Type to use as a meta type.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Exclusive - set to true to only allow the type to be used as a meta type.
     *
     * @generated from protobuf field: bool exclusive = 2;
     */
    exclusive: boolean;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeResponse
 */
export interface RegisterMetaTypeResponse {
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeUseRequest
 */
export interface RegisterMetaTypeUseRequest {
    /**
     * MainType to use the meta type for.
     *
     * @generated from protobuf field: string main_type = 1;
     */
    mainType: string;
    /**
     * MetaType to use for the main document.
     *
     * @generated from protobuf field: string meta_type = 2;
     */
    metaType: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetaTypeUseResponse
 */
export interface RegisterMetaTypeUseResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetaTypesRequest
 */
export interface GetMetaTypesRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetMetaTypesResponse
 */
export interface GetMetaTypesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.MetaTypeInfo types = 1;
     */
    types: MetaTypeInfo[];
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentTypesRequest
 */
export interface GetDocumentTypesRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentTypesResponse
 */
export interface GetDocumentTypesResponse {
    /**
     * Types that have been defined in the schema.
     *
     * @generated from protobuf field: repeated string types = 1;
     */
    types: string[];
}
/**
 * @generated from protobuf message elephant.repository.MetaTypeInfo
 */
export interface MetaTypeInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated string used_by = 2;
     */
    usedBy: string[];
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaRequest
 */
export interface RegisterSchemaRequest {
    /**
     * Schema to register. The spec can be omitted if a schema URL is passed.
     *
     * @generated from protobuf field: elephant.repository.Schema schema = 1;
     */
    schema?: Schema;
    /**
     * Activate the registered schema immediately.
     *
     * @generated from protobuf field: bool activate = 2;
     */
    activate: boolean;
    /**
     * SchemaURL is an HTTP(S) url to the schema to load, can be passed instead of
     * an inline schema spec.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
    /**
     * SchemaSHA256 is a SHA256 checksum to validate the response body from the
     * schema URL against.
     *
     * @generated from protobuf field: string schema_sha256 = 4;
     */
    schemaSha256: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaResponse
 */
export interface RegisterSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaRequest
 */
export interface SetActiveSchemaRequest {
    /**
     * Name is the name of the schema to activate or deactivate, required.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to activate, required when activating a new version.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * Deactivate is used to disable a schema, activate new schema versions
     * instead if you want to start using a new version.
     *
     * @generated from protobuf field: bool deactivate = 3;
     */
    deactivate: boolean;
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaResponse
 */
export interface SetActiveSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * Name of the schema to get.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to get, optional. The currently active version of the
     * schema will be returned if no version is specified.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: bytes spec = 2;
     */
    spec: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export interface GetAllActiveSchemasRequest {
    /**
     * WaitSeconds is the maximum number of seconds to wait for changes, defaults
     * to 10 seconds. Optional.
     *
     * @generated from protobuf field: int64 wait_seconds = 1;
     */
    waitSeconds: bigint;
    /**
     * Known schema versions that the client already has. Optional.
     *
     * @generated from protobuf field: map<string, string> known = 2;
     */
    known: {
        [key: string]: string;
    };
    /**
     * OnlyChanged only returns the schemas that have been changed.
     *
     * @generated from protobuf field: bool only_changed = 3;
     */
    onlyChanged: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export interface GetAllActiveSchemasResponse {
    /**
     * Schemas that currently are active.
     *
     * @generated from protobuf field: repeated elephant.repository.Schema schemas = 1;
     */
    schemas: Schema[];
    /**
     * Unchanged is set to true if no changes were done compared to known schema
     * versions.
     *
     * @generated from protobuf field: bool unchanged = 2;
     */
    unchanged: boolean;
    /**
     * Removed schemas.
     *
     * @generated from protobuf field: repeated string removed = 3;
     */
    removed: string[];
}
/**
 * @generated from protobuf message elephant.repository.ListActiveSchemasRequest
 */
export interface ListActiveSchemasRequest {
}
/**
 * @generated from protobuf message elephant.repository.ListActiveSchemasResponse
 */
export interface ListActiveSchemasResponse {
    /**
     * Schemas without the spec populated
     *
     * @generated from protobuf field: repeated elephant.repository.Schema schemas = 1;
     */
    schemas: Schema[];
}
/**
 * @generated from protobuf message elephant.repository.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: string spec = 3;
     */
    spec: string;
}
/**
 * @generated from protobuf message elephant.repository.GetDeprecationsRequest
 */
export interface GetDeprecationsRequest {
}
/**
 * @generated from protobuf message elephant.repository.Deprecation
 */
export interface Deprecation {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: bool enforced = 2;
     */
    enforced: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetDeprecationsResponse
 */
export interface GetDeprecationsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Deprecation deprecations = 1;
     */
    deprecations: Deprecation[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateDeprecationRequest
 */
export interface UpdateDeprecationRequest {
    /**
     * @generated from protobuf field: elephant.repository.Deprecation deprecation = 1;
     */
    deprecation?: Deprecation;
}
/**
 * @generated from protobuf message elephant.repository.UpdateDeprecationResponse
 */
export interface UpdateDeprecationResponse {
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindRequest
 */
export interface RegisterMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindResponse
 */
export interface RegisterMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindRequest
 */
export interface DeleteMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindResponse
 */
export interface DeleteMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsRequest
 */
export interface GetMetricKindsRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsResponse
 */
export interface GetMetricKindsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.MetricKind kinds = 1;
     */
    kinds: MetricKind[];
}
/**
 * @generated from protobuf message elephant.repository.MetricKind
 */
export interface MetricKind {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricRequest
 */
export interface RegisterMetricRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
    /**
     * @generated from protobuf field: int64 value = 5;
     */
    value: bigint;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricResponse
 */
export interface RegisterMetricResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * The documents to get metrics for.
     *
     * @generated from protobuf field: repeated string uuids = 1;
     */
    uuids: string[];
    /**
     * The metric kinds to get. Optional, defaults to all.
     *
     * @generated from protobuf field: repeated string kinds = 2;
     */
    kinds: string[];
}
/**
 * @generated from protobuf message elephant.repository.GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * @generated from protobuf field: map<string, elephant.repository.DocumentMetrics> documents = 1;
     */
    documents: {
        [key: string]: DocumentMetrics;
    };
}
/**
 * @generated from protobuf message elephant.repository.DocumentMetrics
 */
export interface DocumentMetrics {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: repeated elephant.repository.Metric metrics = 2;
     */
    metrics: Metric[];
}
/**
 * @generated from protobuf message elephant.repository.Metric
 */
export interface Metric {
    /**
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: int64 value = 3;
     */
    value: bigint;
}
/**
 * @generated from protobuf message elephant.repository.LockRequest
 */
export interface LockRequest {
    /**
     * UUID of the document to lock
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock TTL in milliseconds
     *
     * @generated from protobuf field: int32 ttl = 2;
     */
    ttl: number;
    /**
     * Name of the locking application. Optional.
     *
     * @generated from protobuf field: string app = 3;
     */
    app: string;
    /**
     * Free-form comment string. Optional.
     *
     * @generated from protobuf field: string comment = 4;
     */
    comment: string;
}
/**
 * @generated from protobuf message elephant.repository.LockResponse
 */
export interface LockResponse {
    /**
     * Generated lock token in UUID format.
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * Expires is the RFC3339 timestamp when the lock will expire.
     *
     * @generated from protobuf field: string expires = 2;
     */
    expires: string;
}
/**
 * @generated from protobuf message elephant.repository.ExtendLockRequest
 */
export interface ExtendLockRequest {
    /**
     * UUID of the document to extend the lock for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock TTL in milliseconds.
     *
     * @generated from protobuf field: int32 ttl = 2;
     */
    ttl: number;
    /**
     * Lock token in UUID format.
     *
     * @generated from protobuf field: string token = 3;
     */
    token: string;
}
/**
 * @generated from protobuf message elephant.repository.UnlockRequest
 */
export interface UnlockRequest {
    /**
     * UUID of the document to unlock
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Lock token in UUID format.
     *
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * @generated from protobuf message elephant.repository.UnlockResponse
 */
export interface UnlockResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetWithheldRequest
 */
export interface GetWithheldRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetWithheldResponse
 */
export interface GetWithheldResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.ScheduledDocument items = 1;
     */
    items: ScheduledDocument[];
}
/**
 * @generated from protobuf message elephant.repository.ScheduledDocument
 */
export interface ScheduledDocument {
    /**
     * UUID is the ID of the scheduled document.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Type of the scheduled document.
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * StatusID is the last withheld status ID.
     *
     * @generated from protobuf field: int64 status_id = 3;
     */
    statusId: bigint;
    /**
     * DocumentVersion is the last version that was set as withheld.
     *
     * @generated from protobuf field: int64 document_version = 4;
     */
    documentVersion: bigint;
    /**
     * PlanningItem UUID.
     *
     * @generated from protobuf field: string planning_item = 5;
     */
    planningItem: string;
    /**
     * Assignment ID.
     *
     * @generated from protobuf field: string assignment = 6;
     */
    assignment: string;
    /**
     * Publish timestamp as RFC3339 set in the assignment.
     *
     * @generated from protobuf field: string publish = 7;
     */
    publish: string;
    /**
     * ScheduledBy is the sub of the user that set the withheld status.
     *
     * @generated from protobuf field: string scheduled_by = 8;
     */
    scheduledBy: string;
}
/**
 * @generated from protobuf message elephant.repository.GetDeliverableInfoRequest
 */
export interface GetDeliverableInfoRequest {
    /**
     * UUID of the deliverable.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetDeliverableInfoResponse
 */
export interface GetDeliverableInfoResponse {
    /**
     * Indicates whether the deliverable has planning information.
     *
     * @generated from protobuf field: bool has_planning_info = 1;
     */
    hasPlanningInfo: boolean;
    /**
     * UUID of the related planning item.
     *
     * @generated from protobuf field: string planning_uuid = 2;
     */
    planningUuid: string;
    /**
     * UUID of the related assignment.
     *
     * @generated from protobuf field: string assignment_uuid = 3;
     */
    assignmentUuid: string;
    /**
     * UUID of the related event.
     *
     * @generated from protobuf field: string event_uuid = 4;
     */
    eventUuid: string;
}
/**
 * @generated from protobuf message elephant.repository.CreateUploadRequest
 */
export interface CreateUploadRequest {
    /**
     * Name of the uploaded file, this should be the basename of the file.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * ContentType is the type of the file as a mimetype.
     *
     * @generated from protobuf field: string content_type = 2;
     */
    contentType: string;
    /**
     * Meta can be used to set arbitrary key-value data on an upload.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.CreateUploadResponse
 */
export interface CreateUploadResponse {
    /**
     * ID of the created upload.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * URL to PUT the object content to.
     *
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * @generated from protobuf message elephant.repository.GetAttachmentsRequest
 */
export interface GetAttachmentsRequest {
    /**
     * Documents to get attachments for.
     *
     * @generated from protobuf field: repeated string documents = 1;
     */
    documents: string[];
    /**
     * Attachment name to get information for.
     *
     * @generated from protobuf field: string attachment_name = 2;
     */
    attachmentName: string;
    /**
     * DownloadLink should be set to true to generate a download link.
     *
     * @generated from protobuf field: bool download_link = 3;
     */
    downloadLink: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetAttachmentsResponse
 */
export interface GetAttachmentsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.AttachmentDetails attachments = 1;
     */
    attachments: AttachmentDetails[];
}
/**
 * @generated from protobuf message elephant.repository.AttachmentDetails
 */
export interface AttachmentDetails {
    /**
     * Document is the UUID of the document the object is attached to.
     *
     * @generated from protobuf field: string document = 1;
     */
    document: string;
    /**
     * Name of the attachment.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Version of the attachment.
     *
     * @generated from protobuf field: int64 version = 3;
     */
    version: bigint;
    /**
     * DownloadLink that can be used to fetch the object contents, if requested.
     *
     * @generated from protobuf field: string download_link = 4;
     */
    downloadLink: string;
    /**
     * Filename is the name of the file the object represents.
     *
     * @generated from protobuf field: string filename = 5;
     */
    filename: string;
    /**
     * ContentType is the MIME type of the object.
     *
     * @generated from protobuf field: string content_type = 6;
     */
    contentType: string;
}
/**
 * @generated from protobuf enum elephant.repository.GetMetaDoc
 */
export enum GetMetaDoc {
    /**
     * @generated from protobuf enum value: META_NONE = 0;
     */
    META_NONE = 0,
    /**
     * @generated from protobuf enum value: META_INCLUDE = 1;
     */
    META_INCLUDE = 1,
    /**
     * @generated from protobuf enum value: META_ONLY = 2;
     */
    META_ONLY = 2
}
/**
 * @generated from protobuf enum elephant.repository.MetricAggregation
 */
export enum MetricAggregation {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: REPLACE = 1;
     */
    REPLACE = 1,
    /**
     * @generated from protobuf enum value: INCREMENT = 2;
     */
    INCREMENT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("elephant.repository.GetStatusRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 id */ 3:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 id = 3; */
        if (message.id !== 0n)
            writer.tag(3, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse$Type extends MessageType<GetStatusResponse> {
    constructor() {
        super("elephant.repository.GetStatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse>): GetStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse): GetStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusResponse
 */
export const GetStatusResponse = new GetStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryRequest$Type extends MessageType<GetStatusHistoryRequest> {
    constructor() {
        super("elephant.repository.GetStatusHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryRequest>): GetStatusHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        message.before = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryRequest): GetStatusHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 before */ 3:
                    message.before = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 before = 3; */
        if (message.before !== 0n)
            writer.tag(3, WireType.Varint).int64(message.before);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryRequest
 */
export const GetStatusHistoryRequest = new GetStatusHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryReponse$Type extends MessageType<GetStatusHistoryReponse> {
    constructor() {
        super("elephant.repository.GetStatusHistoryReponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryReponse>): GetStatusHistoryReponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryReponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryReponse): GetStatusHistoryReponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Status statuses */ 1:
                    message.statuses.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryReponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Status statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            Status.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryReponse
 */
export const GetStatusHistoryReponse = new GetStatusHistoryReponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNilStatusesRequest$Type extends MessageType<GetNilStatusesRequest> {
    constructor() {
        super("elephant.repository.GetNilStatusesRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetNilStatusesRequest>): GetNilStatusesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<GetNilStatusesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNilStatusesRequest): GetNilStatusesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated string names */ 2:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNilStatusesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated string names = 2; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetNilStatusesRequest
 */
export const GetNilStatusesRequest = new GetNilStatusesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNilStatusesResponse$Type extends MessageType<GetNilStatusesResponse> {
    constructor() {
        super("elephant.repository.GetNilStatusesResponse", [
            { no: 1, name: "statuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DocumentStatuses } }
        ]);
    }
    create(value?: PartialMessage<GetNilStatusesResponse>): GetNilStatusesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = {};
        if (value !== undefined)
            reflectionMergePartial<GetNilStatusesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNilStatusesResponse): GetNilStatusesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, elephant.repository.DocumentStatuses> statuses */ 1:
                    this.binaryReadMap1(message.statuses, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetNilStatusesResponse["statuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetNilStatusesResponse["statuses"] | undefined, val: GetNilStatusesResponse["statuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DocumentStatuses.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetNilStatusesResponse.statuses");
            }
        }
        map[key ?? ""] = val ?? DocumentStatuses.create();
    }
    internalBinaryWrite(message: GetNilStatusesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, elephant.repository.DocumentStatuses> statuses = 1; */
        for (let k of globalThis.Object.keys(message.statuses)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DocumentStatuses.internalBinaryWrite(message.statuses[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetNilStatusesResponse
 */
export const GetNilStatusesResponse = new GetNilStatusesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusOverviewRequest$Type extends MessageType<GetStatusOverviewRequest> {
    constructor() {
        super("elephant.repository.GetStatusOverviewRequest", [
            { no: 1, name: "uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "statuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "get_meta", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusOverviewRequest>): GetStatusOverviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuids = [];
        message.statuses = [];
        message.getMeta = false;
        if (value !== undefined)
            reflectionMergePartial<GetStatusOverviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusOverviewRequest): GetStatusOverviewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string uuids */ 1:
                    message.uuids.push(reader.string());
                    break;
                case /* repeated string statuses */ 2:
                    message.statuses.push(reader.string());
                    break;
                case /* bool get_meta */ 3:
                    message.getMeta = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusOverviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.uuids[i]);
        /* repeated string statuses = 2; */
        for (let i = 0; i < message.statuses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.statuses[i]);
        /* bool get_meta = 3; */
        if (message.getMeta !== false)
            writer.tag(3, WireType.Varint).bool(message.getMeta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusOverviewRequest
 */
export const GetStatusOverviewRequest = new GetStatusOverviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusOverviewResponse$Type extends MessageType<GetStatusOverviewResponse> {
    constructor() {
        super("elephant.repository.GetStatusOverviewResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusOverviewItem }
        ]);
    }
    create(value?: PartialMessage<GetStatusOverviewResponse>): GetStatusOverviewResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusOverviewResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusOverviewResponse): GetStatusOverviewResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.StatusOverviewItem items */ 1:
                    message.items.push(StatusOverviewItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusOverviewResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.StatusOverviewItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            StatusOverviewItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusOverviewResponse
 */
export const GetStatusOverviewResponse = new GetStatusOverviewResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusOverviewItem$Type extends MessageType<StatusOverviewItem> {
    constructor() {
        super("elephant.repository.StatusOverviewItem", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "modified", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } },
            { no: 5, name: "workflow_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "workflow_checkpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "creator_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusOverviewItem>): StatusOverviewItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        message.modified = "";
        message.heads = {};
        message.workflowState = "";
        message.workflowCheckpoint = "";
        message.creatorUri = "";
        message.updaterUri = "";
        if (value !== undefined)
            reflectionMergePartial<StatusOverviewItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusOverviewItem): StatusOverviewItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string modified */ 3:
                    message.modified = reader.string();
                    break;
                case /* map<string, elephant.repository.Status> heads */ 4:
                    this.binaryReadMap4(message.heads, reader, options);
                    break;
                case /* string workflow_state */ 5:
                    message.workflowState = reader.string();
                    break;
                case /* string workflow_checkpoint */ 6:
                    message.workflowCheckpoint = reader.string();
                    break;
                case /* string creator_uri */ 7:
                    message.creatorUri = reader.string();
                    break;
                case /* string updater_uri */ 8:
                    message.updaterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: StatusOverviewItem["heads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatusOverviewItem["heads"] | undefined, val: StatusOverviewItem["heads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.StatusOverviewItem.heads");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    internalBinaryWrite(message: StatusOverviewItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string modified = 3; */
        if (message.modified !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.modified);
        /* map<string, elephant.repository.Status> heads = 4; */
        for (let k of globalThis.Object.keys(message.heads)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.heads[k], writer, options);
            writer.join().join();
        }
        /* string workflow_state = 5; */
        if (message.workflowState !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.workflowState);
        /* string workflow_checkpoint = 6; */
        if (message.workflowCheckpoint !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.workflowCheckpoint);
        /* string creator_uri = 7; */
        if (message.creatorUri !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.creatorUri);
        /* string updater_uri = 8; */
        if (message.updaterUri !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updaterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusOverviewItem
 */
export const StatusOverviewItem = new StatusOverviewItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsRequest$Type extends MessageType<GetPermissionsRequest> {
    constructor() {
        super("elephant.repository.GetPermissionsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsRequest>): GetPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsRequest): GetPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetPermissionsRequest
 */
export const GetPermissionsRequest = new GetPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsResponse$Type extends MessageType<GetPermissionsResponse> {
    constructor() {
        super("elephant.repository.GetPermissionsResponse", [
            { no: 1, name: "permissions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsResponse>): GetPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = {};
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsResponse): GetPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> permissions */ 1:
                    this.binaryReadMap1(message.permissions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetPermissionsResponse["permissions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetPermissionsResponse["permissions"] | undefined, val: GetPermissionsResponse["permissions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetPermissionsResponse.permissions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> permissions = 1; */
        for (let k of globalThis.Object.keys(message.permissions))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.permissions[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetPermissionsResponse
 */
export const GetPermissionsResponse = new GetPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogRequest$Type extends MessageType<GetEventlogRequest> {
    constructor() {
        super("elephant.repository.GetEventlogRequest", [
            { no: 1, name: "after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "wait_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "batch_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "batch_wait_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEventlogRequest>): GetEventlogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.after = 0n;
        message.waitMs = 0;
        message.batchSize = 0;
        message.batchWaitMs = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEventlogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogRequest): GetEventlogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 after */ 1:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* int32 wait_ms */ 2:
                    message.waitMs = reader.int32();
                    break;
                case /* int32 batch_size */ 3:
                    message.batchSize = reader.int32();
                    break;
                case /* int32 batch_wait_ms */ 4:
                    message.batchWaitMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 after = 1; */
        if (message.after !== 0n)
            writer.tag(1, WireType.Varint).int64(message.after);
        /* int32 wait_ms = 2; */
        if (message.waitMs !== 0)
            writer.tag(2, WireType.Varint).int32(message.waitMs);
        /* int32 batch_size = 3; */
        if (message.batchSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.batchSize);
        /* int32 batch_wait_ms = 4; */
        if (message.batchWaitMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.batchWaitMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogRequest
 */
export const GetEventlogRequest = new GetEventlogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogResponse$Type extends MessageType<GetEventlogResponse> {
    constructor() {
        super("elephant.repository.GetEventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<GetEventlogResponse>): GetEventlogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetEventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogResponse): GetEventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogResponse
 */
export const GetEventlogResponse = new GetEventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCompactedEventlogRequest$Type extends MessageType<GetCompactedEventlogRequest> {
    constructor() {
        super("elephant.repository.GetCompactedEventlogRequest", [
            { no: 1, name: "after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "until", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCompactedEventlogRequest>): GetCompactedEventlogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.after = 0n;
        message.until = 0n;
        message.limit = 0;
        message.offset = 0;
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<GetCompactedEventlogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCompactedEventlogRequest): GetCompactedEventlogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 after */ 1:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* int64 until */ 3:
                    message.until = reader.int64().toBigInt();
                    break;
                case /* int32 limit */ 4:
                    message.limit = reader.int32();
                    break;
                case /* int32 offset */ 5:
                    message.offset = reader.int32();
                    break;
                case /* string type */ 6:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCompactedEventlogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 after = 1; */
        if (message.after !== 0n)
            writer.tag(1, WireType.Varint).int64(message.after);
        /* int64 until = 3; */
        if (message.until !== 0n)
            writer.tag(3, WireType.Varint).int64(message.until);
        /* int32 limit = 4; */
        if (message.limit !== 0)
            writer.tag(4, WireType.Varint).int32(message.limit);
        /* int32 offset = 5; */
        if (message.offset !== 0)
            writer.tag(5, WireType.Varint).int32(message.offset);
        /* string type = 6; */
        if (message.type !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetCompactedEventlogRequest
 */
export const GetCompactedEventlogRequest = new GetCompactedEventlogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCompactedEventlogResponse$Type extends MessageType<GetCompactedEventlogResponse> {
    constructor() {
        super("elephant.repository.GetCompactedEventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<GetCompactedEventlogResponse>): GetCompactedEventlogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetCompactedEventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCompactedEventlogResponse): GetCompactedEventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCompactedEventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetCompactedEventlogResponse
 */
export const GetCompactedEventlogResponse = new GetCompactedEventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventlogItem$Type extends MessageType<EventlogItem> {
    constructor() {
        super("elephant.repository.EventlogItem", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "status_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 9, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "old_language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "system_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "workflow_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "workflow_checkpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "main_document_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "attached_objects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "detached_objects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "delete_record_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "document_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventlogItem>): EventlogItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.event = "";
        message.uuid = "";
        message.timestamp = "";
        message.version = 0n;
        message.status = "";
        message.statusId = 0n;
        message.acl = [];
        message.updaterUri = "";
        message.type = "";
        message.language = "";
        message.oldLanguage = "";
        message.mainDocument = "";
        message.systemState = "";
        message.workflowState = "";
        message.workflowCheckpoint = "";
        message.mainDocumentType = "";
        message.attachedObjects = [];
        message.detachedObjects = [];
        message.deleteRecordId = 0n;
        message.documentNonce = "";
        if (value !== undefined)
            reflectionMergePartial<EventlogItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventlogItem): EventlogItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string event */ 2:
                    message.event = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* string timestamp */ 4:
                    message.timestamp = reader.string();
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* int64 status_id */ 7:
                    message.statusId = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 8:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updater_uri */ 9:
                    message.updaterUri = reader.string();
                    break;
                case /* string type */ 10:
                    message.type = reader.string();
                    break;
                case /* string language */ 11:
                    message.language = reader.string();
                    break;
                case /* string old_language */ 12:
                    message.oldLanguage = reader.string();
                    break;
                case /* string main_document */ 13:
                    message.mainDocument = reader.string();
                    break;
                case /* string system_state */ 14:
                    message.systemState = reader.string();
                    break;
                case /* string workflow_state */ 15:
                    message.workflowState = reader.string();
                    break;
                case /* string workflow_checkpoint */ 16:
                    message.workflowCheckpoint = reader.string();
                    break;
                case /* string main_document_type */ 17:
                    message.mainDocumentType = reader.string();
                    break;
                case /* repeated string attached_objects */ 18:
                    message.attachedObjects.push(reader.string());
                    break;
                case /* repeated string detached_objects */ 19:
                    message.detachedObjects.push(reader.string());
                    break;
                case /* int64 delete_record_id */ 20:
                    message.deleteRecordId = reader.int64().toBigInt();
                    break;
                case /* string document_nonce */ 21:
                    message.documentNonce = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventlogItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string event = 2; */
        if (message.event !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.event);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* string timestamp = 4; */
        if (message.timestamp !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.timestamp);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* int64 status_id = 7; */
        if (message.statusId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.statusId);
        /* repeated elephant.repository.ACLEntry acl = 8; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string updater_uri = 9; */
        if (message.updaterUri !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updaterUri);
        /* string type = 10; */
        if (message.type !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.type);
        /* string language = 11; */
        if (message.language !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.language);
        /* string old_language = 12; */
        if (message.oldLanguage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.oldLanguage);
        /* string main_document = 13; */
        if (message.mainDocument !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.mainDocument);
        /* string system_state = 14; */
        if (message.systemState !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.systemState);
        /* string workflow_state = 15; */
        if (message.workflowState !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.workflowState);
        /* string workflow_checkpoint = 16; */
        if (message.workflowCheckpoint !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.workflowCheckpoint);
        /* string main_document_type = 17; */
        if (message.mainDocumentType !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.mainDocumentType);
        /* repeated string attached_objects = 18; */
        for (let i = 0; i < message.attachedObjects.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.attachedObjects[i]);
        /* repeated string detached_objects = 19; */
        for (let i = 0; i < message.detachedObjects.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.detachedObjects[i]);
        /* int64 delete_record_id = 20; */
        if (message.deleteRecordId !== 0n)
            writer.tag(20, WireType.Varint).int64(message.deleteRecordId);
        /* string document_nonce = 21; */
        if (message.documentNonce !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.documentNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EventlogItem
 */
export const EventlogItem = new EventlogItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesRequest$Type extends MessageType<GetStatusRulesRequest> {
    constructor() {
        super("elephant.repository.GetStatusRulesRequest", []);
    }
    create(value?: PartialMessage<GetStatusRulesRequest>): GetStatusRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesRequest): GetStatusRulesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesRequest
 */
export const GetStatusRulesRequest = new GetStatusRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesResponse$Type extends MessageType<GetStatusRulesResponse> {
    constructor() {
        super("elephant.repository.GetStatusRulesResponse", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<GetStatusRulesResponse>): GetStatusRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesResponse): GetStatusRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.StatusRule rules */ 1:
                    message.rules.push(StatusRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.StatusRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            StatusRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesResponse
 */
export const GetStatusRulesResponse = new GetStatusRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesRequest$Type extends MessageType<GetStatusesRequest> {
    constructor() {
        super("elephant.repository.GetStatusesRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusesRequest>): GetStatusesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<GetStatusesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesRequest): GetStatusesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesRequest
 */
export const GetStatusesRequest = new GetStatusesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWorkflowRequest$Type extends MessageType<SetWorkflowRequest> {
    constructor() {
        super("elephant.repository.SetWorkflowRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "message", T: () => DocumentWorkflow }
        ]);
    }
    create(value?: PartialMessage<SetWorkflowRequest>): SetWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<SetWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWorkflowRequest): SetWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* elephant.repository.DocumentWorkflow workflow */ 2:
                    message.workflow = DocumentWorkflow.internalBinaryRead(reader, reader.uint32(), options, message.workflow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* elephant.repository.DocumentWorkflow workflow = 2; */
        if (message.workflow)
            DocumentWorkflow.internalBinaryWrite(message.workflow, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetWorkflowRequest
 */
export const SetWorkflowRequest = new SetWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentWorkflow$Type extends MessageType<DocumentWorkflow> {
    constructor() {
        super("elephant.repository.DocumentWorkflow", [
            { no: 1, name: "step_zero", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "checkpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "negative_checkpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "steps", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentWorkflow>): DocumentWorkflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepZero = "";
        message.checkpoint = "";
        message.negativeCheckpoint = "";
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentWorkflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentWorkflow): DocumentWorkflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string step_zero */ 1:
                    message.stepZero = reader.string();
                    break;
                case /* string checkpoint */ 2:
                    message.checkpoint = reader.string();
                    break;
                case /* string negative_checkpoint */ 3:
                    message.negativeCheckpoint = reader.string();
                    break;
                case /* repeated string steps */ 4:
                    message.steps.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentWorkflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string step_zero = 1; */
        if (message.stepZero !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.stepZero);
        /* string checkpoint = 2; */
        if (message.checkpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.checkpoint);
        /* string negative_checkpoint = 3; */
        if (message.negativeCheckpoint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.negativeCheckpoint);
        /* repeated string steps = 4; */
        for (let i = 0; i < message.steps.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.steps[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentWorkflow
 */
export const DocumentWorkflow = new DocumentWorkflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWorkflowResponse$Type extends MessageType<SetWorkflowResponse> {
    constructor() {
        super("elephant.repository.SetWorkflowResponse", []);
    }
    create(value?: PartialMessage<SetWorkflowResponse>): SetWorkflowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetWorkflowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWorkflowResponse): SetWorkflowResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetWorkflowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetWorkflowResponse
 */
export const SetWorkflowResponse = new SetWorkflowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowRequest$Type extends MessageType<GetWorkflowRequest> {
    constructor() {
        super("elephant.repository.GetWorkflowRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowRequest>): GetWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowRequest): GetWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetWorkflowRequest
 */
export const GetWorkflowRequest = new GetWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowResponse$Type extends MessageType<GetWorkflowResponse> {
    constructor() {
        super("elephant.repository.GetWorkflowResponse", [
            { no: 1, name: "workflow", kind: "message", T: () => DocumentWorkflow },
            { no: 2, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowResponse>): GetWorkflowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updaterUri = "";
        message.updated = "";
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowResponse): GetWorkflowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentWorkflow workflow */ 1:
                    message.workflow = DocumentWorkflow.internalBinaryRead(reader, reader.uint32(), options, message.workflow);
                    break;
                case /* string updater_uri */ 2:
                    message.updaterUri = reader.string();
                    break;
                case /* string updated */ 3:
                    message.updated = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentWorkflow workflow = 1; */
        if (message.workflow)
            DocumentWorkflow.internalBinaryWrite(message.workflow, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string updater_uri = 2; */
        if (message.updaterUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.updaterUri);
        /* string updated = 3; */
        if (message.updated !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetWorkflowResponse
 */
export const GetWorkflowResponse = new GetWorkflowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWorkflowRequest$Type extends MessageType<DeleteWorkflowRequest> {
    constructor() {
        super("elephant.repository.DeleteWorkflowRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteWorkflowRequest>): DeleteWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWorkflowRequest): DeleteWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteWorkflowRequest
 */
export const DeleteWorkflowRequest = new DeleteWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWorkflowResponse$Type extends MessageType<DeleteWorkflowResponse> {
    constructor() {
        super("elephant.repository.DeleteWorkflowResponse", []);
    }
    create(value?: PartialMessage<DeleteWorkflowResponse>): DeleteWorkflowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteWorkflowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWorkflowResponse): DeleteWorkflowResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteWorkflowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteWorkflowResponse
 */
export const DeleteWorkflowResponse = new DeleteWorkflowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatus$Type extends MessageType<WorkflowStatus> {
    constructor() {
        super("elephant.repository.WorkflowStatus", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatus>): WorkflowStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatus): WorkflowStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.WorkflowStatus
 */
export const WorkflowStatus = new WorkflowStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesResponse$Type extends MessageType<GetStatusesResponse> {
    constructor() {
        super("elephant.repository.GetStatusesResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowStatus }
        ]);
    }
    create(value?: PartialMessage<GetStatusesResponse>): GetStatusesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesResponse): GetStatusesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.WorkflowStatus statuses */ 1:
                    message.statuses.push(WorkflowStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.WorkflowStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            WorkflowStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesResponse
 */
export const GetStatusesResponse = new GetStatusesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusRequest$Type extends MessageType<UpdateStatusRequest> {
    constructor() {
        super("elephant.repository.UpdateStatusRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusRequest>): UpdateStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        message.disabled = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusRequest): UpdateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusRequest
 */
export const UpdateStatusRequest = new UpdateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusResponse$Type extends MessageType<UpdateStatusResponse> {
    constructor() {
        super("elephant.repository.UpdateStatusResponse", []);
    }
    create(value?: PartialMessage<UpdateStatusResponse>): UpdateStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusResponse): UpdateStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusResponse
 */
export const UpdateStatusResponse = new UpdateStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleRequest$Type extends MessageType<CreateStatusRuleRequest> {
    constructor() {
        super("elephant.repository.CreateStatusRuleRequest", [
            { no: 1, name: "rule", kind: "message", T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<CreateStatusRuleRequest>): CreateStatusRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleRequest): CreateStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.StatusRule rule */ 1:
                    message.rule = StatusRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.StatusRule rule = 1; */
        if (message.rule)
            StatusRule.internalBinaryWrite(message.rule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleRequest
 */
export const CreateStatusRuleRequest = new CreateStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusRule$Type extends MessageType<StatusRule> {
    constructor() {
        super("elephant.repository.StatusRule", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_rule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "applies_to", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusRule>): StatusRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        message.description = "";
        message.accessRule = false;
        message.appliesTo = [];
        message.expression = "";
        if (value !== undefined)
            reflectionMergePartial<StatusRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusRule): StatusRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool access_rule */ 4:
                    message.accessRule = reader.bool();
                    break;
                case /* repeated string applies_to */ 5:
                    message.appliesTo.push(reader.string());
                    break;
                case /* string expression */ 7:
                    message.expression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool access_rule = 4; */
        if (message.accessRule !== false)
            writer.tag(4, WireType.Varint).bool(message.accessRule);
        /* repeated string applies_to = 5; */
        for (let i = 0; i < message.appliesTo.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.appliesTo[i]);
        /* string expression = 7; */
        if (message.expression !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusRule
 */
export const StatusRule = new StatusRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleResponse$Type extends MessageType<CreateStatusRuleResponse> {
    constructor() {
        super("elephant.repository.CreateStatusRuleResponse", []);
    }
    create(value?: PartialMessage<CreateStatusRuleResponse>): CreateStatusRuleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleResponse): CreateStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleResponse
 */
export const CreateStatusRuleResponse = new CreateStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleRequest$Type extends MessageType<DeleteStatusRuleRequest> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusRuleRequest>): DeleteStatusRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleRequest): DeleteStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export const DeleteStatusRuleRequest = new DeleteStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleResponse$Type extends MessageType<DeleteStatusRuleResponse> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleResponse", []);
    }
    create(value?: PartialMessage<DeleteStatusRuleResponse>): DeleteStatusRuleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleResponse): DeleteStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export const DeleteStatusRuleResponse = new DeleteStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentRequest$Type extends MessageType<GetDocumentRequest> {
    constructor() {
        super("elephant.repository.GetDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "meta_document", kind: "enum", T: () => ["elephant.repository.GetMetaDoc", GetMetaDoc] },
            { no: 6, name: "meta_document_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentRequest>): GetDocumentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        message.status = "";
        message.lock = false;
        message.metaDocument = 0;
        message.metaDocumentVersion = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentRequest): GetDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* bool lock */ 4:
                    message.lock = reader.bool();
                    break;
                case /* elephant.repository.GetMetaDoc meta_document */ 5:
                    message.metaDocument = reader.int32();
                    break;
                case /* int64 meta_document_version */ 6:
                    message.metaDocumentVersion = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* bool lock = 4; */
        if (message.lock !== false)
            writer.tag(4, WireType.Varint).bool(message.lock);
        /* elephant.repository.GetMetaDoc meta_document = 5; */
        if (message.metaDocument !== 0)
            writer.tag(5, WireType.Varint).int32(message.metaDocument);
        /* int64 meta_document_version = 6; */
        if (message.metaDocumentVersion !== 0n)
            writer.tag(6, WireType.Varint).int64(message.metaDocumentVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentRequest
 */
export const GetDocumentRequest = new GetDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentResponse$Type extends MessageType<GetDocumentResponse> {
    constructor() {
        super("elephant.repository.GetDocumentResponse", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "status", kind: "message", T: () => Status },
            { no: 4, name: "meta", kind: "message", T: () => MetaDocument },
            { no: 5, name: "is_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentResponse>): GetDocumentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.isMetaDocument = false;
        message.mainDocument = "";
        if (value !== undefined)
            reflectionMergePartial<GetDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentResponse): GetDocumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* elephant.repository.Status status */ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* elephant.repository.MetaDocument meta */ 4:
                    message.meta = MetaDocument.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* bool is_meta_document */ 5:
                    message.isMetaDocument = reader.bool();
                    break;
                case /* string main_document */ 6:
                    message.mainDocument = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* elephant.repository.Status status = 3; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.MetaDocument meta = 4; */
        if (message.meta)
            MetaDocument.internalBinaryWrite(message.meta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_meta_document = 5; */
        if (message.isMetaDocument !== false)
            writer.tag(5, WireType.Varint).bool(message.isMetaDocument);
        /* string main_document = 6; */
        if (message.mainDocument !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mainDocument);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentResponse
 */
export const GetDocumentResponse = new GetDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetRequest$Type extends MessageType<BulkGetRequest> {
    constructor() {
        super("elephant.repository.BulkGetRequest", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkGetReference }
        ]);
    }
    create(value?: PartialMessage<BulkGetRequest>): BulkGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = [];
        if (value !== undefined)
            reflectionMergePartial<BulkGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetRequest): BulkGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.BulkGetReference documents */ 1:
                    message.documents.push(BulkGetReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.BulkGetReference documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            BulkGetReference.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetRequest
 */
export const BulkGetRequest = new BulkGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetReference$Type extends MessageType<BulkGetReference> {
    constructor() {
        super("elephant.repository.BulkGetReference", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BulkGetReference>): BulkGetReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<BulkGetReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetReference): BulkGetReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetReference
 */
export const BulkGetReference = new BulkGetReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetResponse$Type extends MessageType<BulkGetResponse> {
    constructor() {
        super("elephant.repository.BulkGetResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BulkGetItem }
        ]);
    }
    create(value?: PartialMessage<BulkGetResponse>): BulkGetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<BulkGetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetResponse): BulkGetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.BulkGetItem items */ 1:
                    message.items.push(BulkGetItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.BulkGetItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            BulkGetItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetResponse
 */
export const BulkGetResponse = new BulkGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkGetItem$Type extends MessageType<BulkGetItem> {
    constructor() {
        super("elephant.repository.BulkGetItem", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BulkGetItem>): BulkGetItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<BulkGetItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkGetItem): BulkGetItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkGetItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkGetItem
 */
export const BulkGetItem = new BulkGetItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaDocument$Type extends MessageType<MetaDocument> {
    constructor() {
        super("elephant.repository.MetaDocument", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MetaDocument>): MetaDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<MetaDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaDocument): MetaDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetaDocument
 */
export const MetaDocument = new MetaDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryRequest$Type extends MessageType<GetHistoryRequest> {
    constructor() {
        super("elephant.repository.GetHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "load_statuses", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetHistoryRequest>): GetHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.before = 0n;
        message.loadStatuses = false;
        if (value !== undefined)
            reflectionMergePartial<GetHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryRequest): GetHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 before */ 2:
                    message.before = reader.int64().toBigInt();
                    break;
                case /* bool load_statuses */ 3:
                    message.loadStatuses = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 before = 2; */
        if (message.before !== 0n)
            writer.tag(2, WireType.Varint).int64(message.before);
        /* bool load_statuses = 3; */
        if (message.loadStatuses !== false)
            writer.tag(3, WireType.Varint).bool(message.loadStatuses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryRequest
 */
export const GetHistoryRequest = new GetHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryResponse$Type extends MessageType<GetHistoryResponse> {
    constructor() {
        super("elephant.repository.GetHistoryResponse", [
            { no: 1, name: "versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentVersion }
        ]);
    }
    create(value?: PartialMessage<GetHistoryResponse>): GetHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versions = [];
        if (value !== undefined)
            reflectionMergePartial<GetHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryResponse): GetHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.DocumentVersion versions */ 1:
                    message.versions.push(DocumentVersion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.DocumentVersion versions = 1; */
        for (let i = 0; i < message.versions.length; i++)
            DocumentVersion.internalBinaryWrite(message.versions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryResponse
 */
export const GetHistoryResponse = new GetHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentVersion$Type extends MessageType<DocumentVersion> {
    constructor() {
        super("elephant.repository.DocumentVersion", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "statuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DocumentStatuses } }
        ]);
    }
    create(value?: PartialMessage<DocumentVersion>): DocumentVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.created = "";
        message.creator = "";
        message.meta = {};
        message.statuses = {};
        if (value !== undefined)
            reflectionMergePartial<DocumentVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentVersion): DocumentVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string created */ 2:
                    message.created = reader.string();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* map<string, string> meta */ 4:
                    this.binaryReadMap4(message.meta, reader, options);
                    break;
                case /* map<string, elephant.repository.DocumentStatuses> statuses */ 5:
                    this.binaryReadMap5(message.statuses, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentVersion["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentVersion["meta"] | undefined, val: DocumentVersion["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentVersion.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: DocumentVersion["statuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentVersion["statuses"] | undefined, val: DocumentVersion["statuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DocumentStatuses.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentVersion.statuses");
            }
        }
        map[key ?? ""] = val ?? DocumentStatuses.create();
    }
    internalBinaryWrite(message: DocumentVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string created = 2; */
        if (message.created !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.created);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* map<string, string> meta = 4; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* map<string, elephant.repository.DocumentStatuses> statuses = 5; */
        for (let k of globalThis.Object.keys(message.statuses)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DocumentStatuses.internalBinaryWrite(message.statuses[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentVersion
 */
export const DocumentVersion = new DocumentVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentStatuses$Type extends MessageType<DocumentStatuses> {
    constructor() {
        super("elephant.repository.DocumentStatuses", [
            { no: 5, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<DocumentStatuses>): DocumentStatuses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentStatuses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentStatuses): DocumentStatuses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Status items */ 5:
                    message.items.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentStatuses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Status items = 5; */
        for (let i = 0; i < message.items.length; i++)
            Status.internalBinaryWrite(message.items[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentStatuses
 */
export const DocumentStatuses = new DocumentStatuses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRequest$Type extends MessageType<UpdateRequest> {
    constructor() {
        super("elephant.repository.UpdateRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document", kind: "message", T: () => Document },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusUpdate },
            { no: 6, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 7, name: "import_directive", kind: "message", T: () => ImportDirective },
            { no: 8, name: "lockToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "update_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "if_workflow_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "if_status_heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 12, name: "attach_objects", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 13, name: "detach_objects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateRequest>): UpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.meta = {};
        message.ifMatch = 0n;
        message.status = [];
        message.acl = [];
        message.lockToken = "";
        message.updateMetaDocument = false;
        message.ifWorkflowState = "";
        message.ifStatusHeads = {};
        message.attachObjects = {};
        message.detachObjects = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRequest): UpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* newsdoc.Document document */ 2:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.StatusUpdate status */ 5:
                    message.status.push(StatusUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 6:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* elephant.repository.ImportDirective import_directive */ 7:
                    message.importDirective = ImportDirective.internalBinaryRead(reader, reader.uint32(), options, message.importDirective);
                    break;
                case /* string lockToken */ 8:
                    message.lockToken = reader.string();
                    break;
                case /* bool update_meta_document */ 9:
                    message.updateMetaDocument = reader.bool();
                    break;
                case /* string if_workflow_state */ 10:
                    message.ifWorkflowState = reader.string();
                    break;
                case /* map<string, int64> if_status_heads */ 11:
                    this.binaryReadMap11(message.ifStatusHeads, reader, options);
                    break;
                case /* map<string, string> attach_objects */ 12:
                    this.binaryReadMap12(message.attachObjects, reader, options);
                    break;
                case /* repeated string detach_objects */ 13:
                    message.detachObjects.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: UpdateRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateRequest["meta"] | undefined, val: UpdateRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.UpdateRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap11(map: UpdateRequest["ifStatusHeads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateRequest["ifStatusHeads"] | undefined, val: UpdateRequest["ifStatusHeads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.UpdateRequest.if_status_heads");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    private binaryReadMap12(map: UpdateRequest["attachObjects"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateRequest["attachObjects"] | undefined, val: UpdateRequest["attachObjects"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.UpdateRequest.attach_objects");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* newsdoc.Document document = 2; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> meta = 3; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        /* repeated elephant.repository.StatusUpdate status = 5; */
        for (let i = 0; i < message.status.length; i++)
            StatusUpdate.internalBinaryWrite(message.status[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.ACLEntry acl = 6; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.ImportDirective import_directive = 7; */
        if (message.importDirective)
            ImportDirective.internalBinaryWrite(message.importDirective, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string lockToken = 8; */
        if (message.lockToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lockToken);
        /* bool update_meta_document = 9; */
        if (message.updateMetaDocument !== false)
            writer.tag(9, WireType.Varint).bool(message.updateMetaDocument);
        /* string if_workflow_state = 10; */
        if (message.ifWorkflowState !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.ifWorkflowState);
        /* map<string, int64> if_status_heads = 11; */
        for (let k of globalThis.Object.keys(message.ifStatusHeads))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.ifStatusHeads[k]).join();
        /* map<string, string> attach_objects = 12; */
        for (let k of globalThis.Object.keys(message.attachObjects))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.attachObjects[k]).join();
        /* repeated string detach_objects = 13; */
        for (let i = 0; i < message.detachObjects.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.detachObjects[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateRequest
 */
export const UpdateRequest = new UpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDirective$Type extends MessageType<ImportDirective> {
    constructor() {
        super("elephant.repository.ImportDirective", [
            { no: 1, name: "originally_created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "original_creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportDirective>): ImportDirective {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originallyCreated = "";
        message.originalCreator = "";
        if (value !== undefined)
            reflectionMergePartial<ImportDirective>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDirective): ImportDirective {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string originally_created */ 1:
                    message.originallyCreated = reader.string();
                    break;
                case /* string original_creator */ 2:
                    message.originalCreator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDirective, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string originally_created = 1; */
        if (message.originallyCreated !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originallyCreated);
        /* string original_creator = 2; */
        if (message.originalCreator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalCreator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ImportDirective
 */
export const ImportDirective = new ImportDirective$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("elephant.repository.UpdateResponse", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkUpdateRequest$Type extends MessageType<BulkUpdateRequest> {
    constructor() {
        super("elephant.repository.BulkUpdateRequest", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UpdateRequest }
        ]);
    }
    create(value?: PartialMessage<BulkUpdateRequest>): BulkUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<BulkUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkUpdateRequest): BulkUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.UpdateRequest updates */ 1:
                    message.updates.push(UpdateRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.UpdateRequest updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            UpdateRequest.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkUpdateRequest
 */
export const BulkUpdateRequest = new BulkUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkUpdateResponse$Type extends MessageType<BulkUpdateResponse> {
    constructor() {
        super("elephant.repository.BulkUpdateResponse", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UpdateResponse }
        ]);
    }
    create(value?: PartialMessage<BulkUpdateResponse>): BulkUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<BulkUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkUpdateResponse): BulkUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.UpdateResponse updates */ 1:
                    message.updates.push(UpdateResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.UpdateResponse updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            UpdateResponse.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.BulkUpdateResponse
 */
export const BulkUpdateResponse = new BulkUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("elephant.repository.ValidateRequest", [
            { no: 1, name: "document", kind: "message", T: () => Document }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* newsdoc.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* newsdoc.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateResponse$Type extends MessageType<ValidateResponse> {
    constructor() {
        super("elephant.repository.ValidateResponse", [
            { no: 1, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidationResult }
        ]);
    }
    create(value?: PartialMessage<ValidateResponse>): ValidateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ValidateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateResponse): ValidateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.ValidationResult errors */ 1:
                    message.errors.push(ValidationResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.ValidationResult errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            ValidationResult.internalBinaryWrite(message.errors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateResponse
 */
export const ValidateResponse = new ValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationResult$Type extends MessageType<ValidationResult> {
    constructor() {
        super("elephant.repository.ValidationResult", [
            { no: 1, name: "entity", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EntityRef },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidationResult>): ValidationResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entity = [];
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ValidationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidationResult): ValidationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EntityRef entity */ 1:
                    message.entity.push(EntityRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EntityRef entity = 1; */
        for (let i = 0; i < message.entity.length; i++)
            EntityRef.internalBinaryWrite(message.entity[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidationResult
 */
export const ValidationResult = new ValidationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityRef$Type extends MessageType<EntityRef> {
    constructor() {
        super("elephant.repository.EntityRef", [
            { no: 1, name: "ref_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "rel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntityRef>): EntityRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refType = "";
        message.kind = "";
        message.index = 0n;
        message.name = "";
        message.type = "";
        message.rel = "";
        if (value !== undefined)
            reflectionMergePartial<EntityRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityRef): EntityRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ref_type */ 1:
                    message.refType = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* int64 index */ 3:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string rel */ 6:
                    message.rel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ref_type = 1; */
        if (message.refType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refType);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* int64 index = 3; */
        if (message.index !== 0n)
            writer.tag(3, WireType.Varint).int64(message.index);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string rel = 6; */
        if (message.rel !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EntityRef
 */
export const EntityRef = new EntityRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusUpdate$Type extends MessageType<StatusUpdate> {
    constructor() {
        super("elephant.repository.StatusUpdate", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StatusUpdate>): StatusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = 0n;
        message.meta = {};
        message.ifMatch = 0n;
        if (value !== undefined)
            reflectionMergePartial<StatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusUpdate): StatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: StatusUpdate["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatusUpdate["meta"] | undefined, val: StatusUpdate["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.StatusUpdate.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: StatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* map<string, string> meta = 3; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusUpdate
 */
export const StatusUpdate = new StatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsRequest$Type extends MessageType<UpdatePermissionsRequest> {
    constructor() {
        super("elephant.repository.UpdatePermissionsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<UpdatePermissionsRequest>): UpdatePermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsRequest): UpdatePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated elephant.repository.ACLEntry list */ 2:
                    message.list.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated elephant.repository.ACLEntry list = 2; */
        for (let i = 0; i < message.list.length; i++)
            ACLEntry.internalBinaryWrite(message.list[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsRequest
 */
export const UpdatePermissionsRequest = new UpdatePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsResponse$Type extends MessageType<UpdatePermissionsResponse> {
    constructor() {
        super("elephant.repository.UpdatePermissionsResponse", []);
    }
    create(value?: PartialMessage<UpdatePermissionsResponse>): UpdatePermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsResponse): UpdatePermissionsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdatePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsResponse
 */
export const UpdatePermissionsResponse = new UpdatePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentRequest$Type extends MessageType<DeleteDocumentRequest> {
    constructor() {
        super("elephant.repository.DeleteDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "lockToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocumentRequest>): DeleteDocumentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.meta = {};
        message.ifMatch = 0n;
        message.lockToken = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentRequest): DeleteDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* map<string, string> meta */ 2:
                    this.binaryReadMap2(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 3:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                case /* string lockToken */ 8:
                    message.lockToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: DeleteDocumentRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteDocumentRequest["meta"] | undefined, val: DeleteDocumentRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DeleteDocumentRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* map<string, string> meta = 2; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 3; */
        if (message.ifMatch !== 0n)
            writer.tag(3, WireType.Varint).int64(message.ifMatch);
        /* string lockToken = 8; */
        if (message.lockToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lockToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentRequest
 */
export const DeleteDocumentRequest = new DeleteDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentResponse$Type extends MessageType<DeleteDocumentResponse> {
    constructor() {
        super("elephant.repository.DeleteDocumentResponse", []);
    }
    create(value?: PartialMessage<DeleteDocumentResponse>): DeleteDocumentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentResponse): DeleteDocumentResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentResponse
 */
export const DeleteDocumentResponse = new DeleteDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreRequest$Type extends MessageType<RestoreRequest> {
    constructor() {
        super("elephant.repository.RestoreRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delete_record_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<RestoreRequest>): RestoreRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.deleteRecordId = 0n;
        message.acl = [];
        if (value !== undefined)
            reflectionMergePartial<RestoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreRequest): RestoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 delete_record_id */ 2:
                    message.deleteRecordId = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 3:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 delete_record_id = 2; */
        if (message.deleteRecordId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.deleteRecordId);
        /* repeated elephant.repository.ACLEntry acl = 3; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RestoreRequest
 */
export const RestoreRequest = new RestoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreResponse$Type extends MessageType<RestoreResponse> {
    constructor() {
        super("elephant.repository.RestoreResponse", []);
    }
    create(value?: PartialMessage<RestoreResponse>): RestoreResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RestoreResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreResponse): RestoreResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RestoreResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RestoreResponse
 */
export const RestoreResponse = new RestoreResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurgeRequest$Type extends MessageType<PurgeRequest> {
    constructor() {
        super("elephant.repository.PurgeRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delete_record_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PurgeRequest>): PurgeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.deleteRecordId = 0n;
        if (value !== undefined)
            reflectionMergePartial<PurgeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurgeRequest): PurgeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 delete_record_id */ 2:
                    message.deleteRecordId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PurgeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 delete_record_id = 2; */
        if (message.deleteRecordId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.deleteRecordId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.PurgeRequest
 */
export const PurgeRequest = new PurgeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PurgeResponse$Type extends MessageType<PurgeResponse> {
    constructor() {
        super("elephant.repository.PurgeResponse", []);
    }
    create(value?: PartialMessage<PurgeResponse>): PurgeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PurgeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PurgeResponse): PurgeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PurgeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.PurgeResponse
 */
export const PurgeResponse = new PurgeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDeletedRequest$Type extends MessageType<ListDeletedRequest> {
    constructor() {
        super("elephant.repository.ListDeletedRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "before_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timezone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDeletedRequest>): ListDeletedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.beforeId = 0n;
        message.beforeDate = "";
        message.timezone = "";
        if (value !== undefined)
            reflectionMergePartial<ListDeletedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDeletedRequest): ListDeletedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 before_id */ 2:
                    message.beforeId = reader.int64().toBigInt();
                    break;
                case /* string before_date */ 3:
                    message.beforeDate = reader.string();
                    break;
                case /* string timezone */ 4:
                    message.timezone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDeletedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 before_id = 2; */
        if (message.beforeId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.beforeId);
        /* string before_date = 3; */
        if (message.beforeDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.beforeDate);
        /* string timezone = 4; */
        if (message.timezone !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.timezone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListDeletedRequest
 */
export const ListDeletedRequest = new ListDeletedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDeletedResponse$Type extends MessageType<ListDeletedResponse> {
    constructor() {
        super("elephant.repository.ListDeletedResponse", [
            { no: 1, name: "deletes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeleteRecord }
        ]);
    }
    create(value?: PartialMessage<ListDeletedResponse>): ListDeletedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deletes = [];
        if (value !== undefined)
            reflectionMergePartial<ListDeletedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDeletedResponse): ListDeletedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.DeleteRecord deletes */ 1:
                    message.deletes.push(DeleteRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDeletedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.DeleteRecord deletes = 1; */
        for (let i = 0; i < message.deletes.length; i++)
            DeleteRecord.internalBinaryWrite(message.deletes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListDeletedResponse
 */
export const ListDeletedResponse = new ListDeletedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRecord$Type extends MessageType<DeleteRecord> {
    constructor() {
        super("elephant.repository.DeleteRecord", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 9, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "finalised", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "purged", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteRecord>): DeleteRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.uuid = "";
        message.uri = "";
        message.type = "";
        message.version = 0n;
        message.created = "";
        message.creator = "";
        message.meta = {};
        message.language = "";
        message.finalised = "";
        message.purged = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRecord): DeleteRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* string uri */ 3:
                    message.uri = reader.string();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string created */ 6:
                    message.created = reader.string();
                    break;
                case /* string creator */ 7:
                    message.creator = reader.string();
                    break;
                case /* map<string, string> meta */ 8:
                    this.binaryReadMap8(message.meta, reader, options);
                    break;
                case /* string language */ 9:
                    message.language = reader.string();
                    break;
                case /* string finalised */ 10:
                    message.finalised = reader.string();
                    break;
                case /* string purged */ 11:
                    message.purged = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: DeleteRecord["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteRecord["meta"] | undefined, val: DeleteRecord["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DeleteRecord.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* string uri = 3; */
        if (message.uri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uri);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        /* string created = 6; */
        if (message.created !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.created);
        /* string creator = 7; */
        if (message.creator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.creator);
        /* map<string, string> meta = 8; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* string language = 9; */
        if (message.language !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.language);
        /* string finalised = 10; */
        if (message.finalised !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.finalised);
        /* string purged = 11; */
        if (message.purged !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.purged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteRecord
 */
export const DeleteRecord = new DeleteRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaRequest$Type extends MessageType<GetMetaRequest> {
    constructor() {
        super("elephant.repository.GetMetaRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetaRequest>): GetMetaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetMetaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaRequest): GetMetaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaRequest
 */
export const GetMetaRequest = new GetMetaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaResponse$Type extends MessageType<GetMetaResponse> {
    constructor() {
        super("elephant.repository.GetMetaResponse", [
            { no: 1, name: "meta", kind: "message", T: () => DocumentMeta }
        ]);
    }
    create(value?: PartialMessage<GetMetaResponse>): GetMetaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMetaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaResponse): GetMetaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentMeta meta */ 1:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentMeta meta = 1; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaResponse
 */
export const GetMetaResponse = new GetMetaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMeta$Type extends MessageType<DocumentMeta> {
    constructor() {
        super("elephant.repository.DocumentMeta", [
            { no: 1, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "modified", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } },
            { no: 5, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 6, name: "lock", kind: "message", T: () => Lock },
            { no: 7, name: "is_meta_document", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "main_document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "workflow_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "workflow_checkpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "creator_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "attachments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AttachmentRef },
            { no: 14, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentMeta>): DocumentMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.created = "";
        message.modified = "";
        message.currentVersion = 0n;
        message.heads = {};
        message.acl = [];
        message.isMetaDocument = false;
        message.mainDocument = "";
        message.workflowState = "";
        message.workflowCheckpoint = "";
        message.creatorUri = "";
        message.updaterUri = "";
        message.attachments = [];
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentMeta): DocumentMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string created */ 1:
                    message.created = reader.string();
                    break;
                case /* string modified */ 2:
                    message.modified = reader.string();
                    break;
                case /* int64 current_version */ 3:
                    message.currentVersion = reader.int64().toBigInt();
                    break;
                case /* map<string, elephant.repository.Status> heads */ 4:
                    this.binaryReadMap4(message.heads, reader, options);
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 5:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* elephant.repository.Lock lock */ 6:
                    message.lock = Lock.internalBinaryRead(reader, reader.uint32(), options, message.lock);
                    break;
                case /* bool is_meta_document */ 7:
                    message.isMetaDocument = reader.bool();
                    break;
                case /* string main_document */ 8:
                    message.mainDocument = reader.string();
                    break;
                case /* string workflow_state */ 9:
                    message.workflowState = reader.string();
                    break;
                case /* string workflow_checkpoint */ 10:
                    message.workflowCheckpoint = reader.string();
                    break;
                case /* string creator_uri */ 11:
                    message.creatorUri = reader.string();
                    break;
                case /* string updater_uri */ 12:
                    message.updaterUri = reader.string();
                    break;
                case /* repeated elephant.repository.AttachmentRef attachments */ 13:
                    message.attachments.push(AttachmentRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string nonce */ 14:
                    message.nonce = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentMeta["heads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentMeta["heads"] | undefined, val: DocumentMeta["heads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentMeta.heads");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    internalBinaryWrite(message: DocumentMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string created = 1; */
        if (message.created !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.created);
        /* string modified = 2; */
        if (message.modified !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modified);
        /* int64 current_version = 3; */
        if (message.currentVersion !== 0n)
            writer.tag(3, WireType.Varint).int64(message.currentVersion);
        /* map<string, elephant.repository.Status> heads = 4; */
        for (let k of globalThis.Object.keys(message.heads)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.heads[k], writer, options);
            writer.join().join();
        }
        /* repeated elephant.repository.ACLEntry acl = 5; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.Lock lock = 6; */
        if (message.lock)
            Lock.internalBinaryWrite(message.lock, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool is_meta_document = 7; */
        if (message.isMetaDocument !== false)
            writer.tag(7, WireType.Varint).bool(message.isMetaDocument);
        /* string main_document = 8; */
        if (message.mainDocument !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.mainDocument);
        /* string workflow_state = 9; */
        if (message.workflowState !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.workflowState);
        /* string workflow_checkpoint = 10; */
        if (message.workflowCheckpoint !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.workflowCheckpoint);
        /* string creator_uri = 11; */
        if (message.creatorUri !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.creatorUri);
        /* string updater_uri = 12; */
        if (message.updaterUri !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.updaterUri);
        /* repeated elephant.repository.AttachmentRef attachments = 13; */
        for (let i = 0; i < message.attachments.length; i++)
            AttachmentRef.internalBinaryWrite(message.attachments[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string nonce = 14; */
        if (message.nonce !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentMeta
 */
export const DocumentMeta = new DocumentMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachmentRef$Type extends MessageType<AttachmentRef> {
    constructor() {
        super("elephant.repository.AttachmentRef", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AttachmentRef>): AttachmentRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<AttachmentRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachmentRef): AttachmentRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachmentRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.AttachmentRef
 */
export const AttachmentRef = new AttachmentRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("elephant.repository.Status", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "meta_doc_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.version = 0n;
        message.creator = "";
        message.created = "";
        message.meta = {};
        message.metaDocVersion = 0n;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* string created */ 4:
                    message.created = reader.string();
                    break;
                case /* map<string, string> meta */ 5:
                    this.binaryReadMap5(message.meta, reader, options);
                    break;
                case /* int64 meta_doc_version */ 6:
                    message.metaDocVersion = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Status["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Status["meta"] | undefined, val: Status["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.Status.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* string created = 4; */
        if (message.created !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.created);
        /* map<string, string> meta = 5; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 meta_doc_version = 6; */
        if (message.metaDocVersion !== 0n)
            writer.tag(6, WireType.Varint).int64(message.metaDocVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ACLEntry$Type extends MessageType<ACLEntry> {
    constructor() {
        super("elephant.repository.ACLEntry", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ACLEntry>): ACLEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<ACLEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ACLEntry): ACLEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* repeated string permissions */ 2:
                    message.permissions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ACLEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* repeated string permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.permissions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ACLEntry
 */
export const ACLEntry = new ACLEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Lock$Type extends MessageType<Lock> {
    constructor() {
        super("elephant.repository.Lock", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expires", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "app", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Lock>): Lock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.uri = "";
        message.created = "";
        message.expires = "";
        message.app = "";
        message.comment = "";
        if (value !== undefined)
            reflectionMergePartial<Lock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Lock): Lock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string uri */ 2:
                    message.uri = reader.string();
                    break;
                case /* string created */ 3:
                    message.created = reader.string();
                    break;
                case /* string expires */ 4:
                    message.expires = reader.string();
                    break;
                case /* string app */ 5:
                    message.app = reader.string();
                    break;
                case /* string comment */ 6:
                    message.comment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Lock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string uri = 2; */
        if (message.uri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uri);
        /* string created = 3; */
        if (message.created !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.created);
        /* string expires = 4; */
        if (message.expires !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.expires);
        /* string app = 5; */
        if (message.app !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.app);
        /* string comment = 6; */
        if (message.comment !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.comment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Lock
 */
export const Lock = new Lock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeRequest$Type extends MessageType<RegisterMetaTypeRequest> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "exclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetaTypeRequest>): RegisterMetaTypeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.exclusive = false;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeRequest): RegisterMetaTypeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool exclusive */ 2:
                    message.exclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetaTypeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bool exclusive = 2; */
        if (message.exclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.exclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeRequest
 */
export const RegisterMetaTypeRequest = new RegisterMetaTypeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeResponse$Type extends MessageType<RegisterMetaTypeResponse> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeResponse", []);
    }
    create(value?: PartialMessage<RegisterMetaTypeResponse>): RegisterMetaTypeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeResponse): RegisterMetaTypeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetaTypeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeResponse
 */
export const RegisterMetaTypeResponse = new RegisterMetaTypeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeUseRequest$Type extends MessageType<RegisterMetaTypeUseRequest> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeUseRequest", [
            { no: 1, name: "main_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "meta_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetaTypeUseRequest>): RegisterMetaTypeUseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mainType = "";
        message.metaType = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeUseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeUseRequest): RegisterMetaTypeUseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string main_type */ 1:
                    message.mainType = reader.string();
                    break;
                case /* string meta_type */ 2:
                    message.metaType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetaTypeUseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string main_type = 1; */
        if (message.mainType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mainType);
        /* string meta_type = 2; */
        if (message.metaType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.metaType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeUseRequest
 */
export const RegisterMetaTypeUseRequest = new RegisterMetaTypeUseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetaTypeUseResponse$Type extends MessageType<RegisterMetaTypeUseResponse> {
    constructor() {
        super("elephant.repository.RegisterMetaTypeUseResponse", []);
    }
    create(value?: PartialMessage<RegisterMetaTypeUseResponse>): RegisterMetaTypeUseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetaTypeUseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetaTypeUseResponse): RegisterMetaTypeUseResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetaTypeUseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetaTypeUseResponse
 */
export const RegisterMetaTypeUseResponse = new RegisterMetaTypeUseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaTypesRequest$Type extends MessageType<GetMetaTypesRequest> {
    constructor() {
        super("elephant.repository.GetMetaTypesRequest", []);
    }
    create(value?: PartialMessage<GetMetaTypesRequest>): GetMetaTypesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMetaTypesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaTypesRequest): GetMetaTypesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMetaTypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaTypesRequest
 */
export const GetMetaTypesRequest = new GetMetaTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaTypesResponse$Type extends MessageType<GetMetaTypesResponse> {
    constructor() {
        super("elephant.repository.GetMetaTypesResponse", [
            { no: 1, name: "types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetaTypeInfo }
        ]);
    }
    create(value?: PartialMessage<GetMetaTypesResponse>): GetMetaTypesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<GetMetaTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaTypesResponse): GetMetaTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.MetaTypeInfo types */ 1:
                    message.types.push(MetaTypeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.MetaTypeInfo types = 1; */
        for (let i = 0; i < message.types.length; i++)
            MetaTypeInfo.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaTypesResponse
 */
export const GetMetaTypesResponse = new GetMetaTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentTypesRequest$Type extends MessageType<GetDocumentTypesRequest> {
    constructor() {
        super("elephant.repository.GetDocumentTypesRequest", []);
    }
    create(value?: PartialMessage<GetDocumentTypesRequest>): GetDocumentTypesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocumentTypesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentTypesRequest): GetDocumentTypesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDocumentTypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentTypesRequest
 */
export const GetDocumentTypesRequest = new GetDocumentTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentTypesResponse$Type extends MessageType<GetDocumentTypesResponse> {
    constructor() {
        super("elephant.repository.GetDocumentTypesResponse", [
            { no: 1, name: "types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentTypesResponse>): GetDocumentTypesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocumentTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentTypesResponse): GetDocumentTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string types */ 1:
                    message.types.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string types = 1; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.types[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentTypesResponse
 */
export const GetDocumentTypesResponse = new GetDocumentTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetaTypeInfo$Type extends MessageType<MetaTypeInfo> {
    constructor() {
        super("elephant.repository.MetaTypeInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "used_by", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MetaTypeInfo>): MetaTypeInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.usedBy = [];
        if (value !== undefined)
            reflectionMergePartial<MetaTypeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetaTypeInfo): MetaTypeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string used_by */ 2:
                    message.usedBy.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetaTypeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string used_by = 2; */
        for (let i = 0; i < message.usedBy.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.usedBy[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetaTypeInfo
 */
export const MetaTypeInfo = new MetaTypeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaRequest$Type extends MessageType<RegisterSchemaRequest> {
    constructor() {
        super("elephant.repository.RegisterSchemaRequest", [
            { no: 1, name: "schema", kind: "message", T: () => Schema },
            { no: 2, name: "activate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "schema_sha256", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterSchemaRequest>): RegisterSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activate = false;
        message.schemaUrl = "";
        message.schemaSha256 = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaRequest): RegisterSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Schema schema */ 1:
                    message.schema = Schema.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* bool activate */ 2:
                    message.activate = reader.bool();
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                case /* string schema_sha256 */ 4:
                    message.schemaSha256 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Schema schema = 1; */
        if (message.schema)
            Schema.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool activate = 2; */
        if (message.activate !== false)
            writer.tag(2, WireType.Varint).bool(message.activate);
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        /* string schema_sha256 = 4; */
        if (message.schemaSha256 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.schemaSha256);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaRequest
 */
export const RegisterSchemaRequest = new RegisterSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaResponse$Type extends MessageType<RegisterSchemaResponse> {
    constructor() {
        super("elephant.repository.RegisterSchemaResponse", []);
    }
    create(value?: PartialMessage<RegisterSchemaResponse>): RegisterSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaResponse): RegisterSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaResponse
 */
export const RegisterSchemaResponse = new RegisterSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaRequest$Type extends MessageType<SetActiveSchemaRequest> {
    constructor() {
        super("elephant.repository.SetActiveSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deactivate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetActiveSchemaRequest>): SetActiveSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.deactivate = false;
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaRequest): SetActiveSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* bool deactivate */ 3:
                    message.deactivate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetActiveSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* bool deactivate = 3; */
        if (message.deactivate !== false)
            writer.tag(3, WireType.Varint).bool(message.deactivate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaRequest
 */
export const SetActiveSchemaRequest = new SetActiveSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaResponse$Type extends MessageType<SetActiveSchemaResponse> {
    constructor() {
        super("elephant.repository.SetActiveSchemaResponse", []);
    }
    create(value?: PartialMessage<SetActiveSchemaResponse>): SetActiveSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaResponse): SetActiveSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetActiveSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaResponse
 */
export const SetActiveSchemaResponse = new SetActiveSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("elephant.repository.GetSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("elephant.repository.GetSchemaResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spec", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.spec = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* bytes spec */ 2:
                    message.spec = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* bytes spec = 2; */
        if (message.spec.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasRequest$Type extends MessageType<GetAllActiveSchemasRequest> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasRequest", [
            { no: 1, name: "wait_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "known", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "only_changed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasRequest>): GetAllActiveSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.waitSeconds = 0n;
        message.known = {};
        message.onlyChanged = false;
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasRequest): GetAllActiveSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 wait_seconds */ 1:
                    message.waitSeconds = reader.int64().toBigInt();
                    break;
                case /* map<string, string> known */ 2:
                    this.binaryReadMap2(message.known, reader, options);
                    break;
                case /* bool only_changed */ 3:
                    message.onlyChanged = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GetAllActiveSchemasRequest["known"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAllActiveSchemasRequest["known"] | undefined, val: GetAllActiveSchemasRequest["known"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetAllActiveSchemasRequest.known");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetAllActiveSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 wait_seconds = 1; */
        if (message.waitSeconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.waitSeconds);
        /* map<string, string> known = 2; */
        for (let k of globalThis.Object.keys(message.known))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.known[k]).join();
        /* bool only_changed = 3; */
        if (message.onlyChanged !== false)
            writer.tag(3, WireType.Varint).bool(message.onlyChanged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export const GetAllActiveSchemasRequest = new GetAllActiveSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasResponse$Type extends MessageType<GetAllActiveSchemasResponse> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasResponse", [
            { no: 1, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Schema },
            { no: 2, name: "unchanged", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "removed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasResponse>): GetAllActiveSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemas = [];
        message.unchanged = false;
        message.removed = [];
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasResponse): GetAllActiveSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Schema schemas */ 1:
                    message.schemas.push(Schema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool unchanged */ 2:
                    message.unchanged = reader.bool();
                    break;
                case /* repeated string removed */ 3:
                    message.removed.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllActiveSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Schema schemas = 1; */
        for (let i = 0; i < message.schemas.length; i++)
            Schema.internalBinaryWrite(message.schemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool unchanged = 2; */
        if (message.unchanged !== false)
            writer.tag(2, WireType.Varint).bool(message.unchanged);
        /* repeated string removed = 3; */
        for (let i = 0; i < message.removed.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.removed[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export const GetAllActiveSchemasResponse = new GetAllActiveSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListActiveSchemasRequest$Type extends MessageType<ListActiveSchemasRequest> {
    constructor() {
        super("elephant.repository.ListActiveSchemasRequest", []);
    }
    create(value?: PartialMessage<ListActiveSchemasRequest>): ListActiveSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListActiveSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListActiveSchemasRequest): ListActiveSchemasRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListActiveSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListActiveSchemasRequest
 */
export const ListActiveSchemasRequest = new ListActiveSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListActiveSchemasResponse$Type extends MessageType<ListActiveSchemasResponse> {
    constructor() {
        super("elephant.repository.ListActiveSchemasResponse", [
            { no: 1, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Schema }
        ]);
    }
    create(value?: PartialMessage<ListActiveSchemasResponse>): ListActiveSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemas = [];
        if (value !== undefined)
            reflectionMergePartial<ListActiveSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListActiveSchemasResponse): ListActiveSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Schema schemas */ 1:
                    message.schemas.push(Schema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListActiveSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Schema schemas = 1; */
        for (let i = 0; i < message.schemas.length; i++)
            Schema.internalBinaryWrite(message.schemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ListActiveSchemasResponse
 */
export const ListActiveSchemasResponse = new ListActiveSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("elephant.repository.Schema", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spec", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.spec = "";
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* string spec */ 3:
                    message.spec = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* string spec = 3; */
        if (message.spec !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeprecationsRequest$Type extends MessageType<GetDeprecationsRequest> {
    constructor() {
        super("elephant.repository.GetDeprecationsRequest", []);
    }
    create(value?: PartialMessage<GetDeprecationsRequest>): GetDeprecationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDeprecationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeprecationsRequest): GetDeprecationsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDeprecationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeprecationsRequest
 */
export const GetDeprecationsRequest = new GetDeprecationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deprecation$Type extends MessageType<Deprecation> {
    constructor() {
        super("elephant.repository.Deprecation", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enforced", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Deprecation>): Deprecation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.enforced = false;
        if (value !== undefined)
            reflectionMergePartial<Deprecation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deprecation): Deprecation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* bool enforced */ 2:
                    message.enforced = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deprecation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* bool enforced = 2; */
        if (message.enforced !== false)
            writer.tag(2, WireType.Varint).bool(message.enforced);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Deprecation
 */
export const Deprecation = new Deprecation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeprecationsResponse$Type extends MessageType<GetDeprecationsResponse> {
    constructor() {
        super("elephant.repository.GetDeprecationsResponse", [
            { no: 1, name: "deprecations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Deprecation }
        ]);
    }
    create(value?: PartialMessage<GetDeprecationsResponse>): GetDeprecationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deprecations = [];
        if (value !== undefined)
            reflectionMergePartial<GetDeprecationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeprecationsResponse): GetDeprecationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Deprecation deprecations */ 1:
                    message.deprecations.push(Deprecation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeprecationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Deprecation deprecations = 1; */
        for (let i = 0; i < message.deprecations.length; i++)
            Deprecation.internalBinaryWrite(message.deprecations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeprecationsResponse
 */
export const GetDeprecationsResponse = new GetDeprecationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeprecationRequest$Type extends MessageType<UpdateDeprecationRequest> {
    constructor() {
        super("elephant.repository.UpdateDeprecationRequest", [
            { no: 1, name: "deprecation", kind: "message", T: () => Deprecation }
        ]);
    }
    create(value?: PartialMessage<UpdateDeprecationRequest>): UpdateDeprecationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDeprecationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeprecationRequest): UpdateDeprecationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Deprecation deprecation */ 1:
                    message.deprecation = Deprecation.internalBinaryRead(reader, reader.uint32(), options, message.deprecation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDeprecationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Deprecation deprecation = 1; */
        if (message.deprecation)
            Deprecation.internalBinaryWrite(message.deprecation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateDeprecationRequest
 */
export const UpdateDeprecationRequest = new UpdateDeprecationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeprecationResponse$Type extends MessageType<UpdateDeprecationResponse> {
    constructor() {
        super("elephant.repository.UpdateDeprecationResponse", []);
    }
    create(value?: PartialMessage<UpdateDeprecationResponse>): UpdateDeprecationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDeprecationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeprecationResponse): UpdateDeprecationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateDeprecationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateDeprecationResponse
 */
export const UpdateDeprecationResponse = new UpdateDeprecationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindRequest$Type extends MessageType<RegisterMetricKindRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricKindRequest>): RegisterMetricKindRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aggregation = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindRequest): RegisterMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindRequest
 */
export const RegisterMetricKindRequest = new RegisterMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindResponse$Type extends MessageType<RegisterMetricKindResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricKindResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricKindResponse>): RegisterMetricKindResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindResponse): RegisterMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindResponse
 */
export const RegisterMetricKindResponse = new RegisterMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindRequest$Type extends MessageType<DeleteMetricKindRequest> {
    constructor() {
        super("elephant.repository.DeleteMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMetricKindRequest>): DeleteMetricKindRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindRequest): DeleteMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindRequest
 */
export const DeleteMetricKindRequest = new DeleteMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindResponse$Type extends MessageType<DeleteMetricKindResponse> {
    constructor() {
        super("elephant.repository.DeleteMetricKindResponse", []);
    }
    create(value?: PartialMessage<DeleteMetricKindResponse>): DeleteMetricKindResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindResponse): DeleteMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindResponse
 */
export const DeleteMetricKindResponse = new DeleteMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsRequest$Type extends MessageType<GetMetricKindsRequest> {
    constructor() {
        super("elephant.repository.GetMetricKindsRequest", []);
    }
    create(value?: PartialMessage<GetMetricKindsRequest>): GetMetricKindsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsRequest): GetMetricKindsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMetricKindsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsRequest
 */
export const GetMetricKindsRequest = new GetMetricKindsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsResponse$Type extends MessageType<GetMetricKindsResponse> {
    constructor() {
        super("elephant.repository.GetMetricKindsResponse", [
            { no: 1, name: "kinds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricKind }
        ]);
    }
    create(value?: PartialMessage<GetMetricKindsResponse>): GetMetricKindsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kinds = [];
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsResponse): GetMetricKindsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.MetricKind kinds */ 1:
                    message.kinds.push(MetricKind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricKindsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.MetricKind kinds = 1; */
        for (let i = 0; i < message.kinds.length; i++)
            MetricKind.internalBinaryWrite(message.kinds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsResponse
 */
export const GetMetricKindsResponse = new GetMetricKindsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricKind$Type extends MessageType<MetricKind> {
    constructor() {
        super("elephant.repository.MetricKind", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<MetricKind>): MetricKind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aggregation = 0;
        if (value !== undefined)
            reflectionMergePartial<MetricKind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricKind): MetricKind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricKind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetricKind
 */
export const MetricKind = new MetricKind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricRequest$Type extends MessageType<RegisterMetricRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricRequest>): RegisterMetricRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.kind = "";
        message.label = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricRequest): RegisterMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* int64 value */ 5:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* int64 value = 5; */
        if (message.value !== 0n)
            writer.tag(5, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricRequest
 */
export const RegisterMetricRequest = new RegisterMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricResponse$Type extends MessageType<RegisterMetricResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricResponse>): RegisterMetricResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricResponse): RegisterMetricResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricResponse
 */
export const RegisterMetricResponse = new RegisterMetricResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsRequest$Type extends MessageType<GetMetricsRequest> {
    constructor() {
        super("elephant.repository.GetMetricsRequest", [
            { no: 1, name: "uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kinds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetricsRequest>): GetMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuids = [];
        message.kinds = [];
        if (value !== undefined)
            reflectionMergePartial<GetMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsRequest): GetMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string uuids */ 1:
                    message.uuids.push(reader.string());
                    break;
                case /* repeated string kinds */ 2:
                    message.kinds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.uuids[i]);
        /* repeated string kinds = 2; */
        for (let i = 0; i < message.kinds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.kinds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricsRequest
 */
export const GetMetricsRequest = new GetMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsResponse$Type extends MessageType<GetMetricsResponse> {
    constructor() {
        super("elephant.repository.GetMetricsResponse", [
            { no: 1, name: "documents", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DocumentMetrics } }
        ]);
    }
    create(value?: PartialMessage<GetMetricsResponse>): GetMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = {};
        if (value !== undefined)
            reflectionMergePartial<GetMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsResponse): GetMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, elephant.repository.DocumentMetrics> documents */ 1:
                    this.binaryReadMap1(message.documents, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetMetricsResponse["documents"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMetricsResponse["documents"] | undefined, val: GetMetricsResponse["documents"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DocumentMetrics.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetMetricsResponse.documents");
            }
        }
        map[key ?? ""] = val ?? DocumentMetrics.create();
    }
    internalBinaryWrite(message: GetMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, elephant.repository.DocumentMetrics> documents = 1; */
        for (let k of globalThis.Object.keys(message.documents)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DocumentMetrics.internalBinaryWrite(message.documents[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricsResponse
 */
export const GetMetricsResponse = new GetMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMetrics$Type extends MessageType<DocumentMetrics> {
    constructor() {
        super("elephant.repository.DocumentMetrics", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Metric }
        ]);
    }
    create(value?: PartialMessage<DocumentMetrics>): DocumentMetrics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.metrics = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentMetrics): DocumentMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated elephant.repository.Metric metrics */ 2:
                    message.metrics.push(Metric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated elephant.repository.Metric metrics = 2; */
        for (let i = 0; i < message.metrics.length; i++)
            Metric.internalBinaryWrite(message.metrics[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentMetrics
 */
export const DocumentMetrics = new DocumentMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metric$Type extends MessageType<Metric> {
    constructor() {
        super("elephant.repository.Metric", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Metric>): Metric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.label = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metric): Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* int64 value */ 3:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* int64 value = 3; */
        if (message.value !== 0n)
            writer.tag(3, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Metric
 */
export const Metric = new Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockRequest$Type extends MessageType<LockRequest> {
    constructor() {
        super("elephant.repository.LockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ttl", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "app", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LockRequest>): LockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.ttl = 0;
        message.app = "";
        message.comment = "";
        if (value !== undefined)
            reflectionMergePartial<LockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockRequest): LockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int32 ttl */ 2:
                    message.ttl = reader.int32();
                    break;
                case /* string app */ 3:
                    message.app = reader.string();
                    break;
                case /* string comment */ 4:
                    message.comment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int32 ttl = 2; */
        if (message.ttl !== 0)
            writer.tag(2, WireType.Varint).int32(message.ttl);
        /* string app = 3; */
        if (message.app !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.app);
        /* string comment = 4; */
        if (message.comment !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.comment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.LockRequest
 */
export const LockRequest = new LockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockResponse$Type extends MessageType<LockResponse> {
    constructor() {
        super("elephant.repository.LockResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expires", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LockResponse>): LockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.expires = "";
        if (value !== undefined)
            reflectionMergePartial<LockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockResponse): LockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string expires */ 2:
                    message.expires = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string expires = 2; */
        if (message.expires !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.expires);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.LockResponse
 */
export const LockResponse = new LockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendLockRequest$Type extends MessageType<ExtendLockRequest> {
    constructor() {
        super("elephant.repository.ExtendLockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ttl", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExtendLockRequest>): ExtendLockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.ttl = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ExtendLockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendLockRequest): ExtendLockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int32 ttl */ 2:
                    message.ttl = reader.int32();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendLockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int32 ttl = 2; */
        if (message.ttl !== 0)
            writer.tag(2, WireType.Varint).int32(message.ttl);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ExtendLockRequest
 */
export const ExtendLockRequest = new ExtendLockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockRequest$Type extends MessageType<UnlockRequest> {
    constructor() {
        super("elephant.repository.UnlockRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockRequest>): UnlockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<UnlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockRequest): UnlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UnlockRequest
 */
export const UnlockRequest = new UnlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockResponse$Type extends MessageType<UnlockResponse> {
    constructor() {
        super("elephant.repository.UnlockResponse", []);
    }
    create(value?: PartialMessage<UnlockResponse>): UnlockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UnlockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockResponse): UnlockResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UnlockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UnlockResponse
 */
export const UnlockResponse = new UnlockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWithheldRequest$Type extends MessageType<GetWithheldRequest> {
    constructor() {
        super("elephant.repository.GetWithheldRequest", []);
    }
    create(value?: PartialMessage<GetWithheldRequest>): GetWithheldRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetWithheldRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWithheldRequest): GetWithheldRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetWithheldRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetWithheldRequest
 */
export const GetWithheldRequest = new GetWithheldRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWithheldResponse$Type extends MessageType<GetWithheldResponse> {
    constructor() {
        super("elephant.repository.GetWithheldResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScheduledDocument }
        ]);
    }
    create(value?: PartialMessage<GetWithheldResponse>): GetWithheldResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetWithheldResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWithheldResponse): GetWithheldResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.ScheduledDocument items */ 1:
                    message.items.push(ScheduledDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWithheldResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.ScheduledDocument items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ScheduledDocument.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetWithheldResponse
 */
export const GetWithheldResponse = new GetWithheldResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScheduledDocument$Type extends MessageType<ScheduledDocument> {
    constructor() {
        super("elephant.repository.ScheduledDocument", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "document_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "planning_item", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assignment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "publish", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "scheduled_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScheduledDocument>): ScheduledDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.type = "";
        message.statusId = 0n;
        message.documentVersion = 0n;
        message.planningItem = "";
        message.assignment = "";
        message.publish = "";
        message.scheduledBy = "";
        if (value !== undefined)
            reflectionMergePartial<ScheduledDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScheduledDocument): ScheduledDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* int64 status_id */ 3:
                    message.statusId = reader.int64().toBigInt();
                    break;
                case /* int64 document_version */ 4:
                    message.documentVersion = reader.int64().toBigInt();
                    break;
                case /* string planning_item */ 5:
                    message.planningItem = reader.string();
                    break;
                case /* string assignment */ 6:
                    message.assignment = reader.string();
                    break;
                case /* string publish */ 7:
                    message.publish = reader.string();
                    break;
                case /* string scheduled_by */ 8:
                    message.scheduledBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScheduledDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* int64 status_id = 3; */
        if (message.statusId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.statusId);
        /* int64 document_version = 4; */
        if (message.documentVersion !== 0n)
            writer.tag(4, WireType.Varint).int64(message.documentVersion);
        /* string planning_item = 5; */
        if (message.planningItem !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.planningItem);
        /* string assignment = 6; */
        if (message.assignment !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.assignment);
        /* string publish = 7; */
        if (message.publish !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.publish);
        /* string scheduled_by = 8; */
        if (message.scheduledBy !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.scheduledBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ScheduledDocument
 */
export const ScheduledDocument = new ScheduledDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeliverableInfoRequest$Type extends MessageType<GetDeliverableInfoRequest> {
    constructor() {
        super("elephant.repository.GetDeliverableInfoRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeliverableInfoRequest>): GetDeliverableInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeliverableInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeliverableInfoRequest): GetDeliverableInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeliverableInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeliverableInfoRequest
 */
export const GetDeliverableInfoRequest = new GetDeliverableInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeliverableInfoResponse$Type extends MessageType<GetDeliverableInfoResponse> {
    constructor() {
        super("elephant.repository.GetDeliverableInfoResponse", [
            { no: 1, name: "has_planning_info", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "planning_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "assignment_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeliverableInfoResponse>): GetDeliverableInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasPlanningInfo = false;
        message.planningUuid = "";
        message.assignmentUuid = "";
        message.eventUuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeliverableInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeliverableInfoResponse): GetDeliverableInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_planning_info */ 1:
                    message.hasPlanningInfo = reader.bool();
                    break;
                case /* string planning_uuid */ 2:
                    message.planningUuid = reader.string();
                    break;
                case /* string assignment_uuid */ 3:
                    message.assignmentUuid = reader.string();
                    break;
                case /* string event_uuid */ 4:
                    message.eventUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeliverableInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_planning_info = 1; */
        if (message.hasPlanningInfo !== false)
            writer.tag(1, WireType.Varint).bool(message.hasPlanningInfo);
        /* string planning_uuid = 2; */
        if (message.planningUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.planningUuid);
        /* string assignment_uuid = 3; */
        if (message.assignmentUuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.assignmentUuid);
        /* string event_uuid = 4; */
        if (message.eventUuid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.eventUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDeliverableInfoResponse
 */
export const GetDeliverableInfoResponse = new GetDeliverableInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUploadRequest$Type extends MessageType<CreateUploadRequest> {
    constructor() {
        super("elephant.repository.CreateUploadRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<CreateUploadRequest>): CreateUploadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.contentType = "";
        message.meta = {};
        if (value !== undefined)
            reflectionMergePartial<CreateUploadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUploadRequest): CreateUploadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string content_type */ 2:
                    message.contentType = reader.string();
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: CreateUploadRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CreateUploadRequest["meta"] | undefined, val: CreateUploadRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.CreateUploadRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: CreateUploadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string content_type = 2; */
        if (message.contentType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contentType);
        /* map<string, string> meta = 3; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateUploadRequest
 */
export const CreateUploadRequest = new CreateUploadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUploadResponse$Type extends MessageType<CreateUploadResponse> {
    constructor() {
        super("elephant.repository.CreateUploadResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUploadResponse>): CreateUploadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<CreateUploadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUploadResponse): CreateUploadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUploadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateUploadResponse
 */
export const CreateUploadResponse = new CreateUploadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttachmentsRequest$Type extends MessageType<GetAttachmentsRequest> {
    constructor() {
        super("elephant.repository.GetAttachmentsRequest", [
            { no: 1, name: "documents", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attachment_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "download_link", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAttachmentsRequest>): GetAttachmentsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documents = [];
        message.attachmentName = "";
        message.downloadLink = false;
        if (value !== undefined)
            reflectionMergePartial<GetAttachmentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttachmentsRequest): GetAttachmentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string documents */ 1:
                    message.documents.push(reader.string());
                    break;
                case /* string attachment_name */ 2:
                    message.attachmentName = reader.string();
                    break;
                case /* bool download_link */ 3:
                    message.downloadLink = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttachmentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.documents[i]);
        /* string attachment_name = 2; */
        if (message.attachmentName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attachmentName);
        /* bool download_link = 3; */
        if (message.downloadLink !== false)
            writer.tag(3, WireType.Varint).bool(message.downloadLink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAttachmentsRequest
 */
export const GetAttachmentsRequest = new GetAttachmentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttachmentsResponse$Type extends MessageType<GetAttachmentsResponse> {
    constructor() {
        super("elephant.repository.GetAttachmentsResponse", [
            { no: 1, name: "attachments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AttachmentDetails }
        ]);
    }
    create(value?: PartialMessage<GetAttachmentsResponse>): GetAttachmentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attachments = [];
        if (value !== undefined)
            reflectionMergePartial<GetAttachmentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttachmentsResponse): GetAttachmentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.AttachmentDetails attachments */ 1:
                    message.attachments.push(AttachmentDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttachmentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.AttachmentDetails attachments = 1; */
        for (let i = 0; i < message.attachments.length; i++)
            AttachmentDetails.internalBinaryWrite(message.attachments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAttachmentsResponse
 */
export const GetAttachmentsResponse = new GetAttachmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachmentDetails$Type extends MessageType<AttachmentDetails> {
    constructor() {
        super("elephant.repository.AttachmentDetails", [
            { no: 1, name: "document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "download_link", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "content_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachmentDetails>): AttachmentDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.document = "";
        message.name = "";
        message.version = 0n;
        message.downloadLink = "";
        message.filename = "";
        message.contentType = "";
        if (value !== undefined)
            reflectionMergePartial<AttachmentDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachmentDetails): AttachmentDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document */ 1:
                    message.document = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 version */ 3:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string download_link */ 4:
                    message.downloadLink = reader.string();
                    break;
                case /* string filename */ 5:
                    message.filename = reader.string();
                    break;
                case /* string content_type */ 6:
                    message.contentType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachmentDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document = 1; */
        if (message.document !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.document);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 version = 3; */
        if (message.version !== 0n)
            writer.tag(3, WireType.Varint).int64(message.version);
        /* string download_link = 4; */
        if (message.downloadLink !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.downloadLink);
        /* string filename = 5; */
        if (message.filename !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.filename);
        /* string content_type = 6; */
        if (message.contentType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.contentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.AttachmentDetails
 */
export const AttachmentDetails = new AttachmentDetails$Type();
/**
 * @generated ServiceType for protobuf service elephant.repository.Documents
 */
export const Documents = new ServiceType("elephant.repository.Documents", [
    { name: "Get", options: {}, I: GetDocumentRequest, O: GetDocumentResponse },
    { name: "BulkGet", options: {}, I: BulkGetRequest, O: BulkGetResponse },
    { name: "GetHistory", options: {}, I: GetHistoryRequest, O: GetHistoryResponse },
    { name: "Update", options: {}, I: UpdateRequest, O: UpdateResponse },
    { name: "BulkUpdate", options: {}, I: BulkUpdateRequest, O: BulkUpdateResponse },
    { name: "Validate", options: {}, I: ValidateRequest, O: ValidateResponse },
    { name: "Delete", options: {}, I: DeleteDocumentRequest, O: DeleteDocumentResponse },
    { name: "ListDeleted", options: {}, I: ListDeletedRequest, O: ListDeletedResponse },
    { name: "Restore", options: {}, I: RestoreRequest, O: RestoreResponse },
    { name: "Purge", options: {}, I: PurgeRequest, O: PurgeResponse },
    { name: "GetMeta", options: {}, I: GetMetaRequest, O: GetMetaResponse },
    { name: "Eventlog", options: {}, I: GetEventlogRequest, O: GetEventlogResponse },
    { name: "CompactedEventlog", options: {}, I: GetCompactedEventlogRequest, O: GetCompactedEventlogResponse },
    { name: "GetStatus", options: {}, I: GetStatusRequest, O: GetStatusResponse },
    { name: "GetStatusHistory", options: {}, I: GetStatusHistoryRequest, O: GetStatusHistoryReponse },
    { name: "GetNilStatuses", options: {}, I: GetNilStatusesRequest, O: GetNilStatusesResponse },
    { name: "GetStatusOverview", options: {}, I: GetStatusOverviewRequest, O: GetStatusOverviewResponse },
    { name: "GetPermissions", options: {}, I: GetPermissionsRequest, O: GetPermissionsResponse },
    { name: "Lock", options: {}, I: LockRequest, O: LockResponse },
    { name: "ExtendLock", options: {}, I: ExtendLockRequest, O: LockResponse },
    { name: "Unlock", options: {}, I: UnlockRequest, O: UnlockResponse },
    { name: "GetWithheld", options: {}, I: GetWithheldRequest, O: GetWithheldResponse },
    { name: "GetDeliverableInfo", options: {}, I: GetDeliverableInfoRequest, O: GetDeliverableInfoResponse },
    { name: "CreateUpload", options: {}, I: CreateUploadRequest, O: CreateUploadResponse },
    { name: "GetAttachments", options: {}, I: GetAttachmentsRequest, O: GetAttachmentsResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Schemas
 */
export const Schemas = new ServiceType("elephant.repository.Schemas", [
    { name: "Register", options: {}, I: RegisterSchemaRequest, O: RegisterSchemaResponse },
    { name: "SetActive", options: {}, I: SetActiveSchemaRequest, O: SetActiveSchemaResponse },
    { name: "Get", options: {}, I: GetSchemaRequest, O: GetSchemaResponse },
    { name: "GetAllActive", options: {}, I: GetAllActiveSchemasRequest, O: GetAllActiveSchemasResponse },
    { name: "ListActive", options: {}, I: ListActiveSchemasRequest, O: ListActiveSchemasResponse },
    { name: "RegisterMetaType", options: {}, I: RegisterMetaTypeRequest, O: RegisterMetaTypeResponse },
    { name: "RegisterMetaTypeUse", options: {}, I: RegisterMetaTypeUseRequest, O: RegisterMetaTypeUseResponse },
    { name: "GetDeprecations", options: {}, I: GetDeprecationsRequest, O: GetDeprecationsResponse },
    { name: "UpdateDeprecation", options: {}, I: UpdateDeprecationRequest, O: UpdateDeprecationResponse },
    { name: "GetMetaTypes", options: {}, I: GetMetaTypesRequest, O: GetMetaTypesResponse },
    { name: "GetDocumentTypes", options: {}, I: GetDocumentTypesRequest, O: GetDocumentTypesResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Workflows
 */
export const Workflows = new ServiceType("elephant.repository.Workflows", [
    { name: "UpdateStatus", options: {}, I: UpdateStatusRequest, O: UpdateStatusResponse },
    { name: "GetStatuses", options: {}, I: GetStatusesRequest, O: GetStatusesResponse },
    { name: "CreateStatusRule", options: {}, I: CreateStatusRuleRequest, O: CreateStatusRuleResponse },
    { name: "DeleteStatusRule", options: {}, I: DeleteStatusRuleRequest, O: DeleteStatusRuleResponse },
    { name: "GetStatusRules", options: {}, I: GetStatusRulesRequest, O: GetStatusRulesResponse },
    { name: "SetWorkflow", options: {}, I: SetWorkflowRequest, O: SetWorkflowResponse },
    { name: "GetWorkflow", options: {}, I: GetWorkflowRequest, O: GetWorkflowResponse },
    { name: "DeleteWorkflow", options: {}, I: DeleteWorkflowRequest, O: DeleteWorkflowResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Metrics
 */
export const Metrics = new ServiceType("elephant.repository.Metrics", [
    { name: "RegisterKind", options: {}, I: RegisterMetricKindRequest, O: RegisterMetricKindResponse },
    { name: "DeleteKind", options: {}, I: DeleteMetricKindRequest, O: DeleteMetricKindResponse },
    { name: "GetKinds", options: {}, I: GetMetricKindsRequest, O: GetMetricKindsResponse },
    { name: "RegisterMetric", options: {}, I: RegisterMetricRequest, O: RegisterMetricResponse },
    { name: "GetMetrics", options: {}, I: GetMetricsRequest, O: GetMetricsResponse }
]);
